CCS PCH C Compiler, Version 5.082, 42929               11-Sep-19 15:36

               Filename:   C:\Users\Darvesh\Dropbox\Loowatt_calibrated_codes\Darvesh_Attendant_Controller_Firmware\Attendant_FW\Darvesh\LW_Attendant_Main.lst

               ROM used:   19684 bytes (30%)
                           Largest free fragment is 45848
               RAM used:   600 (16%) at main() level
                           1088 (28%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 31

*
00000:  GOTO   3F40
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  F9D.1
00056:  GOTO   0060
0005A:  BTFSC  F9E.1
0005C:  GOTO   082A
00060:  MOVFF  0E,00
00064:  MOVFF  0F,01
00068:  MOVFF  10,02
0006C:  MOVFF  11,03
00070:  MOVFF  0C,FE9
00074:  MOVFF  07,FEA
00078:  BSF    07.7
0007A:  MOVFF  08,FE1
0007E:  MOVFF  09,FE2
00082:  MOVFF  0A,FD9
00086:  MOVFF  0B,FDA
0008A:  MOVFF  12,FF3
0008E:  MOVFF  13,FF4
00092:  MOVFF  14,FFA
00096:  MOVFF  15,FF5
0009A:  MOVFF  16,FF6
0009E:  MOVFF  17,FF7
000A2:  MOVF   04,W
000A4:  MOVFF  06,FE0
000A8:  MOVFF  05,FD8
000AC:  RETFIE 0
.................... /***************************************************************************** 
.................... *                               System Include Files 
.................... *****************************************************************************/ 
....................  
.................... #INCLUDE <18F66K90.h>   //Flash programmable device  
.................... //////////// Standard Header file for the PIC18F66K90 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F66K90 
000AE:  CLRF   FF7
000B0:  ADDLW  BE
000B2:  MOVWF  FF6
000B4:  MOVLW  00
000B6:  ADDWFC FF7,F
000B8:  TBLRD*+
000BA:  MOVF   FF5,W
000BC:  RETURN 0
000BE:  DATA 4C,6F
000C0:  DATA 6F,57
000C2:  DATA 00,00
000C4:  CLRF   FF7
000C6:  ADDLW  D4
000C8:  MOVWF  FF6
000CA:  MOVLW  00
000CC:  ADDWFC FF7,F
000CE:  TBLRD*+
000D0:  MOVF   FF5,W
000D2:  RETURN 0
000D4:  DATA 31,30
000D6:  DATA 00,00
000D8:  CLRF   FF7
000DA:  ADDLW  E8
000DC:  MOVWF  FF6
000DE:  MOVLW  00
000E0:  ADDWFC FF7,F
000E2:  TBLRD*+
000E4:  MOVF   FF5,W
000E6:  RETURN 0
000E8:  DATA 2E,54
000EA:  DATA 58,54
000EC:  DATA 00,00
000EE:  CLRF   FF7
000F0:  ADDLW  FE
000F2:  MOVWF  FF6
000F4:  MOVLW  00
000F6:  ADDWFC FF7,F
000F8:  TBLRD*+
000FA:  MOVF   FF5,W
000FC:  RETURN 0
000FE:  DATA 54,52
00100:  DATA 41,49
00102:  DATA 4C,45
00104:  DATA 52,3A
00106:  DATA 00,00
00108:  CLRF   FF7
0010A:  ADDLW  18
0010C:  MOVWF  FF6
0010E:  MOVLW  01
00110:  ADDWFC FF7,F
00112:  TBLRD*+
00114:  MOVF   FF5,W
00116:  RETURN 0
00118:  DATA 20,55
0011A:  DATA 4E,49
0011C:  DATA 54,3A
0011E:  DATA 20,00
00120:  CLRF   FF7
00122:  ADDLW  30
00124:  MOVWF  FF6
00126:  MOVLW  01
00128:  ADDWFC FF7,F
0012A:  TBLRD*+
0012C:  MOVF   FF5,W
0012E:  RETURN 0
00130:  DATA 0D,0A
00132:  DATA 00,00
00134:  CLRF   FF7
00136:  ADDLW  44
00138:  MOVWF  FF6
0013A:  MOVLW  01
0013C:  ADDWFC FF7,F
0013E:  TBLRD*+
00140:  MOVF   FF5,W
00142:  RETURN 0
00144:  DATA 44,41
00146:  DATA 54,45
00148:  DATA 2C,54
0014A:  DATA 49,4D
0014C:  DATA 45,2C
0014E:  DATA 4D,41
00150:  DATA 4E,55
00152:  DATA 41,4C
00154:  DATA 20,46
00156:  DATA 57,44
00158:  DATA 2C,4D
0015A:  DATA 41,4E
0015C:  DATA 55,41
0015E:  DATA 4C,20
00160:  DATA 42,41
00162:  DATA 43,4B
00164:  DATA 2C,00
00166:  CLRF   FF7
00168:  ADDLW  76
0016A:  MOVWF  FF6
0016C:  MOVLW  01
0016E:  ADDWFC FF7,F
00170:  TBLRD*+
00172:  MOVF   FF5,W
00174:  RETURN 0
00176:  DATA 4D,41
00178:  DATA 49,4E
0017A:  DATA 20,46
0017C:  DATA 4C,55
0017E:  DATA 53,48
00180:  DATA 2C,4D
00182:  DATA 41,49
00184:  DATA 4E,20
00186:  DATA 42,41
00188:  DATA 47,20
0018A:  DATA 55,53
0018C:  DATA 45,44
0018E:  DATA 2C,53
00190:  DATA 45,43
00192:  DATA 20,46
00194:  DATA 4C,55
00196:  DATA 53,48
00198:  DATA 2C,00
0019A:  CLRF   FF7
0019C:  ADDLW  AA
0019E:  MOVWF  FF6
001A0:  MOVLW  01
001A2:  ADDWFC FF7,F
001A4:  TBLRD*+
001A6:  MOVF   FF5,W
001A8:  RETURN 0
001AA:  DATA 53,45
001AC:  DATA 43,20
001AE:  DATA 42,41
001B0:  DATA 47,20
001B2:  DATA 55,53
001B4:  DATA 45,44
001B6:  DATA 2C,42
001B8:  DATA 41,47
001BA:  DATA 20,55
001BC:  DATA 53,45
001BE:  DATA 44,2C
001C0:  DATA 42,41
001C2:  DATA 47,20
001C4:  DATA 4C,45
001C6:  DATA 46,54
001C8:  DATA 2C,00
001CA:  CLRF   FF7
001CC:  ADDLW  DA
001CE:  MOVWF  FF6
001D0:  MOVLW  01
001D2:  ADDWFC FF7,F
001D4:  TBLRD*+
001D6:  MOVF   FF5,W
001D8:  RETURN 0
001DA:  DATA 4E,4F
001DC:  DATA 20,42
001DE:  DATA 4C,4F
001E0:  DATA 43,4B
001E2:  DATA 53,2C
001E4:  DATA 4E,4F
001E6:  DATA 20,52
001E8:  DATA 45,53
001EA:  DATA 45,54
001EC:  DATA 53,2C
001EE:  DATA 4D,4F
001F0:  DATA 44,45
001F2:  DATA 0D,0A
001F4:  DATA 00,00
001F6:  CLRF   FF7
001F8:  ADDLW  06
001FA:  MOVWF  FF6
001FC:  MOVLW  02
001FE:  ADDWFC FF7,F
00200:  TBLRD*+
00202:  MOVF   FF5,W
00204:  RETURN 0
00206:  DATA 00,00
00208:  CLRF   FF7
0020A:  ADDLW  18
0020C:  MOVWF  FF6
0020E:  MOVLW  02
00210:  ADDWFC FF7,F
00212:  TBLRD*+
00214:  MOVF   FF5,W
00216:  RETURN 0
00218:  DATA 2C,00
0021A:  CLRF   FF7
0021C:  ADDLW  2A
0021E:  MOVWF  FF6
00220:  MOVLW  02
00222:  ADDWFC FF7,F
00224:  TBLRD*+
00226:  MOVF   FF5,W
00228:  RETURN 0
0022A:  DATA 52,55
0022C:  DATA 4E,0D
0022E:  DATA 0A,00
00230:  CLRF   FF7
00232:  ADDLW  40
00234:  MOVWF  FF6
00236:  MOVLW  02
00238:  ADDWFC FF7,F
0023A:  TBLRD*+
0023C:  MOVF   FF5,W
0023E:  RETURN 0
00240:  DATA 53,52
00242:  DATA 56,0D
00244:  DATA 0A,00
00246:  CLRF   FF7
00248:  ADDLW  56
0024A:  MOVWF  FF6
0024C:  MOVLW  02
0024E:  ADDWFC FF7,F
00250:  TBLRD*+
00252:  MOVF   FF5,W
00254:  RETURN 0
00256:  DATA 4F,46
00258:  DATA 46,0D
0025A:  DATA 0A,00
0025C:  CLRF   FF7
0025E:  ADDLW  6C
00260:  MOVWF  FF6
00262:  MOVLW  02
00264:  ADDWFC FF7,F
00266:  TBLRD*+
00268:  MOVF   FF5,W
0026A:  RETURN 0
0026C:  DATA 20,20
0026E:  DATA 20,20
00270:  DATA 20,20
00272:  DATA 20,20
00274:  DATA 20,20
00276:  DATA 00,00
00278:  CLRF   FF7
0027A:  ADDLW  88
0027C:  MOVWF  FF6
0027E:  MOVLW  02
00280:  ADDWFC FF7,F
00282:  TBLRD*+
00284:  MOVF   FF5,W
00286:  RETURN 0
00288:  DATA 20,20
0028A:  DATA 20,00
0028C:  CLRF   FF7
0028E:  ADDLW  9C
00290:  MOVWF  FF6
00292:  MOVLW  02
00294:  ADDWFC FF7,F
00296:  TBLRD*+
00298:  MOVF   FF5,W
0029A:  RETURN 0
0029C:  DATA 20,20
0029E:  DATA 20,20
002A0:  DATA 20,20
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 20,20
002AA:  DATA 20,20
002AC:  DATA 20,20
002AE:  DATA 20,20
002B0:  DATA 00,00
002B2:  CLRF   FF7
002B4:  ADDLW  C2
002B6:  MOVWF  FF6
002B8:  MOVLW  02
002BA:  ADDWFC FF7,F
002BC:  TBLRD*+
002BE:  MOVF   FF5,W
002C0:  RETURN 0
002C2:  DATA 55,4E
002C4:  DATA 49,54
002C6:  DATA 20,20
002C8:  DATA 20,3A
002CA:  DATA 20,20
002CC:  DATA 20,20
002CE:  DATA 20,20
002D0:  DATA 20,20
002D2:  DATA 20,20
002D4:  DATA 20,20
002D6:  DATA 00,00
002D8:  CLRF   FF7
002DA:  ADDLW  E8
002DC:  MOVWF  FF6
002DE:  MOVLW  02
002E0:  ADDWFC FF7,F
002E2:  TBLRD*+
002E4:  MOVF   FF5,W
002E6:  RETURN 0
002E8:  DATA 00,00
002EA:  DATA 1F,00
002EC:  DATA 3B,00
002EE:  DATA 5A,00
002F0:  DATA 78,00
002F2:  DATA 97,00
002F4:  DATA B5,00
002F6:  DATA D4,00
002F8:  DATA F3,00
002FA:  DATA 11,01
002FC:  DATA 30,01
002FE:  DATA 4E,01
00300:  CLRF   FF7
00302:  ADDLW  10
00304:  MOVWF  FF6
00306:  MOVLW  03
00308:  ADDWFC FF7,F
0030A:  TBLRD*+
0030C:  MOVF   FF5,W
0030E:  RETURN 0
00310:  DATA 55,53
00312:  DATA 42,20
00314:  DATA 41,43
00316:  DATA 54,49
00318:  DATA 56,45
0031A:  DATA 00,00
0031C:  CLRF   FF7
0031E:  ADDLW  2C
00320:  MOVWF  FF6
00322:  MOVLW  03
00324:  ADDWFC FF7,F
00326:  TBLRD*+
00328:  MOVF   FF5,W
0032A:  RETURN 0
0032C:  DATA 20,20
0032E:  DATA 55,53
00330:  DATA 42,20
00332:  DATA 46,4C
00334:  DATA 41,53
00336:  DATA 48,20
00338:  DATA 44,52
0033A:  DATA 49,56
0033C:  DATA 45,20
0033E:  DATA 20,20
00340:  DATA 00,00
00342:  CLRF   FF7
00344:  ADDLW  52
00346:  MOVWF  FF6
00348:  MOVLW  03
0034A:  ADDWFC FF7,F
0034C:  TBLRD*+
0034E:  MOVF   FF5,W
00350:  RETURN 0
00352:  DATA 4D,49
00354:  DATA 53,53
00356:  DATA 49,4E
00358:  DATA 47,20
0035A:  DATA 2D,20
0035C:  DATA 49,4E
0035E:  DATA 53,45
00360:  DATA 52,54
00362:  DATA 20,55
00364:  DATA 53,42
00366:  DATA 00,00
00368:  CLRF   FF7
0036A:  ADDLW  78
0036C:  MOVWF  FF6
0036E:  MOVLW  03
00370:  ADDWFC FF7,F
00372:  TBLRD*+
00374:  MOVF   FF5,W
00376:  RETURN 0
00378:  DATA 44,45
0037A:  DATA 56,49
0037C:  DATA 43,45
0037E:  DATA 20,41
00380:  DATA 4E,44
00382:  DATA 20,50
00384:  DATA 52,45
00386:  DATA 53,53
00388:  DATA 20,45
0038A:  DATA 4E,54
0038C:  DATA 00,00
0038E:  CLRF   FF7
00390:  ADDLW  9E
00392:  MOVWF  FF6
00394:  MOVLW  03
00396:  ADDWFC FF7,F
00398:  TBLRD*+
0039A:  MOVF   FF5,W
0039C:  RETURN 0
0039E:  DATA 50,52
003A0:  DATA 45,53
003A2:  DATA 53,20
003A4:  DATA 55,50
003A6:  DATA 20,46
003A8:  DATA 4F,52
003AA:  DATA 20,4E
003AC:  DATA 4F,20
003AE:  DATA 55,53
003B0:  DATA 42,20
003B2:  DATA 00,00
003B4:  CLRF   FF7
003B6:  ADDLW  C4
003B8:  MOVWF  FF6
003BA:  MOVLW  03
003BC:  ADDWFC FF7,F
003BE:  TBLRD*+
003C0:  MOVF   FF5,W
003C2:  RETURN 0
003C4:  DATA 20,20
003C6:  DATA 20,20
003C8:  DATA 49,4E
003CA:  DATA 49,54
003CC:  DATA 49,41
003CE:  DATA 4C,49
003D0:  DATA 53,49
003D2:  DATA 4E,47
003D4:  DATA 20,20
003D6:  DATA 20,20
003D8:  DATA 00,00
003DA:  CLRF   FF7
003DC:  ADDLW  EA
003DE:  MOVWF  FF6
003E0:  MOVLW  03
003E2:  ADDWFC FF7,F
003E4:  TBLRD*+
003E6:  MOVF   FF5,W
003E8:  RETURN 0
003EA:  DATA 20,20
003EC:  DATA 20,20
003EE:  DATA 20,55
003F0:  DATA 53,42
003F2:  DATA 20,44
003F4:  DATA 45,56
003F6:  DATA 49,43
003F8:  DATA 45,20
003FA:  DATA 20,20
003FC:  DATA 20,20
003FE:  DATA 00,00
00400:  CLRF   FF7
00402:  ADDLW  10
00404:  MOVWF  FF6
00406:  MOVLW  04
00408:  ADDWFC FF7,F
0040A:  TBLRD*+
0040C:  MOVF   FF5,W
0040E:  RETURN 0
00410:  DATA 53,65
00412:  DATA 74,20
00414:  DATA 54,72
00416:  DATA 61,69
00418:  DATA 6C,65
0041A:  DATA 72,20
0041C:  DATA 49,44
0041E:  DATA 20,20
00420:  DATA 20,20
00422:  DATA 20,20
00424:  DATA 00,00
00426:  CLRF   FF7
00428:  ADDLW  36
0042A:  MOVWF  FF6
0042C:  MOVLW  04
0042E:  ADDWFC FF7,F
00430:  TBLRD*+
00432:  MOVF   FF5,W
00434:  RETURN 0
00436:  DATA 53,2F
00438:  DATA 52,20
0043A:  DATA 55,6E
0043C:  DATA 69,74
0043E:  DATA 20,41
00440:  DATA 64,64
00442:  DATA 72,65
00444:  DATA 73,73
00446:  DATA 65,73
00448:  DATA 20,20
0044A:  DATA 00,00
0044C:  CLRF   FF7
0044E:  ADDLW  5C
00450:  MOVWF  FF6
00452:  MOVLW  04
00454:  ADDWFC FF7,F
00456:  TBLRD*+
00458:  MOVF   FF5,W
0045A:  RETURN 0
0045C:  DATA 53,65
0045E:  DATA 74,20
00460:  DATA 54,69
00462:  DATA 6D,65
00464:  DATA 20,61
00466:  DATA 6E,64
00468:  DATA 20,44
0046A:  DATA 61,74
0046C:  DATA 65,20
0046E:  DATA 20,20
00470:  DATA 00,00
00472:  CLRF   FF7
00474:  ADDLW  82
00476:  MOVWF  FF6
00478:  MOVLW  04
0047A:  ADDWFC FF7,F
0047C:  TBLRD*+
0047E:  MOVF   FF5,W
00480:  RETURN 0
00482:  DATA 45,78
00484:  DATA 69,74
00486:  DATA 20,20
00488:  DATA 20,20
0048A:  DATA 20,20
0048C:  DATA 20,20
0048E:  DATA 20,20
00490:  DATA 20,20
00492:  DATA 20,20
00494:  DATA 20,20
00496:  DATA 00,00
00498:  CLRF   FF7
0049A:  ADDLW  A8
0049C:  MOVWF  FF6
0049E:  MOVLW  04
004A0:  ADDWFC FF7,F
004A2:  TBLRD*+
004A4:  MOVF   FF5,W
004A6:  RETURN 0
004A8:  DATA 53,65
004AA:  DATA 74,20
004AC:  DATA 55,6E
004AE:  DATA 69,74
004B0:  DATA 20,41
004B2:  DATA 64,64
004B4:  DATA 72,65
004B6:  DATA 73,73
004B8:  DATA 65,73
004BA:  DATA 20,20
004BC:  DATA 00,00
004BE:  CLRF   FF7
004C0:  ADDLW  CE
004C2:  MOVWF  FF6
004C4:  MOVLW  04
004C6:  ADDWFC FF7,F
004C8:  TBLRD*+
004CA:  MOVF   FF5,W
004CC:  RETURN 0
004CE:  DATA 52,65
004D0:  DATA 73,65
004D2:  DATA 74,20
004D4:  DATA 41,6C
004D6:  DATA 6C,20
004D8:  DATA 61,64
004DA:  DATA 64,72
004DC:  DATA 65,73
004DE:  DATA 73,65
004E0:  DATA 73,20
004E2:  DATA 00,00
004E4:  CLRF   FF7
004E6:  ADDLW  F4
004E8:  MOVWF  FF6
004EA:  MOVLW  04
004EC:  ADDWFC FF7,F
004EE:  TBLRD*+
004F0:  MOVF   FF5,W
004F2:  RETURN 0
004F4:  DATA 21,41
004F6:  DATA 42,4F
004F8:  DATA 55,54
004FA:  DATA 20,54
004FC:  DATA 4F,20
004FE:  DATA 52,45
00500:  DATA 53,45
00502:  DATA 54,20
00504:  DATA 41,4C
00506:  DATA 4C,21
00508:  DATA 00,00
0050A:  CLRF   FF7
0050C:  ADDLW  1A
0050E:  MOVWF  FF6
00510:  MOVLW  05
00512:  ADDWFC FF7,F
00514:  TBLRD*+
00516:  MOVF   FF5,W
00518:  RETURN 0
0051A:  DATA 20,20
0051C:  DATA 20,41
0051E:  DATA 52,45
00520:  DATA 20,59
00522:  DATA 4F,55
00524:  DATA 20,53
00526:  DATA 55,52
00528:  DATA 45,3F
0052A:  DATA 3F,20
0052C:  DATA 20,20
0052E:  DATA 00,00
00530:  CLRF   FF7
00532:  ADDLW  40
00534:  MOVWF  FF6
00536:  MOVLW  05
00538:  ADDWFC FF7,F
0053A:  TBLRD*+
0053C:  MOVF   FF5,W
0053E:  RETURN 0
00540:  DATA 20,50
00542:  DATA 72,65
00544:  DATA 73,73
00546:  DATA 20,45
00548:  DATA 4E,54
0054A:  DATA 20,74
0054C:  DATA 6F,20
0054E:  DATA 61,62
00550:  DATA 6F,72
00552:  DATA 74,20
00554:  DATA 00,00
00556:  CLRF   FF7
00558:  ADDLW  66
0055A:  MOVWF  FF6
0055C:  MOVLW  05
0055E:  ADDWFC FF7,F
00560:  TBLRD*+
00562:  MOVF   FF5,W
00564:  RETURN 0
00566:  DATA 20,50
00568:  DATA 72,65
0056A:  DATA 73,73
0056C:  DATA 20,55
0056E:  DATA 50,20
00570:  DATA 72,65
00572:  DATA 73,65
00574:  DATA 74,20
00576:  DATA 41,4C
00578:  DATA 4C,20
0057A:  DATA 00,00
0057C:  CLRF   FF7
0057E:  ADDLW  8C
00580:  MOVWF  FF6
00582:  MOVLW  05
00584:  ADDWFC FF7,F
00586:  TBLRD*+
00588:  MOVF   FF5,W
0058A:  RETURN 0
0058C:  DATA 20,20
0058E:  DATA 20,20
00590:  DATA 20,20
00592:  DATA 20,20
00594:  DATA 20,20
00596:  DATA 20,20
00598:  DATA 20,20
0059A:  DATA 20,20
0059C:  DATA 20,20
0059E:  DATA 20,00
005A0:  CLRF   FF7
005A2:  ADDLW  B0
005A4:  MOVWF  FF6
005A6:  MOVLW  05
005A8:  ADDWFC FF7,F
005AA:  TBLRD*+
005AC:  MOVF   FF5,W
005AE:  RETURN 0
005B0:  DATA 55,73
005B2:  DATA 65,20
005B4:  DATA 55,70
005B6:  DATA 2F,44
005B8:  DATA 6F,77
005BA:  DATA 6E,20
005BC:  DATA 74,6F
005BE:  DATA 20,73
005C0:  DATA 65,6C
005C2:  DATA 20,20
005C4:  DATA 00,00
005C6:  CLRF   FF7
005C8:  ADDLW  D6
005CA:  MOVWF  FF6
005CC:  MOVLW  05
005CE:  ADDWFC FF7,F
005D0:  TBLRD*+
005D2:  MOVF   FF5,W
005D4:  RETURN 0
005D6:  DATA 50,72
005D8:  DATA 65,73
005DA:  DATA 73,20
005DC:  DATA 45,6E
005DE:  DATA 74,20
005E0:  DATA 77,68
005E2:  DATA 65,6E
005E4:  DATA 20,64
005E6:  DATA 6F,6E
005E8:  DATA 65,20
005EA:  DATA 00,00
005EC:  CLRF   FF7
005EE:  ADDLW  FC
005F0:  MOVWF  FF6
005F2:  MOVLW  05
005F4:  ADDWFC FF7,F
005F6:  TBLRD*+
005F8:  MOVF   FF5,W
005FA:  RETURN 0
005FC:  DATA 4D,41
005FE:  DATA 58,20
00600:  DATA 41,44
00602:  DATA 44,52
00604:  DATA 45,53
00606:  DATA 53,20
00608:  DATA 52,45
0060A:  DATA 41,43
0060C:  DATA 48,45
0060E:  DATA 44,20
00610:  DATA 00,00
00612:  CLRF   FF7
00614:  ADDLW  22
00616:  MOVWF  FF6
00618:  MOVLW  06
0061A:  ADDWFC FF7,F
0061C:  TBLRD*+
0061E:  MOVF   FF5,W
00620:  RETURN 0
00622:  DATA 53,65
00624:  DATA 74,20
00626:  DATA 55,6E
00628:  DATA 69,74
0062A:  DATA 20,41
0062C:  DATA 64,64
0062E:  DATA 72,65
00630:  DATA 73,73
00632:  DATA 20,20
00634:  DATA 20,20
00636:  DATA 00,00
00638:  CLRF   FF7
0063A:  ADDLW  48
0063C:  MOVWF  FF6
0063E:  MOVLW  06
00640:  ADDWFC FF7,F
00642:  TBLRD*+
00644:  MOVF   FF5,W
00646:  RETURN 0
00648:  DATA 50,72
0064A:  DATA 65,73
0064C:  DATA 73,20
0064E:  DATA 45,6E
00650:  DATA 74,65
00652:  DATA 72,20
00654:  DATA 74,6F
00656:  DATA 20,45
00658:  DATA 78,69
0065A:  DATA 74,20
0065C:  DATA 00,00
0065E:  CLRF   FF7
00660:  ADDLW  6E
00662:  MOVWF  FF6
00664:  MOVLW  06
00666:  ADDWFC FF7,F
00668:  TBLRD*+
0066A:  MOVF   FF5,W
0066C:  RETURN 0
0066E:  DATA 50,72
00670:  DATA 65,73
00672:  DATA 73,20
00674:  DATA 55,50
00676:  DATA 20,74
00678:  DATA 6F,20
0067A:  DATA 73,65
0067C:  DATA 74,20
0067E:  DATA 61,64
00680:  DATA 64,72
00682:  DATA 00,00
00684:  CLRF   FF7
00686:  ADDLW  94
00688:  MOVWF  FF6
0068A:  MOVLW  06
0068C:  ADDWFC FF7,F
0068E:  TBLRD*+
00690:  MOVF   FF5,W
00692:  RETURN 0
00694:  DATA 20,21
00696:  DATA 4F,50
00698:  DATA 45,52
0069A:  DATA 41,54
0069C:  DATA 49,4F
0069E:  DATA 4E,20
006A0:  DATA 46,41
006A2:  DATA 49,4C
006A4:  DATA 45,44
006A6:  DATA 21,20
006A8:  DATA 00,00
006AA:  CLRF   FF7
006AC:  ADDLW  BA
006AE:  MOVWF  FF6
006B0:  MOVLW  06
006B2:  ADDWFC FF7,F
006B4:  TBLRD*+
006B6:  MOVF   FF5,W
006B8:  RETURN 0
006BA:  DATA 20,20
006BC:  DATA 20,41
006BE:  DATA 44,44
006C0:  DATA 52,45
006C2:  DATA 53,53
006C4:  DATA 20,53
006C6:  DATA 45,54
006C8:  DATA 20,4F
006CA:  DATA 4B,20
006CC:  DATA 20,20
006CE:  DATA 00,00
006D0:  CLRF   FF7
006D2:  ADDLW  E0
006D4:  MOVWF  FF6
006D6:  MOVLW  06
006D8:  ADDWFC FF7,F
006DA:  TBLRD*+
006DC:  MOVF   FF5,W
006DE:  RETURN 0
006E0:  DATA 4D,41
006E2:  DATA 58,20
006E4:  DATA 41,44
006E6:  DATA 44,52
006E8:  DATA 45,53
006EA:  DATA 53,20
006EC:  DATA 52,45
006EE:  DATA 41,43
006F0:  DATA 48,45
006F2:  DATA 44,21
006F4:  DATA 00,00
006F6:  CLRF   FF7
006F8:  ADDLW  06
006FA:  MOVWF  FF6
006FC:  MOVLW  07
006FE:  ADDWFC FF7,F
00700:  TBLRD*+
00702:  MOVF   FF5,W
00704:  RETURN 0
00706:  DATA 20,20
00708:  DATA 20,20
0070A:  DATA 20,50
0070C:  DATA 6C,65
0070E:  DATA 61,73
00710:  DATA 65,20
00712:  DATA 57,61
00714:  DATA 69,74
00716:  DATA 20,20
00718:  DATA 20,20
0071A:  DATA 00,00
0071C:  CLRF   FF7
0071E:  ADDLW  2C
00720:  MOVWF  FF6
00722:  MOVLW  07
00724:  ADDWFC FF7,F
00726:  TBLRD*+
00728:  MOVF   FF5,W
0072A:  RETURN 0
0072C:  DATA 20,20
0072E:  DATA 52,45
00730:  DATA 53,45
00732:  DATA 54,20
00734:  DATA 53,55
00736:  DATA 43,43
00738:  DATA 45,53
0073A:  DATA 53,46
0073C:  DATA 55,4C
0073E:  DATA 20,20
00740:  DATA 00,00
00742:  CLRF   FF7
00744:  ADDLW  52
00746:  MOVWF  FF6
00748:  MOVLW  07
0074A:  ADDWFC FF7,F
0074C:  TBLRD*+
0074E:  MOVF   FF5,W
00750:  RETURN 0
00752:  DATA 45,4E
00754:  DATA 54,45
00756:  DATA 52,20
00758:  DATA 44,41
0075A:  DATA 54,45
0075C:  DATA 20,20
0075E:  DATA 59,59
00760:  DATA 20,4D
00762:  DATA 4D,20
00764:  DATA 44,44
00766:  DATA 00,00
00768:  CLRF   FF7
0076A:  ADDLW  78
0076C:  MOVWF  FF6
0076E:  MOVLW  07
00770:  ADDWFC FF7,F
00772:  TBLRD*+
00774:  MOVF   FF5,W
00776:  RETURN 0
00778:  DATA 45,4E
0077A:  DATA 54,45
0077C:  DATA 52,20
0077E:  DATA 54,49
00780:  DATA 4D,45
00782:  DATA 20,20
00784:  DATA 48,48
00786:  DATA 20,4D
00788:  DATA 4D,20
0078A:  DATA 53,53
0078C:  DATA 00,00
0078E:  CLRF   FF7
00790:  ADDLW  9E
00792:  MOVWF  FF6
00794:  MOVLW  07
00796:  ADDWFC FF7,F
00798:  TBLRD*+
0079A:  MOVF   FF5,W
0079C:  RETURN 0
0079E:  DATA 43,4F
007A0:  DATA 4D,4D
007A2:  DATA 53,20
007A4:  DATA 46,41
007A6:  DATA 49,4C
007A8:  DATA 00,00
007AA:  CLRF   FF7
007AC:  ADDLW  BA
007AE:  MOVWF  FF6
007B0:  MOVLW  07
007B2:  ADDWFC FF7,F
007B4:  TBLRD*+
007B6:  MOVF   FF5,W
007B8:  RETURN 0
007BA:  DATA 42,4C
007BC:  DATA 4F,43
007BE:  DATA 4B,41
007C0:  DATA 47,45
007C2:  DATA 20,20
007C4:  DATA 00,00
*
01A82:  MOVLB  2
01A84:  MOVF   xFD,W
01A86:  CLRF   01
01A88:  SUBWF  xFC,W
01A8A:  BC    1A92
01A8C:  MOVFF  2FC,00
01A90:  BRA    1AAA
01A92:  CLRF   00
01A94:  MOVLW  08
01A96:  MOVWF  xFE
01A98:  RLCF   xFC,F
01A9A:  RLCF   00,F
01A9C:  MOVF   xFD,W
01A9E:  SUBWF  00,W
01AA0:  BTFSC  FD8.0
01AA2:  MOVWF  00
01AA4:  RLCF   01,F
01AA6:  DECFSZ xFE,F
01AA8:  BRA    1A98
01AAA:  MOVLB  0
01AAC:  RETURN 0
*
029D2:  MOVLB  2
029D4:  CLRF   xF6
029D6:  CLRF   xF7
029D8:  MOVLW  01
029DA:  MOVWF  xF8
029DC:  CLRF   FDA
029DE:  CLRF   FD9
029E0:  MOVLW  02
029E2:  MOVWF  xFB
029E4:  MOVLW  EE
029E6:  MOVWF  xFA
029E8:  MOVLW  02
029EA:  MOVWF  FEA
029EC:  MOVLW  F2
029EE:  MOVWF  FE9
029F0:  MOVFF  2FB,FE2
029F4:  MOVFF  2FA,FE1
029F8:  MOVFF  2F8,2F9
029FC:  BCF    FD8.0
029FE:  MOVF   FE5,W
02A00:  MULWF  FEE
02A02:  MOVF   FF3,W
02A04:  ADDWFC xF6,F
02A06:  MOVF   FF4,W
02A08:  ADDWFC xF7,F
02A0A:  DECFSZ xF9,F
02A0C:  BRA    29FC
02A0E:  MOVFF  2F6,FDE
02A12:  MOVFF  2F7,2F6
02A16:  CLRF   xF7
02A18:  BTFSC  FD8.0
02A1A:  INCF   xF7,F
02A1C:  INCF   xFA,F
02A1E:  BTFSC  FD8.2
02A20:  INCF   xFB,F
02A22:  INCF   xF8,F
02A24:  MOVF   xF8,W
02A26:  SUBLW  05
02A28:  BNZ   29E8
02A2A:  MOVLB  0
02A2C:  RETURN 0
02A2E:  BTFSC  FD8.1
02A30:  BRA    2A3A
02A32:  MOVLW  02
02A34:  MOVWF  FEA
02A36:  MOVLW  60
02A38:  MOVWF  FE9
02A3A:  CLRF   00
02A3C:  CLRF   01
02A3E:  CLRF   02
02A40:  CLRF   03
02A42:  MOVLB  2
02A44:  CLRF   x60
02A46:  CLRF   x61
02A48:  CLRF   x62
02A4A:  CLRF   x63
02A4C:  MOVF   x5F,W
02A4E:  IORWF  x5E,W
02A50:  IORWF  x5D,W
02A52:  IORWF  x5C,W
02A54:  BZ    2AAE
02A56:  MOVLW  20
02A58:  MOVWF  x64
02A5A:  BCF    FD8.0
02A5C:  RLCF   x58,F
02A5E:  RLCF   x59,F
02A60:  RLCF   x5A,F
02A62:  RLCF   x5B,F
02A64:  RLCF   x60,F
02A66:  RLCF   x61,F
02A68:  RLCF   x62,F
02A6A:  RLCF   x63,F
02A6C:  MOVF   x5F,W
02A6E:  SUBWF  x63,W
02A70:  BNZ   2A82
02A72:  MOVF   x5E,W
02A74:  SUBWF  x62,W
02A76:  BNZ   2A82
02A78:  MOVF   x5D,W
02A7A:  SUBWF  x61,W
02A7C:  BNZ   2A82
02A7E:  MOVF   x5C,W
02A80:  SUBWF  x60,W
02A82:  BNC   2AA2
02A84:  MOVF   x5C,W
02A86:  SUBWF  x60,F
02A88:  MOVF   x5D,W
02A8A:  BTFSS  FD8.0
02A8C:  INCFSZ x5D,W
02A8E:  SUBWF  x61,F
02A90:  MOVF   x5E,W
02A92:  BTFSS  FD8.0
02A94:  INCFSZ x5E,W
02A96:  SUBWF  x62,F
02A98:  MOVF   x5F,W
02A9A:  BTFSS  FD8.0
02A9C:  INCFSZ x5F,W
02A9E:  SUBWF  x63,F
02AA0:  BSF    FD8.0
02AA2:  RLCF   00,F
02AA4:  RLCF   01,F
02AA6:  RLCF   02,F
02AA8:  RLCF   03,F
02AAA:  DECFSZ x64,F
02AAC:  BRA    2A5A
02AAE:  MOVFF  260,FEF
02AB2:  MOVFF  261,FEC
02AB6:  MOVFF  262,FEC
02ABA:  MOVFF  263,FEC
02ABE:  MOVLB  0
02AC0:  GOTO   44E0 (RETURN)
*
02FB8:  CLRF   01
02FBA:  CLRF   02
02FBC:  CLRF   00
02FBE:  CLRF   03
02FC0:  MOVLB  2
02FC2:  MOVF   xF9,W
02FC4:  BNZ   2FCA
02FC6:  MOVF   xF8,W
02FC8:  BZ    2FFA
02FCA:  MOVLW  10
02FCC:  MOVWF  xFA
02FCE:  BCF    FD8.0
02FD0:  RLCF   xF6,F
02FD2:  RLCF   xF7,F
02FD4:  RLCF   00,F
02FD6:  RLCF   03,F
02FD8:  MOVF   xF9,W
02FDA:  SUBWF  03,W
02FDC:  BNZ   2FE2
02FDE:  MOVF   xF8,W
02FE0:  SUBWF  00,W
02FE2:  BNC   2FF2
02FE4:  MOVF   xF8,W
02FE6:  SUBWF  00,F
02FE8:  BTFSS  FD8.0
02FEA:  DECF   03,F
02FEC:  MOVF   xF9,W
02FEE:  SUBWF  03,F
02FF0:  BSF    FD8.0
02FF2:  RLCF   01,F
02FF4:  RLCF   02,F
02FF6:  DECFSZ xFA,F
02FF8:  BRA    2FCE
02FFA:  MOVLB  0
02FFC:  RETURN 0
....................  
.................... #list 
....................  
....................  
.................... /***************************************************************************** 
.................... *                             Pre-processor Directives 
.................... *****************************************************************************/  
.................... #USE DELAY (Clock = 8000000)    //the value used for the library routines             
*
00BF4:  MOVLW  02
00BF6:  MOVWF  FEA
00BF8:  MOVLW  FC
00BFA:  MOVWF  FE9
00BFC:  MOVF   FEF,W
00BFE:  BZ    0C1A
00C00:  MOVLW  02
00C02:  MOVWF  01
00C04:  CLRF   00
00C06:  DECFSZ 00,F
00C08:  BRA    0C06
00C0A:  DECFSZ 01,F
00C0C:  BRA    0C04
00C0E:  MOVLW  97
00C10:  MOVWF  00
00C12:  DECFSZ 00,F
00C14:  BRA    0C12
00C16:  DECFSZ FEF,F
00C18:  BRA    0C00
00C1A:  RETURN 0
*
011C6:  MOVLW  09
011C8:  MOVLB  3
011CA:  SUBWF  x97,F
011CC:  BNC   11E6
011CE:  MOVLW  03
011D0:  MOVWF  FEA
011D2:  MOVLW  97
011D4:  MOVWF  FE9
011D6:  BCF    FD8.0
011D8:  RRCF   FEF,F
011DA:  MOVF   FEF,W
011DC:  BZ    11E6
011DE:  BRA    11E2
011E0:  NOP   
011E2:  DECFSZ FEF,F
011E4:  BRA    11E0
011E6:  MOVLB  0
011E8:  GOTO   1240 (RETURN)
.................... #USE FAST_IO(ALL)   //compiler to perform I/O without programming Dir. reg. Port A     
.................... #FUSES NOWDT,NOPROTECT,HSH,NOPUT,NOPLLEN 
.................... /***************************************************************************** 
.................... *                               File Includes 
.................... *****************************************************************************/ 
.................... #INCLUDE <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0226A:  MOVFF  2F5,2F9
0226E:  MOVFF  2F4,2F8
02272:  MOVFF  2F9,03
02276:  MOVLB  2
02278:  MOVFF  2F8,FE9
0227C:  MOVFF  03,FEA
02280:  MOVF   FEF,F
02282:  BZ    2290
02284:  INCF   xF8,F
02286:  BTFSC  FD8.2
02288:  INCF   xF9,F
0228A:  MOVLB  0
0228C:  BRA    2272
0228E:  MOVLB  2
....................    while(*s2 != '\0') 
02290:  MOVFF  2F7,03
02294:  MOVFF  2F6,FE9
02298:  MOVFF  03,FEA
0229C:  MOVF   FEF,F
0229E:  BZ    22CE
....................    { 
....................       *s = *s2; 
022A0:  MOVFF  2F9,2FB
022A4:  MOVFF  2F7,03
022A8:  MOVFF  2F6,FE9
022AC:  MOVFF  03,FEA
022B0:  MOVFF  FEF,2FC
022B4:  MOVFF  2FB,FEA
022B8:  MOVFF  2F8,FE9
022BC:  MOVFF  2FC,FEF
....................       ++s; 
022C0:  INCF   xF8,F
022C2:  BTFSC  FD8.2
022C4:  INCF   xF9,F
....................       ++s2; 
022C6:  INCF   xF6,F
022C8:  BTFSC  FD8.2
022CA:  INCF   xF7,F
022CC:  BRA    2290
....................    } 
....................  
....................    *s = '\0'; 
022CE:  MOVFF  2F9,03
022D2:  MOVFF  2F8,FE9
022D6:  MOVFF  03,FEA
022DA:  CLRF   FEF
....................    return(s1); 
022DC:  MOVFF  2F4,01
022E0:  MOVFF  2F5,02
022E4:  MOVLB  0
022E6:  RETURN 0
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <LW_Attendant_MAIN.h> 
.................... /*************************************************************************************** 
.................... * Name:   	MAIN.h 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	Loo Watt Attendant main header file. 
.................... * 
.................... * History: 	30/03/15	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
....................  
.................... //Defines 
.................... #BYTE 	OSCCON = 0x0FD3 
.................... #BYTE	TRISA = 0x0F92 
.................... #BYTE	TRISB = 0x0F93 
.................... #BYTE	TRISC = 0x0F94 
.................... #BYTE	TRISD = 0x0F95 
.................... #BYTE	TRISE = 0x0F96 
.................... #BYTE	TRISF = 0x0F97 
.................... #BYTE	TRISG = 0x0F98 
.................... #BYTE	PORTA = 0x0F80		 
.................... #BYTE	PORTB = 0x0F81		 
.................... #BYTE	PORTC = 0x0F82		 
.................... #BYTE	PORTD = 0x0F83		 
.................... #BYTE	PORTE = 0x0F84		 
.................... #BYTE	PORTF = 0x0F85		 
.................... #BYTE	PORTG = 0x0F86		 
.................... #BYTE 	ADCON0 = 0x0FC2 
.................... #BYTE	ADCON1 = 0x0FC1 
.................... #BYTE	ADCON2 = 0x0FC0 
.................... #BYTE	ANCON0 = 0x0F25 
.................... #BYTE	ANCON1 = 0x0F24 
.................... #BYTE 	ANCON2 = 0x0F23 
.................... #BYTE  	ADRESL = 0x0FC3 
.................... #BYTE 	ADRESH = 0x0FC4 
.................... #BYTE	PIR1 = 0x0F9E 
.................... #BYTE 	PIR2 = 0x0FA1 
.................... #BYTE	PIR3 = 0x0FA4 
.................... #BYTE	PIR4 = 0x0FB7 
.................... #BYTE	PIE1 = 0x0F9D 
.................... #BYTE	PIE2 = 0x0FA0 
.................... #BYTE	PIE3 = 0x0FA3 
.................... #BYTE	PIE4 = 0x0FB6 
.................... #BYTE	WDTCON = 0x0FD1 
.................... #BYTE	T1CON = 0x0FCD 
.................... #BYTE	TMR1L = 0x0FCE 
.................... #BYTE	TMR1H = 0x0FCF 
.................... #BYTE	T2CON = 0x0FCA 
.................... #BYTE	PR2 = 0x0FCB 
.................... #BYTE 	TMR2 = 0x0FCC 
.................... #BYTE	INTCON = 0x0FF2 
.................... #BYTE	COMMS_IN = 0x0FAE		//RCREG1 
.................... #BYTE	COMMS_OUT = 0x0FAD		//TXREG1 
.................... #BYTE	SPBRG1 = 0x0FAF 
.................... #BYTE	RCSTA1 = 0x0FAB 
.................... #BYTE	TXSTA1 = 0x0FAC 
.................... #BYTE	BAUD1CON = 0x0F65 
.................... #BYTE	BAUD2CON = 0x0F20 
.................... #BYTE	RCREG2 = 0x0F1D 
.................... #BYTE	TXREG2 = 0x0F1C 
.................... #BYTE	SPBRG2 = 0x0F1E 
.................... #BYTE	RCSTA2= 0x0F22 
.................... #BYTE	TXSTA2 = 0x0F21 
.................... #BYTE	BAUD2CON = 0x0F20 
.................... #BYTE 	CCP4CON = 0x0F0F 
.................... #BYTE 	CCPTMRS0 = 0x0F2D 
.................... #BYTE 	PR4 = 0x0F04 
.................... #BYTE 	CCPR4L = 0x0F10 
.................... #BYTE 	T4CON = 0x0F03 
....................  
.................... #BYTE	T6CON = 0x0F39 
.................... #BYTE	PR6 = 0x0F3A 
.................... #BYTE	TMR6 = 0x0F3B 
....................  
.................... #BIT	GO_DONE = ADCON0.1 
.................... #BIT	TMR1ON = T1CON.0 
.................... #BIT	TMR1IF = PIR1.0 
.................... #BIT	TRMT1 = TXSTA1.1 
.................... #BIT	TX_EN = TXSTA1.5 
.................... #BIT	RX_EN = RCSTA1.4 
.................... #BIT	RC1IF = PIR1.5 
.................... #BIT	CREN = RCSTA1.4 
.................... #BIT	TMR2_IF = PIR1.1 
.................... #BIT 	TMR2IE = PIE1.1 
.................... #BIT	TMR6IE = PIE3.3 
.................... #BIT	TMR6IF = PIR3.1 
....................  
.................... #define MK3 
.................... //IO Defines 
.................... #BIT	LCD_RS = PORTG.3 
.................... #BIT	LCD_RW = PORTG.0 
.................... #ifdef 	MK3 
.................... #BIT	LCD_E = PORTD.0 
.................... #else 
.................... #BIT	LCD_E = PORTD.0 
.................... #endif 
.................... #BIT	BUZZER_ON = PORTG.4 
.................... #BIT	EXT_LAMP = PORTD.7 
.................... #BIT	DIR1 = PORTC.0 
.................... #BIT	DIR2 = PORTC.1 
.................... #BIT	RTC_CE = PORTC.3 
.................... #BIT	NO_USB = PORTF.1 
.................... #BIT	PB_UP = PORTF.3 
.................... #BIT	PB_DN = PORTF.4 
.................... #BIT	PB_ENT = PORTF.5 
.................... //SPI pins 
.................... #BIT 	SPI_SCK = PORTC.2 
.................... #BIT	SPI_SDO = PORTC.4 
.................... #BIT	SPI_SDI = PORTC.5 
....................  
....................  
....................  
.................... //Macro's 
.................... #define DO_NOP #asm NOP #endasm 
.................... #define wait1us DO_NOP;DO_NOP; 
.................... #define START_GET_DATA_TO TMR1ON = 1; 
.................... #define STOP_GET_DATA_TO TMR1ON = 0; 
.................... #define RST_GET_DATA_TO set_timer1(0); TMR1IF = 0; 
.................... #define RX1_BYTE_RDY RC1IF == 1			//used in statements, no ; required. 
.................... #define RX1_BYTE_NRDY RC1IF == 0		//used in statements, no ; required. 
.................... #define FLASHING_ON TMR2_IF = 0; TMR2 = 0; TMR2IE = 1; 
.................... #define FLASHING_OFF TMR2IE = 0; 
.................... #define INT_EN INTCON |= 0b11000000; 
.................... #define INT_DIS INTCON &= 0b00111111; 
.................... #define TIME_ON TMR6IE = 1; 
.................... #define TIME_OFF TMR6IE = 0; 
.................... #define TOP_LINE_FLASH_ON FLASH_REG[0] |= BIT0; 
.................... #define TOP_LINE_FLASH_OFF FLASH_REG[0] &= ~BIT0; 
.................... #define RTC_EN 	SPI_SCK = 0; DO_NOP; RTC_CE = 1; 
.................... #define RTC_DIS RTC_CE = 0;SPI_SCK = 0; 
....................  
.................... #define DIR_RX 0 
.................... #define DIR_TX 1 
.................... #define ON 1 
.................... #define OFF 0 
....................  
.................... //Bit defines 
.................... #define BIT0 0b00000001 
.................... #define BIT1 0b00000010 
.................... #define BIT2 0b00000100 
.................... #define BIT3 0b00001000 
.................... #define BIT4 0b00010000 
.................... #define BIT5 0b00100000 
.................... #define BIT6 0b01000000 
.................... #define BIT7 0b10000000 
....................  
.................... #define BATT_LOW_LIM 716 
....................  
....................  
.................... //display defines 
.................... #define DAT 0 
.................... #define CMD 1 
.................... #define max_retries 5 
....................  
.................... //Display flashing defines. 
.................... #define half_way 25 
.................... #define flash_rate 50 
....................  
.................... //time structure 
.................... typedef struct TIME { 
.................... 	int8 sec; 
.................... 	int8 min; 
.................... 	int8 hour; 
.................... 	int8 day; 
.................... 	int8 month; 
.................... 	int8 year; 
.................... }; 
....................  
.................... //STATES 
.................... #define SERVICE 0 
.................... #define RUNNING 1 
.................... #define OO_SERVICE 2 
....................  
.................... //STATUS BYTE is as follows. 
.................... //bit15-8 used for the number of resets taken place since unit started 
.................... //bit0-7 (in order) 
.................... #define RUNSTATE  0b00000010 
.................... #define SERSTATE  0b00000001 
.................... #define OOSERVICE 0b00000100 
.................... #define LOW_FILM  0b00001000 
.................... #define blockage  0b00010000 
.................... //#define LS_RESET  0b00000111 
.................... //#define RST_STATE 0b11111000 
.................... //#define OVERFLOW_LIM 40000		//allows up to 40M of film. 
....................  
....................  
.................... //Data unions 
.................... #define UNION_LEN 20 
.................... typedef union LOG_UNION { 
.................... 	int16	LOG_DATA[UNION_LEN/2]; 
.................... 	int8	LOG_RXD[UNION_LEN];	 
.................... }; 
....................  
.................... //For single bits logic  1 is active state. For len, it is 0-2 (11 is empty loo). 
.................... //Note the first flush after the bag_reset will reset the bag_reset bit. 
.................... #define LooSTATUS	LOG_DATA[0] 
.................... #define MFB_USED	LOG_DATA[1] 
.................... #define MBB_USED 	LOG_DATA[2] 
.................... #define NOI_FLUSH	LOG_DATA[3] 
.................... #define NOIB_USED	LOG_DATA[4] 
.................... #define NOS_FLUSH	LOG_DATA[5] 
.................... #define NOSB_USED	LOG_DATA[6] 
.................... #define BAG_USED	LOG_DATA[7] 
.................... #define BAG_LEFT	LOG_DATA[8] 
.................... #define NO_BLOCKS	LOG_DATA[9] 
.................... 	 
.................... //RS485 Defines 
.................... #define NO	0 
.................... #define YES 1 
....................  
.................... //loo error defines 
.................... #define RUN_BIT BIT5 
.................... #define LOW_BATT BIT4 
.................... #define ERR_BIT BIT3 
.................... #define BLK_BIT BIT2 
.................... #define SER_BIT BIT1 
.................... #define LOW_BIT BIT0 
....................  
.................... #define Max_no_LOOS 6		//max units in a trailer, Changed PH 121217 renamed to Max_no_LOOS, and 6 max 
....................  
.................... //EEPROM Defines 
.................... #define trailer_addr 0		//EEPROM address of trailer ident. 
.................... #define no_of_units 1		//actual number of loos fitted 
....................  
....................  
.................... struct TIME TIME_STAMP; 
.................... struct TIME *pTIME_STAMP; 
.................... union LOG_UNION DATA_IN[Max_no_LOOS]; 
.................... union LOG_UNION *pDATA_IN; 
....................  
.................... //Timings 
.................... #define W_HOUR 120		//based on a USB update rate of 30 seconds = 1 hour. 
....................  
.................... int8 FLASH_REG[2]; 
.................... int8 scroll_offset; 
.................... int8 ALARM_FLAG; 
.................... int8 FLASH_FLAG; 
.................... int8 tick;				//gets set every LCD update used for general timing/de-bounce 
.................... int8 target_USB = 0xFF; 
.................... int8 target_MENU = 0xFF; 
.................... char TRAILER_ID; 
.................... int8 no_of_loos; 
.................... int8 max_scroll_offset; 
.................... int8 *Ploo[11]; 
.................... int8 Loo_FREG[11]; 
.................... int8 Loo_FL[11]; 
.................... int8 SEND_FLT_FLAG = 0;	//tells attendant new fault so send to webserver. 
....................  
.................... #INCLUDE <LW_Attendant_display.h> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Attendant_Display.H 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	prototype header file. 
.................... * 
.................... * History: 	28/02/16	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
.................... void FLASH_TIMER (void); 
.................... void init_display (void); 
.................... void write_text_LCD (int8 line, int8 col, char *pLCD_TEXT); 
.................... void set_run_display_ram(); 
.................... #BIT LCD_BF = PORTE.7 
....................  
.................... //LCD defines 
.................... #define CLEAR_DISP 	0b00000001 
.................... #define RETURN_HOME	0b00000010 
.................... #define DISP_MODE 	0b00001100 
.................... #define FUNC_SET	0b00111100 
.................... #define ENTRY_MODE 	0b00000110 
.................... #define SET_DDRAM	0b10000000	//0-40H in bits 0-6. 
.................... #define LCD_IO PORTE 
.................... #define WRITE_IR	LCD_RS = 0;LCD_RW = 0; 
.................... //#define READ_BUSY	LCD_RS = 0;LCD_RW = 1; 
.................... #define WRITE_DATA  LCD_RS = 1;LCD_RW = 0; 
.................... #define CYCLE_E 	LCD_E = 1;DO_NOP;LCD_E = 0; 
.................... #define LCD_IO_DIR_IP TRISE = 0xFF; 
.................... #define LCD_IO_DIR_OP TRISE = 0; 
....................  
.................... //initialisation for programs 
....................  
.................... //Display line addresses in LCD DDRAM. 
.................... #define LINE_1 0x00 
.................... #define LINE_2 0x40 
.................... #define LINE_3 0x14 
.................... #define LINE_4 0x54 
....................  
....................  
.................... //LCD RAM AREA, though it only has 4 lines, there can be six total  
.................... char display_ram[6][21];	//21 for the end of string terminator 
.................... #define line1_flash_A 10 
.................... #define No_Line1_chars 9 
.................... #define line_flash_A1 6 
.................... #define line_flash_A2 16 
.................... #define flash_col 6 
.................... #define flush_rem_col 2 
.................... #define No_Line_flash_chars 3 
.................... #define NORMAL 1 
.................... #define MENU 0 
....................  
.................... int8 display_type; 
....................  
....................  
....................  
.................... #INCLUDE <LW_Attendant_Func.h> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Controller_Func.H 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	prototype header file. 
.................... * 
.................... * History: 	30/03/15	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
.................... void INIT_USART1 (void); 
.................... void INIT_USART2 (void); 
.................... void INIT_ALL (void); 
.................... int16 CHK_BATT (void); 
.................... int1 chk_up (void); 
.................... int1 chk_dn (void); 
.................... int1 chk_ent (void); 
.................... void read_RTC (void); 
.................... void write_RTC (void); 
.................... int8 SEND_SPI (int8 spid_out); 
.................... int8 write_to_usb (int8 USB_CMD, char *pUSB_DATA); 
.................... int8 USB_ready (void); 
.................... void convert_to_3digits (int16 INPUT, char *pOUTPUT); 
.................... long long Convert_To_UNIX_TIME (void); 
....................  
.................... #define debounce_time 2 
.................... #define USB_I2C_ADDR 82	//actuallly 41, but I2C addr is top 7 bits 
.................... #define I2C_FILENAME 0 
.................... #define IC2_WRITE 1 
.................... #define I2C_APPEND 2 
.................... #define I2C_READB 3 
.................... #define I2C_READ_SETLINE 4 
.................... #define I2C_FLASH_READY 99 
....................  
.................... //RTC defines 
.................... #define read_time_date 0b10001000 
.................... #define write_time_date 0b00001000 
....................  
.................... //Misc 
.................... #define RESET_TO 0xFF 
....................  
.................... #INCLUDE <LW_Attendant_RS485.h> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Attendant_RS485.h 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * 
.................... * Description: 
.................... *		 	RS485 Functions/Interrupts Header file. 
.................... * 
.................... * History: 	14/04/15	Initial code started 
.................... *			15/03/16	New Comms function 
.................... *			 
.................... ****************************************************************************************/ 
.................... int1 send_RS485 (int8 action, int8 L_ADR); 
.................... void send_data_to_WEB(int8 *pFAULTS); 
.................... void delim_send (int8 data_in); 
.................... //Command Defines for comms 
.................... #define STX 0x02 
.................... #define ETX 0x03 
.................... #define DLE 0x10 
.................... #define STX_POS 0 
.................... #define LEN_POS 1 
.................... #define ADR_POS 2 
.................... #define DATA_START 3 
.................... #define BCC_POS 4		//only set/reset address, not for send data 
.................... #define OVERHEAD 4		 
.................... #define MAX_ADR 10 
.................... #define SET_ADR 0x1E 
.................... #define RST_ADR 0x4A 
.................... #define SND_DATA 0x2D 
....................  
.................... #INCLUDE <LW_Attendant_Menu.h> 
.................... /**************************************************************************** 
.................... * File Name: LooWatt Attendant_Menu.h 
.................... * Purpose: 
.................... *		Menu header file.          
.................... * Parameters Passed:  
.................... * Parameters Returned:  
.................... * Globals: 
.................... * Date Started 	28/02/2016	 
.................... * Version		Not released 
.................... ****************************************************************************/   
.................... void display_USB_warning (int8 action); 
.................... int1 set_init_mess (void); 
.................... void set_top_menu (void); 
.................... void reset_disp_ram (void); 
.................... void set_reset_addr_menu (void); 
.................... void reset_all_addr_menu (void); 
.................... void menu_sys (void); 
.................... void set_trailer_id (void); 
.................... void set_rst_units (void); 
.................... void set_unit_addrs (void); 
.................... int8 rst_unit_addrs (void);		//return to break from function. 
.................... void set_time_date (void); 
.................... int8 convert_BCD_to_No (int8 BCDin,int8 Act_Bits); 
.................... int8 convert_No_to_BCD (int8 no_in); 
.................... int8 enter_number (int8 hi_lim, int8 lo_lim, int8 number, int8 line, int8 col); 
....................  
.................... #define ID_POS 9 
.................... #define disp_warning 1 
.................... #define rst_warning 0 
....................  
.................... #INCLUDE <LW_Attendant_USB.h> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Controller_Func.H 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	prototype header file. 
.................... * 
.................... * History: 	30/03/15	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
.................... int1 initalise_USB_files(int8 trailer_ID); 
.................... int1 send_log_data_to_USB(void); 
.................... void number_to_string (int16 number, *string_out); 
.................... void date_to_string (struct TIME *pTIME, char *string); 
.................... void time_to_string (struct TIME *pTIME, char *string); 
....................  
....................  
.................... #INCLUDE <LW_Attendant_USB.c> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Attendant_USB.C 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	Control PCB functions. 
.................... * 
.................... * History: 	22/06/15	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
.................... int1 initalise_USB_files(int8 trailer_ID) 
.................... {	//creates file headers for all possible units 
.................... 	extern int8 no_of_loos; 
.................... 	int8 loo; 
.................... 	char I2C_TEXT[40], CAT_TEXT[15]; 
....................   
.................... 	for(loo =1; loo <= no_of_loos; loo++) 
*
024A0:  MOVLW  01
024A2:  MOVLB  2
024A4:  MOVWF  x51
024A6:  MOVF   x51,W
024A8:  MOVLB  0
024AA:  SUBWF  xA7,W
024AC:  BTFSS  FD8.0
024AE:  BRA    2736
.................... 	{	 
.................... 		//create string to set the file we want to append to 
.................... 		I2C_TEXT = "LooW"; 
024B0:  MOVLW  02
024B2:  MOVWF  FEA
024B4:  MOVLW  52
024B6:  MOVWF  FE9
024B8:  MOVLW  00
024BA:  CALL   00AE
024BE:  TBLRD*-
024C0:  TBLRD*+
024C2:  MOVF   FF5,W
024C4:  MOVWF  FEE
024C6:  IORLW  00
024C8:  BNZ   24C0
.................... 		if(loo < 10) CAT_TEXT[0] = '0'+loo; CAT_TEXT[1] = 0; 
024CA:  MOVLB  2
024CC:  MOVF   x51,W
024CE:  SUBLW  09
024D0:  BNC   24D8
024D2:  MOVLW  30
024D4:  ADDWF  x51,W
024D6:  MOVWF  x7A
024D8:  CLRF   x7B
.................... 		if(loo == 10) CAT_TEXT = "10"; 
024DA:  MOVF   x51,W
024DC:  SUBLW  0A
024DE:  BNZ   24FE
024E0:  MOVLW  02
024E2:  MOVWF  FEA
024E4:  MOVLW  7A
024E6:  MOVWF  FE9
024E8:  MOVLW  00
024EA:  MOVLB  0
024EC:  CALL   00C4
024F0:  TBLRD*-
024F2:  TBLRD*+
024F4:  MOVF   FF5,W
024F6:  MOVWF  FEE
024F8:  IORLW  00
024FA:  BNZ   24F2
024FC:  MOVLB  2
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
024FE:  MOVLW  02
02500:  MOVWF  xF5
02502:  MOVLW  52
02504:  MOVWF  xF4
02506:  MOVLW  02
02508:  MOVWF  xF7
0250A:  MOVLW  7A
0250C:  MOVWF  xF6
0250E:  MOVLB  0
02510:  RCALL  226A
.................... 		CAT_TEXT = ".TXT"; 
02512:  MOVLW  02
02514:  MOVWF  FEA
02516:  MOVLW  7A
02518:  MOVWF  FE9
0251A:  MOVLW  00
0251C:  CALL   00D8
02520:  TBLRD*-
02522:  TBLRD*+
02524:  MOVF   FF5,W
02526:  MOVWF  FEE
02528:  IORLW  00
0252A:  BNZ   2522
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
0252C:  MOVLW  02
0252E:  MOVLB  2
02530:  MOVWF  xF5
02532:  MOVLW  52
02534:  MOVWF  xF4
02536:  MOVLW  02
02538:  MOVWF  xF7
0253A:  MOVLW  7A
0253C:  MOVWF  xF6
0253E:  MOVLB  0
02540:  RCALL  226A
.................... 		write_to_usb(I2C_FILENAME,I2C_TEXT); 
02542:  MOVLB  2
02544:  CLRF   xF4
02546:  MOVLW  02
02548:  MOVWF  xF6
0254A:  MOVLW  52
0254C:  MOVWF  xF5
0254E:  MOVLB  0
02550:  RCALL  2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
02552:  RCALL  23D2
02554:  MOVF   01,F
02556:  BNZ   255E
02558:  MOVLW  00
0255A:  MOVWF  01
0255C:  BRA    2736
....................  
.................... 		//now for the file header e.g. TRAILER A: UNIT 1: 
.................... 		I2C_TEXT = "TRAILER:"; 
0255E:  MOVLW  02
02560:  MOVWF  FEA
02562:  MOVLW  52
02564:  MOVWF  FE9
02566:  MOVLW  00
02568:  CALL   00EE
0256C:  TBLRD*-
0256E:  TBLRD*+
02570:  MOVF   FF5,W
02572:  MOVWF  FEE
02574:  IORLW  00
02576:  BNZ   256E
.................... 		CAT_TEXT[0] = trailer_ID; 
02578:  MOVFF  250,27A
.................... 		CAT_TEXT[1] = 0; 
0257C:  MOVLB  2
0257E:  CLRF   x7B
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
02580:  MOVLW  02
02582:  MOVWF  xF5
02584:  MOVLW  52
02586:  MOVWF  xF4
02588:  MOVLW  02
0258A:  MOVWF  xF7
0258C:  MOVLW  7A
0258E:  MOVWF  xF6
02590:  MOVLB  0
02592:  RCALL  226A
.................... 		CAT_TEXT = " UNIT: "; 
02594:  MOVLW  02
02596:  MOVWF  FEA
02598:  MOVLW  7A
0259A:  MOVWF  FE9
0259C:  MOVLW  00
0259E:  CALL   0108
025A2:  TBLRD*-
025A4:  TBLRD*+
025A6:  MOVF   FF5,W
025A8:  MOVWF  FEE
025AA:  IORLW  00
025AC:  BNZ   25A4
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
025AE:  MOVLW  02
025B0:  MOVLB  2
025B2:  MOVWF  xF5
025B4:  MOVLW  52
025B6:  MOVWF  xF4
025B8:  MOVLW  02
025BA:  MOVWF  xF7
025BC:  MOVLW  7A
025BE:  MOVWF  xF6
025C0:  MOVLB  0
025C2:  RCALL  226A
.................... 		if(loo < 10) CAT_TEXT[0] = '0'+loo;CAT_TEXT[1] = 0; 
025C4:  MOVLB  2
025C6:  MOVF   x51,W
025C8:  SUBLW  09
025CA:  BNC   25D2
025CC:  MOVLW  30
025CE:  ADDWF  x51,W
025D0:  MOVWF  x7A
025D2:  CLRF   x7B
.................... 		if(loo == 10) CAT_TEXT = "10"; 
025D4:  MOVF   x51,W
025D6:  SUBLW  0A
025D8:  BNZ   25F8
025DA:  MOVLW  02
025DC:  MOVWF  FEA
025DE:  MOVLW  7A
025E0:  MOVWF  FE9
025E2:  MOVLW  00
025E4:  MOVLB  0
025E6:  CALL   00C4
025EA:  TBLRD*-
025EC:  TBLRD*+
025EE:  MOVF   FF5,W
025F0:  MOVWF  FEE
025F2:  IORLW  00
025F4:  BNZ   25EC
025F6:  MOVLB  2
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
025F8:  MOVLW  02
025FA:  MOVWF  xF5
025FC:  MOVLW  52
025FE:  MOVWF  xF4
02600:  MOVLW  02
02602:  MOVWF  xF7
02604:  MOVLW  7A
02606:  MOVWF  xF6
02608:  MOVLB  0
0260A:  RCALL  226A
.................... 		CAT_TEXT = "\r\n"; 
0260C:  MOVLW  02
0260E:  MOVWF  FEA
02610:  MOVLW  7A
02612:  MOVWF  FE9
02614:  MOVLW  00
02616:  CALL   0120
0261A:  TBLRD*-
0261C:  TBLRD*+
0261E:  MOVF   FF5,W
02620:  MOVWF  FEE
02622:  IORLW  00
02624:  BNZ   261C
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
02626:  MOVLW  02
02628:  MOVLB  2
0262A:  MOVWF  xF5
0262C:  MOVLW  52
0262E:  MOVWF  xF4
02630:  MOVLW  02
02632:  MOVWF  xF7
02634:  MOVLW  7A
02636:  MOVWF  xF6
02638:  MOVLB  0
0263A:  RCALL  226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
0263C:  MOVLW  02
0263E:  MOVLB  2
02640:  MOVWF  xF4
02642:  MOVWF  xF6
02644:  MOVLW  52
02646:  MOVWF  xF5
02648:  MOVLB  0
0264A:  RCALL  2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
0264C:  RCALL  23D2
0264E:  MOVF   01,F
02650:  BNZ   2658
02652:  MOVLW  00
02654:  MOVWF  01
02656:  BRA    2736
....................  
.................... 		//now the log data header =  
.................... 		I2C_TEXT = "DATE,TIME,MANUAL FWD,MANUAL BACK,"; 
02658:  MOVLW  02
0265A:  MOVWF  FEA
0265C:  MOVLW  52
0265E:  MOVWF  FE9
02660:  MOVLW  00
02662:  CALL   0134
02666:  TBLRD*-
02668:  TBLRD*+
0266A:  MOVF   FF5,W
0266C:  MOVWF  FEE
0266E:  IORLW  00
02670:  BNZ   2668
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
02672:  MOVLW  02
02674:  MOVLB  2
02676:  MOVWF  xF4
02678:  MOVWF  xF6
0267A:  MOVLW  52
0267C:  MOVWF  xF5
0267E:  MOVLB  0
02680:  RCALL  2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
02682:  RCALL  23D2
02684:  MOVF   01,F
02686:  BNZ   268E
02688:  MOVLW  00
0268A:  MOVWF  01
0268C:  BRA    2736
....................  
.................... 		I2C_TEXT = "MAIN FLUSH,MAIN BAG USED,SEC FLUSH,"; 
0268E:  MOVLW  02
02690:  MOVWF  FEA
02692:  MOVLW  52
02694:  MOVWF  FE9
02696:  MOVLW  00
02698:  CALL   0166
0269C:  TBLRD*-
0269E:  TBLRD*+
026A0:  MOVF   FF5,W
026A2:  MOVWF  FEE
026A4:  IORLW  00
026A6:  BNZ   269E
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
026A8:  MOVLW  02
026AA:  MOVLB  2
026AC:  MOVWF  xF4
026AE:  MOVWF  xF6
026B0:  MOVLW  52
026B2:  MOVWF  xF5
026B4:  MOVLB  0
026B6:  RCALL  2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
026B8:  RCALL  23D2
026BA:  MOVF   01,F
026BC:  BNZ   26C4
026BE:  MOVLW  00
026C0:  MOVWF  01
026C2:  BRA    2736
....................  
.................... 		I2C_TEXT = "SEC BAG USED,BAG USED,BAG LEFT,"; 
026C4:  MOVLW  02
026C6:  MOVWF  FEA
026C8:  MOVLW  52
026CA:  MOVWF  FE9
026CC:  MOVLW  00
026CE:  CALL   019A
026D2:  TBLRD*-
026D4:  TBLRD*+
026D6:  MOVF   FF5,W
026D8:  MOVWF  FEE
026DA:  IORLW  00
026DC:  BNZ   26D4
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
026DE:  MOVLW  02
026E0:  MOVLB  2
026E2:  MOVWF  xF4
026E4:  MOVWF  xF6
026E6:  MOVLW  52
026E8:  MOVWF  xF5
026EA:  MOVLB  0
026EC:  RCALL  2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
026EE:  RCALL  23D2
026F0:  MOVF   01,F
026F2:  BNZ   26FA
026F4:  MOVLW  00
026F6:  MOVWF  01
026F8:  BRA    2736
....................  
.................... 		I2C_TEXT = "NO BLOCKS,NO RESETS,MODE\r\n"; 
026FA:  MOVLW  02
026FC:  MOVWF  FEA
026FE:  MOVLW  52
02700:  MOVWF  FE9
02702:  MOVLW  00
02704:  CALL   01CA
02708:  TBLRD*-
0270A:  TBLRD*+
0270C:  MOVF   FF5,W
0270E:  MOVWF  FEE
02710:  IORLW  00
02712:  BNZ   270A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
02714:  MOVLW  02
02716:  MOVLB  2
02718:  MOVWF  xF4
0271A:  MOVWF  xF6
0271C:  MOVLW  52
0271E:  MOVWF  xF5
02720:  MOVLB  0
02722:  RCALL  2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
02724:  RCALL  23D2
02726:  MOVF   01,F
02728:  BNZ   2730
0272A:  MOVLW  00
0272C:  MOVWF  01
0272E:  BRA    2736
02730:  MOVLB  2
02732:  INCF   x51,F
02734:  BRA    24A6
02736:  MOVLB  0
.................... 	} 
02738:  GOTO   402E (RETURN)
.................... } 
....................  
.................... int1 send_log_data_to_USB (void) 
.................... {	//Formatt, and send all data to USB flash memory. 
....................  
.................... 	extern union LOG_UNION DATA_IN[Max_no_LOOS]; 
.................... 	extern union LOG_UNION *pDATA_IN; 
.................... 	extern struct TIME TIME_STAMP; 
.................... 	extern struct TIME *pTIME_STAMP; 
.................... 	extern int8 no_of_loos; 
....................  
.................... 	int8 loo; 
.................... 	int16 number; 
....................  
.................... 	char I2C_TEXT[20], CAT_TEXT[10]; 
....................  
.................... 	pTIME_STAMP = &TIME_STAMP; 
*
0312A:  CLRF   23
0312C:  MOVLW  1C
0312E:  MOVWF  22
.................... 	read_RTC(); 
03130:  CALL   196C
.................... 	for(loo = 1; loo < no_of_loos+1; loo++)		//This may look weird, but don't think about changing it!! 
03134:  MOVLW  01
03136:  MOVLB  2
03138:  MOVWF  x50
0313A:  MOVLW  01
0313C:  MOVLB  0
0313E:  ADDWF  xA7,W
03140:  MOVLB  2
03142:  SUBWF  x50,W
03144:  BTFSC  FD8.0
03146:  GOTO   3980
.................... 	{ 
.................... 		pDATA_IN = &DATA_IN[loo-1];		 
0314A:  MOVLW  01
0314C:  SUBWF  x50,W
0314E:  MULLW  14
03150:  MOVF   FF3,W
03152:  CLRF   03
03154:  ADDLW  24
03156:  MOVWF  01
03158:  MOVLW  00
0315A:  ADDWFC 03,F
0315C:  MOVFF  01,9C
03160:  MOVLB  0
03162:  MOVFF  03,9D
....................  
.................... 		I2C_TEXT = "LooW"; 
03166:  MOVLW  02
03168:  MOVWF  FEA
0316A:  MOVLW  53
0316C:  MOVWF  FE9
0316E:  MOVLW  00
03170:  CALL   00AE
03174:  TBLRD*-
03176:  TBLRD*+
03178:  MOVF   FF5,W
0317A:  MOVWF  FEE
0317C:  IORLW  00
0317E:  BNZ   3176
.................... 		if(loo < 10) CAT_TEXT[0] = '0'+loo; CAT_TEXT[1] = 0; 
03180:  MOVLB  2
03182:  MOVF   x50,W
03184:  SUBLW  09
03186:  BNC   318E
03188:  MOVLW  30
0318A:  ADDWF  x50,W
0318C:  MOVWF  x67
0318E:  CLRF   x68
.................... 		if(loo == 10)  
03190:  MOVF   x50,W
03192:  SUBLW  0A
03194:  BNZ   31B4
.................... 		{ 
.................... 			CAT_TEXT = "10"; 
03196:  MOVLW  02
03198:  MOVWF  FEA
0319A:  MOVLW  67
0319C:  MOVWF  FE9
0319E:  MOVLW  00
031A0:  MOVLB  0
031A2:  CALL   00C4
031A6:  TBLRD*-
031A8:  TBLRD*+
031AA:  MOVF   FF5,W
031AC:  MOVWF  FEE
031AE:  IORLW  00
031B0:  BNZ   31A8
031B2:  MOVLB  2
.................... 		} 
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
031B4:  MOVLW  02
031B6:  MOVWF  xF5
031B8:  MOVLW  53
031BA:  MOVWF  xF4
031BC:  MOVLW  02
031BE:  MOVWF  xF7
031C0:  MOVLW  67
031C2:  MOVWF  xF6
031C4:  MOVLB  0
031C6:  CALL   226A
.................... 		CAT_TEXT = ".TXT"; 
031CA:  MOVLW  02
031CC:  MOVWF  FEA
031CE:  MOVLW  67
031D0:  MOVWF  FE9
031D2:  MOVLW  00
031D4:  CALL   00D8
031D8:  TBLRD*-
031DA:  TBLRD*+
031DC:  MOVF   FF5,W
031DE:  MOVWF  FEE
031E0:  IORLW  00
031E2:  BNZ   31DA
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
031E4:  MOVLW  02
031E6:  MOVLB  2
031E8:  MOVWF  xF5
031EA:  MOVLW  53
031EC:  MOVWF  xF4
031EE:  MOVLW  02
031F0:  MOVWF  xF7
031F2:  MOVLW  67
031F4:  MOVWF  xF6
031F6:  MOVLB  0
031F8:  CALL   226A
.................... 		write_to_usb(I2C_FILENAME,I2C_TEXT); 
031FC:  MOVLB  2
031FE:  CLRF   xF4
03200:  MOVLW  02
03202:  MOVWF  xF6
03204:  MOVLW  53
03206:  MOVWF  xF5
03208:  MOVLB  0
0320A:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
0320E:  CALL   23D2
03212:  MOVF   01,F
03214:  BNZ   321E
03216:  MOVLW  00
03218:  MOVWF  01
0321A:  GOTO   3984
....................  
.................... 		//First Date 
.................... 		I2C_TEXT = ""; 
0321E:  MOVLW  02
03220:  MOVWF  FEA
03222:  MOVLW  53
03224:  MOVWF  FE9
03226:  MOVLW  00
03228:  CALL   01F6
0322C:  TBLRD*-
0322E:  TBLRD*+
03230:  MOVF   FF5,W
03232:  MOVWF  FEE
03234:  IORLW  00
03236:  BNZ   322E
.................... 		CAT_TEXT = ""; 
03238:  MOVLW  02
0323A:  MOVWF  FEA
0323C:  MOVLW  67
0323E:  MOVWF  FE9
03240:  MOVLW  00
03242:  CALL   01F6
03246:  TBLRD*-
03248:  TBLRD*+
0324A:  MOVF   FF5,W
0324C:  MOVWF  FEE
0324E:  IORLW  00
03250:  BNZ   3248
.................... 		date_to_string (pTIME_STAMP,I2C_TEXT); 
03252:  MOVFF  23,2F5
03256:  MOVFF  22,2F4
0325A:  MOVLW  02
0325C:  MOVLB  2
0325E:  MOVWF  xF7
03260:  MOVLW  53
03262:  MOVWF  xF6
03264:  MOVLB  0
03266:  BRA    2D24
.................... 		CAT_TEXT = ","; 
03268:  MOVLW  02
0326A:  MOVWF  FEA
0326C:  MOVLW  67
0326E:  MOVWF  FE9
03270:  MOVLW  00
03272:  CALL   0208
03276:  TBLRD*-
03278:  TBLRD*+
0327A:  MOVF   FF5,W
0327C:  MOVWF  FEE
0327E:  IORLW  00
03280:  BNZ   3278
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03282:  MOVLW  02
03284:  MOVLB  2
03286:  MOVWF  xF5
03288:  MOVLW  53
0328A:  MOVWF  xF4
0328C:  MOVLW  02
0328E:  MOVWF  xF7
03290:  MOVLW  67
03292:  MOVWF  xF6
03294:  MOVLB  0
03296:  CALL   226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
0329A:  MOVLW  02
0329C:  MOVLB  2
0329E:  MOVWF  xF4
032A0:  MOVWF  xF6
032A2:  MOVLW  53
032A4:  MOVWF  xF5
032A6:  MOVLB  0
032A8:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
032AC:  CALL   23D2
032B0:  MOVF   01,F
032B2:  BNZ   32BA
032B4:  MOVLW  00
032B6:  MOVWF  01
032B8:  BRA    3984
.................... 		time_to_string (pTIME_STAMP,I2C_TEXT); 
032BA:  MOVFF  23,2F5
032BE:  MOVFF  22,2F4
032C2:  MOVLW  02
032C4:  MOVLB  2
032C6:  MOVWF  xF7
032C8:  MOVLW  53
032CA:  MOVWF  xF6
032CC:  MOVLB  0
032CE:  BRA    2E88
.................... 		CAT_TEXT = ","; 
032D0:  MOVLW  02
032D2:  MOVWF  FEA
032D4:  MOVLW  67
032D6:  MOVWF  FE9
032D8:  MOVLW  00
032DA:  CALL   0208
032DE:  TBLRD*-
032E0:  TBLRD*+
032E2:  MOVF   FF5,W
032E4:  MOVWF  FEE
032E6:  IORLW  00
032E8:  BNZ   32E0
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
032EA:  MOVLW  02
032EC:  MOVLB  2
032EE:  MOVWF  xF5
032F0:  MOVLW  53
032F2:  MOVWF  xF4
032F4:  MOVLW  02
032F6:  MOVWF  xF7
032F8:  MOVLW  67
032FA:  MOVWF  xF6
032FC:  MOVLB  0
032FE:  CALL   226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
03302:  MOVLW  02
03304:  MOVLB  2
03306:  MOVWF  xF4
03308:  MOVWF  xF6
0330A:  MOVLW  53
0330C:  MOVWF  xF5
0330E:  MOVLB  0
03310:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
03314:  CALL   23D2
03318:  MOVF   01,F
0331A:  BNZ   3322
0331C:  MOVLW  00
0331E:  MOVWF  01
03320:  BRA    3984
.................... 		I2C_TEXT = ""; 
03322:  MOVLW  02
03324:  MOVWF  FEA
03326:  MOVLW  53
03328:  MOVWF  FE9
0332A:  MOVLW  00
0332C:  CALL   01F6
03330:  TBLRD*-
03332:  TBLRD*+
03334:  MOVF   FF5,W
03336:  MOVWF  FEE
03338:  IORLW  00
0333A:  BNZ   3332
.................... 		number = pDATA_IN->MFB_USED/10; 
0333C:  MOVLW  02
0333E:  ADDWF  x9C,W
03340:  MOVWF  FE9
03342:  MOVLW  00
03344:  ADDWFC x9D,W
03346:  MOVWF  FEA
03348:  MOVFF  FEC,2F7
0334C:  MOVF   FED,F
0334E:  MOVFF  FEF,2F6
03352:  MOVLB  2
03354:  CLRF   xF9
03356:  MOVLW  0A
03358:  MOVWF  xF8
0335A:  MOVLB  0
0335C:  RCALL  2FB8
0335E:  MOVFF  02,252
03362:  MOVFF  01,251
.................... 		number_to_string (number,I2C_TEXT); 
03366:  MOVFF  252,2F5
0336A:  MOVFF  251,2F4
0336E:  MOVLW  02
03370:  MOVLB  2
03372:  MOVWF  xF7
03374:  MOVLW  53
03376:  MOVWF  xF6
03378:  MOVLB  0
0337A:  RCALL  2FFE
.................... 		CAT_TEXT = ","; 
0337C:  MOVLW  02
0337E:  MOVWF  FEA
03380:  MOVLW  67
03382:  MOVWF  FE9
03384:  MOVLW  00
03386:  CALL   0208
0338A:  TBLRD*-
0338C:  TBLRD*+
0338E:  MOVF   FF5,W
03390:  MOVWF  FEE
03392:  IORLW  00
03394:  BNZ   338C
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03396:  MOVLW  02
03398:  MOVLB  2
0339A:  MOVWF  xF5
0339C:  MOVLW  53
0339E:  MOVWF  xF4
033A0:  MOVLW  02
033A2:  MOVWF  xF7
033A4:  MOVLW  67
033A6:  MOVWF  xF6
033A8:  MOVLB  0
033AA:  CALL   226A
.................... 		number = pDATA_IN->MBB_USED/10; 
033AE:  MOVLW  04
033B0:  ADDWF  x9C,W
033B2:  MOVWF  FE9
033B4:  MOVLW  00
033B6:  ADDWFC x9D,W
033B8:  MOVWF  FEA
033BA:  MOVFF  FEC,2F7
033BE:  MOVF   FED,F
033C0:  MOVFF  FEF,2F6
033C4:  MOVLB  2
033C6:  CLRF   xF9
033C8:  MOVLW  0A
033CA:  MOVWF  xF8
033CC:  MOVLB  0
033CE:  RCALL  2FB8
033D0:  MOVFF  02,252
033D4:  MOVFF  01,251
.................... 		number_to_string (number,CAT_TEXT); 
033D8:  MOVFF  252,2F5
033DC:  MOVFF  251,2F4
033E0:  MOVLW  02
033E2:  MOVLB  2
033E4:  MOVWF  xF7
033E6:  MOVLW  67
033E8:  MOVWF  xF6
033EA:  MOVLB  0
033EC:  RCALL  2FFE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
033EE:  MOVLW  02
033F0:  MOVLB  2
033F2:  MOVWF  xF5
033F4:  MOVLW  53
033F6:  MOVWF  xF4
033F8:  MOVLW  02
033FA:  MOVWF  xF7
033FC:  MOVLW  67
033FE:  MOVWF  xF6
03400:  MOVLB  0
03402:  CALL   226A
.................... 		CAT_TEXT = ","; 
03406:  MOVLW  02
03408:  MOVWF  FEA
0340A:  MOVLW  67
0340C:  MOVWF  FE9
0340E:  MOVLW  00
03410:  CALL   0208
03414:  TBLRD*-
03416:  TBLRD*+
03418:  MOVF   FF5,W
0341A:  MOVWF  FEE
0341C:  IORLW  00
0341E:  BNZ   3416
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03420:  MOVLW  02
03422:  MOVLB  2
03424:  MOVWF  xF5
03426:  MOVLW  53
03428:  MOVWF  xF4
0342A:  MOVLW  02
0342C:  MOVWF  xF7
0342E:  MOVLW  67
03430:  MOVWF  xF6
03432:  MOVLB  0
03434:  CALL   226A
.................... 		number = pDATA_IN->NOI_FLUSH; 
03438:  MOVLW  06
0343A:  ADDWF  x9C,W
0343C:  MOVWF  FE9
0343E:  MOVLW  00
03440:  ADDWFC x9D,W
03442:  MOVWF  FEA
03444:  MOVFF  FEC,252
03448:  MOVF   FED,F
0344A:  MOVFF  FEF,251
.................... 		number_to_string (number,CAT_TEXT); 
0344E:  MOVFF  252,2F5
03452:  MOVFF  251,2F4
03456:  MOVLW  02
03458:  MOVLB  2
0345A:  MOVWF  xF7
0345C:  MOVLW  67
0345E:  MOVWF  xF6
03460:  MOVLB  0
03462:  RCALL  2FFE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03464:  MOVLW  02
03466:  MOVLB  2
03468:  MOVWF  xF5
0346A:  MOVLW  53
0346C:  MOVWF  xF4
0346E:  MOVLW  02
03470:  MOVWF  xF7
03472:  MOVLW  67
03474:  MOVWF  xF6
03476:  MOVLB  0
03478:  CALL   226A
.................... 		CAT_TEXT = ","; 
0347C:  MOVLW  02
0347E:  MOVWF  FEA
03480:  MOVLW  67
03482:  MOVWF  FE9
03484:  MOVLW  00
03486:  CALL   0208
0348A:  TBLRD*-
0348C:  TBLRD*+
0348E:  MOVF   FF5,W
03490:  MOVWF  FEE
03492:  IORLW  00
03494:  BNZ   348C
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03496:  MOVLW  02
03498:  MOVLB  2
0349A:  MOVWF  xF5
0349C:  MOVLW  53
0349E:  MOVWF  xF4
034A0:  MOVLW  02
034A2:  MOVWF  xF7
034A4:  MOVLW  67
034A6:  MOVWF  xF6
034A8:  MOVLB  0
034AA:  CALL   226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
034AE:  MOVLW  02
034B0:  MOVLB  2
034B2:  MOVWF  xF4
034B4:  MOVWF  xF6
034B6:  MOVLW  53
034B8:  MOVWF  xF5
034BA:  MOVLB  0
034BC:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
034C0:  CALL   23D2
034C4:  MOVF   01,F
034C6:  BNZ   34CE
034C8:  MOVLW  00
034CA:  MOVWF  01
034CC:  BRA    3984
....................  
.................... 		I2C_TEXT = ""; 
034CE:  MOVLW  02
034D0:  MOVWF  FEA
034D2:  MOVLW  53
034D4:  MOVWF  FE9
034D6:  MOVLW  00
034D8:  CALL   01F6
034DC:  TBLRD*-
034DE:  TBLRD*+
034E0:  MOVF   FF5,W
034E2:  MOVWF  FEE
034E4:  IORLW  00
034E6:  BNZ   34DE
.................... 		number = pDATA_IN->NOIB_USED/10; 
034E8:  MOVLW  08
034EA:  ADDWF  x9C,W
034EC:  MOVWF  FE9
034EE:  MOVLW  00
034F0:  ADDWFC x9D,W
034F2:  MOVWF  FEA
034F4:  MOVFF  FEC,2F7
034F8:  MOVF   FED,F
034FA:  MOVFF  FEF,2F6
034FE:  MOVLB  2
03500:  CLRF   xF9
03502:  MOVLW  0A
03504:  MOVWF  xF8
03506:  MOVLB  0
03508:  RCALL  2FB8
0350A:  MOVFF  02,252
0350E:  MOVFF  01,251
.................... 		number_to_string (number,I2C_TEXT); 
03512:  MOVFF  252,2F5
03516:  MOVFF  251,2F4
0351A:  MOVLW  02
0351C:  MOVLB  2
0351E:  MOVWF  xF7
03520:  MOVLW  53
03522:  MOVWF  xF6
03524:  MOVLB  0
03526:  RCALL  2FFE
.................... 		CAT_TEXT = ","; 
03528:  MOVLW  02
0352A:  MOVWF  FEA
0352C:  MOVLW  67
0352E:  MOVWF  FE9
03530:  MOVLW  00
03532:  CALL   0208
03536:  TBLRD*-
03538:  TBLRD*+
0353A:  MOVF   FF5,W
0353C:  MOVWF  FEE
0353E:  IORLW  00
03540:  BNZ   3538
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03542:  MOVLW  02
03544:  MOVLB  2
03546:  MOVWF  xF5
03548:  MOVLW  53
0354A:  MOVWF  xF4
0354C:  MOVLW  02
0354E:  MOVWF  xF7
03550:  MOVLW  67
03552:  MOVWF  xF6
03554:  MOVLB  0
03556:  CALL   226A
.................... 		number = pDATA_IN->NOS_FLUSH; 
0355A:  MOVLW  0A
0355C:  ADDWF  x9C,W
0355E:  MOVWF  FE9
03560:  MOVLW  00
03562:  ADDWFC x9D,W
03564:  MOVWF  FEA
03566:  MOVFF  FEC,252
0356A:  MOVF   FED,F
0356C:  MOVFF  FEF,251
.................... 		number_to_string (number,CAT_TEXT); 
03570:  MOVFF  252,2F5
03574:  MOVFF  251,2F4
03578:  MOVLW  02
0357A:  MOVLB  2
0357C:  MOVWF  xF7
0357E:  MOVLW  67
03580:  MOVWF  xF6
03582:  MOVLB  0
03584:  RCALL  2FFE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03586:  MOVLW  02
03588:  MOVLB  2
0358A:  MOVWF  xF5
0358C:  MOVLW  53
0358E:  MOVWF  xF4
03590:  MOVLW  02
03592:  MOVWF  xF7
03594:  MOVLW  67
03596:  MOVWF  xF6
03598:  MOVLB  0
0359A:  CALL   226A
.................... 		CAT_TEXT = ","; 
0359E:  MOVLW  02
035A0:  MOVWF  FEA
035A2:  MOVLW  67
035A4:  MOVWF  FE9
035A6:  MOVLW  00
035A8:  CALL   0208
035AC:  TBLRD*-
035AE:  TBLRD*+
035B0:  MOVF   FF5,W
035B2:  MOVWF  FEE
035B4:  IORLW  00
035B6:  BNZ   35AE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
035B8:  MOVLW  02
035BA:  MOVLB  2
035BC:  MOVWF  xF5
035BE:  MOVLW  53
035C0:  MOVWF  xF4
035C2:  MOVLW  02
035C4:  MOVWF  xF7
035C6:  MOVLW  67
035C8:  MOVWF  xF6
035CA:  MOVLB  0
035CC:  CALL   226A
.................... 		number = pDATA_IN->NOSB_USED/10; 
035D0:  MOVLW  0C
035D2:  ADDWF  x9C,W
035D4:  MOVWF  FE9
035D6:  MOVLW  00
035D8:  ADDWFC x9D,W
035DA:  MOVWF  FEA
035DC:  MOVFF  FEC,2F7
035E0:  MOVF   FED,F
035E2:  MOVFF  FEF,2F6
035E6:  MOVLB  2
035E8:  CLRF   xF9
035EA:  MOVLW  0A
035EC:  MOVWF  xF8
035EE:  MOVLB  0
035F0:  RCALL  2FB8
035F2:  MOVFF  02,252
035F6:  MOVFF  01,251
.................... 		number_to_string (number,CAT_TEXT); 
035FA:  MOVFF  252,2F5
035FE:  MOVFF  251,2F4
03602:  MOVLW  02
03604:  MOVLB  2
03606:  MOVWF  xF7
03608:  MOVLW  67
0360A:  MOVWF  xF6
0360C:  MOVLB  0
0360E:  RCALL  2FFE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03610:  MOVLW  02
03612:  MOVLB  2
03614:  MOVWF  xF5
03616:  MOVLW  53
03618:  MOVWF  xF4
0361A:  MOVLW  02
0361C:  MOVWF  xF7
0361E:  MOVLW  67
03620:  MOVWF  xF6
03622:  MOVLB  0
03624:  CALL   226A
.................... 		CAT_TEXT = ","; 
03628:  MOVLW  02
0362A:  MOVWF  FEA
0362C:  MOVLW  67
0362E:  MOVWF  FE9
03630:  MOVLW  00
03632:  CALL   0208
03636:  TBLRD*-
03638:  TBLRD*+
0363A:  MOVF   FF5,W
0363C:  MOVWF  FEE
0363E:  IORLW  00
03640:  BNZ   3638
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03642:  MOVLW  02
03644:  MOVLB  2
03646:  MOVWF  xF5
03648:  MOVLW  53
0364A:  MOVWF  xF4
0364C:  MOVLW  02
0364E:  MOVWF  xF7
03650:  MOVLW  67
03652:  MOVWF  xF6
03654:  MOVLB  0
03656:  CALL   226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
0365A:  MOVLW  02
0365C:  MOVLB  2
0365E:  MOVWF  xF4
03660:  MOVWF  xF6
03662:  MOVLW  53
03664:  MOVWF  xF5
03666:  MOVLB  0
03668:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
0366C:  CALL   23D2
03670:  MOVF   01,F
03672:  BNZ   367A
03674:  MOVLW  00
03676:  MOVWF  01
03678:  BRA    3984
....................  
.................... 		I2C_TEXT = ""; 
0367A:  MOVLW  02
0367C:  MOVWF  FEA
0367E:  MOVLW  53
03680:  MOVWF  FE9
03682:  MOVLW  00
03684:  CALL   01F6
03688:  TBLRD*-
0368A:  TBLRD*+
0368C:  MOVF   FF5,W
0368E:  MOVWF  FEE
03690:  IORLW  00
03692:  BNZ   368A
.................... 		number = pDATA_IN->BAG_USED/10; 
03694:  MOVLW  0E
03696:  ADDWF  x9C,W
03698:  MOVWF  FE9
0369A:  MOVLW  00
0369C:  ADDWFC x9D,W
0369E:  MOVWF  FEA
036A0:  MOVFF  FEC,2F7
036A4:  MOVF   FED,F
036A6:  MOVFF  FEF,2F6
036AA:  MOVLB  2
036AC:  CLRF   xF9
036AE:  MOVLW  0A
036B0:  MOVWF  xF8
036B2:  MOVLB  0
036B4:  RCALL  2FB8
036B6:  MOVFF  02,252
036BA:  MOVFF  01,251
.................... 		number_to_string (number,I2C_TEXT); 
036BE:  MOVFF  252,2F5
036C2:  MOVFF  251,2F4
036C6:  MOVLW  02
036C8:  MOVLB  2
036CA:  MOVWF  xF7
036CC:  MOVLW  53
036CE:  MOVWF  xF6
036D0:  MOVLB  0
036D2:  RCALL  2FFE
.................... 		CAT_TEXT = ","; 
036D4:  MOVLW  02
036D6:  MOVWF  FEA
036D8:  MOVLW  67
036DA:  MOVWF  FE9
036DC:  MOVLW  00
036DE:  CALL   0208
036E2:  TBLRD*-
036E4:  TBLRD*+
036E6:  MOVF   FF5,W
036E8:  MOVWF  FEE
036EA:  IORLW  00
036EC:  BNZ   36E4
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
036EE:  MOVLW  02
036F0:  MOVLB  2
036F2:  MOVWF  xF5
036F4:  MOVLW  53
036F6:  MOVWF  xF4
036F8:  MOVLW  02
036FA:  MOVWF  xF7
036FC:  MOVLW  67
036FE:  MOVWF  xF6
03700:  MOVLB  0
03702:  CALL   226A
.................... 		number = pDATA_IN->BAG_LEFT/10; 
03706:  MOVLW  10
03708:  ADDWF  x9C,W
0370A:  MOVWF  FE9
0370C:  MOVLW  00
0370E:  ADDWFC x9D,W
03710:  MOVWF  FEA
03712:  MOVFF  FEC,2F7
03716:  MOVF   FED,F
03718:  MOVFF  FEF,2F6
0371C:  MOVLB  2
0371E:  CLRF   xF9
03720:  MOVLW  0A
03722:  MOVWF  xF8
03724:  MOVLB  0
03726:  RCALL  2FB8
03728:  MOVFF  02,252
0372C:  MOVFF  01,251
.................... 		number_to_string (number,CAT_TEXT); 
03730:  MOVFF  252,2F5
03734:  MOVFF  251,2F4
03738:  MOVLW  02
0373A:  MOVLB  2
0373C:  MOVWF  xF7
0373E:  MOVLW  67
03740:  MOVWF  xF6
03742:  MOVLB  0
03744:  RCALL  2FFE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03746:  MOVLW  02
03748:  MOVLB  2
0374A:  MOVWF  xF5
0374C:  MOVLW  53
0374E:  MOVWF  xF4
03750:  MOVLW  02
03752:  MOVWF  xF7
03754:  MOVLW  67
03756:  MOVWF  xF6
03758:  MOVLB  0
0375A:  CALL   226A
.................... 		CAT_TEXT = ","; 
0375E:  MOVLW  02
03760:  MOVWF  FEA
03762:  MOVLW  67
03764:  MOVWF  FE9
03766:  MOVLW  00
03768:  CALL   0208
0376C:  TBLRD*-
0376E:  TBLRD*+
03770:  MOVF   FF5,W
03772:  MOVWF  FEE
03774:  IORLW  00
03776:  BNZ   376E
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03778:  MOVLW  02
0377A:  MOVLB  2
0377C:  MOVWF  xF5
0377E:  MOVLW  53
03780:  MOVWF  xF4
03782:  MOVLW  02
03784:  MOVWF  xF7
03786:  MOVLW  67
03788:  MOVWF  xF6
0378A:  MOVLB  0
0378C:  CALL   226A
.................... 		number = pDATA_IN->NO_BLOCKS; 
03790:  MOVLW  12
03792:  ADDWF  x9C,W
03794:  MOVWF  FE9
03796:  MOVLW  00
03798:  ADDWFC x9D,W
0379A:  MOVWF  FEA
0379C:  MOVFF  FEC,252
037A0:  MOVF   FED,F
037A2:  MOVFF  FEF,251
.................... 		number_to_string (number,CAT_TEXT); 
037A6:  MOVFF  252,2F5
037AA:  MOVFF  251,2F4
037AE:  MOVLW  02
037B0:  MOVLB  2
037B2:  MOVWF  xF7
037B4:  MOVLW  67
037B6:  MOVWF  xF6
037B8:  MOVLB  0
037BA:  RCALL  2FFE
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
037BC:  MOVLW  02
037BE:  MOVLB  2
037C0:  MOVWF  xF5
037C2:  MOVLW  53
037C4:  MOVWF  xF4
037C6:  MOVLW  02
037C8:  MOVWF  xF7
037CA:  MOVLW  67
037CC:  MOVWF  xF6
037CE:  MOVLB  0
037D0:  CALL   226A
.................... 		CAT_TEXT = ","; 
037D4:  MOVLW  02
037D6:  MOVWF  FEA
037D8:  MOVLW  67
037DA:  MOVWF  FE9
037DC:  MOVLW  00
037DE:  CALL   0208
037E2:  TBLRD*-
037E4:  TBLRD*+
037E6:  MOVF   FF5,W
037E8:  MOVWF  FEE
037EA:  IORLW  00
037EC:  BNZ   37E4
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
037EE:  MOVLW  02
037F0:  MOVLB  2
037F2:  MOVWF  xF5
037F4:  MOVLW  53
037F6:  MOVWF  xF4
037F8:  MOVLW  02
037FA:  MOVWF  xF7
037FC:  MOVLW  67
037FE:  MOVWF  xF6
03800:  MOVLB  0
03802:  CALL   226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
03806:  MOVLW  02
03808:  MOVLB  2
0380A:  MOVWF  xF4
0380C:  MOVWF  xF6
0380E:  MOVLW  53
03810:  MOVWF  xF5
03812:  MOVLB  0
03814:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
03818:  CALL   23D2
0381C:  MOVF   01,F
0381E:  BNZ   3826
03820:  MOVLW  00
03822:  MOVWF  01
03824:  BRA    3984
....................  
.................... 		I2C_TEXT = ""; 
03826:  MOVLW  02
03828:  MOVWF  FEA
0382A:  MOVLW  53
0382C:  MOVWF  FE9
0382E:  MOVLW  00
03830:  CALL   01F6
03834:  TBLRD*-
03836:  TBLRD*+
03838:  MOVF   FF5,W
0383A:  MOVWF  FEE
0383C:  IORLW  00
0383E:  BNZ   3836
.................... 		number = ((pDATA_IN->LooSTATUS/256)); 
03840:  MOVFF  9C,FE9
03844:  MOVFF  9D,FEA
03848:  MOVFF  FEC,251
0384C:  MOVF   FED,F
0384E:  MOVFF  FEF,271
03852:  MOVLB  2
03854:  CLRF   x52
.................... 		number_to_string (number,I2C_TEXT); 
03856:  MOVFF  252,2F5
0385A:  MOVFF  251,2F4
0385E:  MOVLW  02
03860:  MOVWF  xF7
03862:  MOVLW  53
03864:  MOVWF  xF6
03866:  MOVLB  0
03868:  CALL   2FFE
.................... 		CAT_TEXT = ","; 
0386C:  MOVLW  02
0386E:  MOVWF  FEA
03870:  MOVLW  67
03872:  MOVWF  FE9
03874:  MOVLW  00
03876:  CALL   0208
0387A:  TBLRD*-
0387C:  TBLRD*+
0387E:  MOVF   FF5,W
03880:  MOVWF  FEE
03882:  IORLW  00
03884:  BNZ   387C
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03886:  MOVLW  02
03888:  MOVLB  2
0388A:  MOVWF  xF5
0388C:  MOVLW  53
0388E:  MOVWF  xF4
03890:  MOVLW  02
03892:  MOVWF  xF7
03894:  MOVLW  67
03896:  MOVWF  xF6
03898:  MOVLB  0
0389A:  CALL   226A
.................... 		if((pDATA_IN->LooSTATUS & RUNSTATE) == RUNSTATE) 
0389E:  MOVFF  9C,FE9
038A2:  MOVFF  9D,FEA
038A6:  MOVFF  FEC,272
038AA:  MOVF   FED,F
038AC:  MOVFF  FEF,271
038B0:  MOVLW  02
038B2:  MOVLB  2
038B4:  ANDWF  x71,F
038B6:  CLRF   x72
038B8:  MOVF   x71,W
038BA:  SUBLW  02
038BC:  BNZ   38E0
038BE:  MOVF   x72,F
038C0:  BNZ   38E0
.................... 		{ 
.................... 			CAT_TEXT = "RUN\r\n"; 
038C2:  MOVLW  02
038C4:  MOVWF  FEA
038C6:  MOVLW  67
038C8:  MOVWF  FE9
038CA:  MOVLW  00
038CC:  MOVLB  0
038CE:  CALL   021A
038D2:  TBLRD*-
038D4:  TBLRD*+
038D6:  MOVF   FF5,W
038D8:  MOVWF  FEE
038DA:  IORLW  00
038DC:  BNZ   38D4
.................... 		} 
038DE:  BRA    3940
.................... 		else if ((pDATA_IN->LooSTATUS & SERSTATE) == SERSTATE) 
038E0:  MOVLB  0
038E2:  MOVFF  9C,FE9
038E6:  MOVFF  9D,FEA
038EA:  MOVFF  FEC,272
038EE:  MOVF   FED,F
038F0:  MOVFF  FEF,271
038F4:  MOVLW  01
038F6:  MOVLB  2
038F8:  ANDWF  x71,F
038FA:  CLRF   x72
038FC:  DECFSZ x71,W
038FE:  BRA    3924
03900:  MOVF   x72,F
03902:  BNZ   3924
.................... 		{	 
.................... 			CAT_TEXT = "SRV\r\n"; 
03904:  MOVLW  02
03906:  MOVWF  FEA
03908:  MOVLW  67
0390A:  MOVWF  FE9
0390C:  MOVLW  00
0390E:  MOVLB  0
03910:  CALL   0230
03914:  TBLRD*-
03916:  TBLRD*+
03918:  MOVF   FF5,W
0391A:  MOVWF  FEE
0391C:  IORLW  00
0391E:  BNZ   3916
.................... 		} 
03920:  BRA    3940
03922:  MOVLB  2
.................... 		else 
.................... 		{ 
.................... 			CAT_TEXT = "OFF\r\n"; 
03924:  MOVLW  02
03926:  MOVWF  FEA
03928:  MOVLW  67
0392A:  MOVWF  FE9
0392C:  MOVLW  00
0392E:  MOVLB  0
03930:  CALL   0246
03934:  TBLRD*-
03936:  TBLRD*+
03938:  MOVF   FF5,W
0393A:  MOVWF  FEE
0393C:  IORLW  00
0393E:  BNZ   3936
.................... 		} 
.................... 		strcat(I2C_TEXT,CAT_TEXT); 
03940:  MOVLW  02
03942:  MOVLB  2
03944:  MOVWF  xF5
03946:  MOVLW  53
03948:  MOVWF  xF4
0394A:  MOVLW  02
0394C:  MOVWF  xF7
0394E:  MOVLW  67
03950:  MOVWF  xF6
03952:  MOVLB  0
03954:  CALL   226A
.................... 		write_to_usb(I2C_APPEND,I2C_TEXT); 
03958:  MOVLW  02
0395A:  MOVLB  2
0395C:  MOVWF  xF4
0395E:  MOVWF  xF6
03960:  MOVLW  53
03962:  MOVWF  xF5
03964:  MOVLB  0
03966:  CALL   2308
.................... 		if(!USB_ready()) return 0;		//cancel USB as it is not working. 
0396A:  CALL   23D2
0396E:  MOVF   01,F
03970:  BNZ   3978
03972:  MOVLW  00
03974:  MOVWF  01
03976:  BRA    3984
03978:  MOVLB  2
0397A:  INCF   x50,F
0397C:  GOTO   313A
.................... 	}	 
.................... 	return 1; 
03980:  MOVLW  01
03982:  MOVWF  01
03984:  MOVLB  0
03986:  GOTO   4C92 (RETURN)
.................... }	 
....................  
....................  
....................  
.................... void number_to_string (int16 number, *string_out) 
*
02FFE:  MOVLB  2
03000:  CLRF   xF8
.................... {	//does not remove leading zeros,adds NULL to end. 
....................  
.................... 	int8 start_flag = 0; 
....................  
.................... 	if(number > 9999) number = 9999; 
03002:  MOVF   xF5,W
03004:  SUBLW  26
03006:  BC    301A
03008:  XORLW  FF
0300A:  BNZ   3012
0300C:  MOVF   xF4,W
0300E:  SUBLW  0F
03010:  BC    301A
03012:  MOVLW  27
03014:  MOVWF  xF5
03016:  MOVLW  0F
03018:  MOVWF  xF4
....................  
.................... 	*string_out = 48;	//character 0. 
0301A:  MOVFF  2F7,03
0301E:  MOVFF  2F6,FE9
03022:  MOVFF  03,FEA
03026:  MOVLW  30
03028:  MOVWF  FEF
.................... 	if(number > 999 ) 
0302A:  MOVF   xF5,W
0302C:  SUBLW  02
0302E:  BC    306C
03030:  XORLW  FF
03032:  BNZ   303A
03034:  MOVF   xF4,W
03036:  SUBLW  E7
03038:  BC    306C
.................... 	{ 
.................... 		while(number >= 1000) 
0303A:  MOVF   xF5,W
0303C:  SUBLW  02
0303E:  BC    3062
03040:  XORLW  FF
03042:  BNZ   304A
03044:  MOVF   xF4,W
03046:  SUBLW  E7
03048:  BC    3062
.................... 		{ 
.................... 			(*string_out)++; 
0304A:  MOVFF  2F7,03
0304E:  MOVFF  2F6,FE9
03052:  MOVFF  03,FEA
03056:  INCF   FEF,F
.................... 			number = number - 1000; 
03058:  MOVLW  E8
0305A:  SUBWF  xF4,F
0305C:  MOVLW  03
0305E:  SUBWFB xF5,F
03060:  BRA    303A
.................... 		} 
.................... 		start_flag = 1; 
03062:  MOVLW  01
03064:  MOVWF  xF8
.................... 		string_out++; 
03066:  INCF   xF6,F
03068:  BTFSC  FD8.2
0306A:  INCF   xF7,F
.................... 	} 
....................  
.................... 	*string_out = 48;	//character 0. 
0306C:  MOVFF  2F7,03
03070:  MOVFF  2F6,FE9
03074:  MOVFF  03,FEA
03078:  MOVLW  30
0307A:  MOVWF  FEF
.................... 	if((number > 99) || start_flag) 
0307C:  MOVF   xF5,F
0307E:  BNZ   308A
03080:  MOVF   xF4,W
03082:  SUBLW  63
03084:  BNC   308A
03086:  MOVF   xF8,F
03088:  BZ    30B4
.................... 	{ 
.................... 		while(number >= 100) 
0308A:  MOVF   xF5,F
0308C:  BNZ   3094
0308E:  MOVF   xF4,W
03090:  SUBLW  63
03092:  BC    30AC
.................... 		{ 
.................... 			(*string_out)++; 
03094:  MOVFF  2F7,03
03098:  MOVFF  2F6,FE9
0309C:  MOVFF  03,FEA
030A0:  INCF   FEF,F
.................... 			number = number - 100; 
030A2:  MOVLW  64
030A4:  SUBWF  xF4,F
030A6:  MOVLW  00
030A8:  SUBWFB xF5,F
030AA:  BRA    308A
.................... 		} 
.................... 		string_out++; 
030AC:  INCF   xF6,F
030AE:  BTFSC  FD8.2
030B0:  INCF   xF7,F
.................... 	} 
030B2:  BRA    30BE
.................... 	else if(start_flag) 
030B4:  MOVF   xF8,F
030B6:  BZ    30BE
.................... 	{ 
.................... 		string_out++; 
030B8:  INCF   xF6,F
030BA:  BTFSC  FD8.2
030BC:  INCF   xF7,F
.................... 	} 
....................  
.................... 	*string_out = 48;	//character 0. 
030BE:  MOVFF  2F7,03
030C2:  MOVFF  2F6,FE9
030C6:  MOVFF  03,FEA
030CA:  MOVLW  30
030CC:  MOVWF  FEF
.................... 	if(number > 9 ) 
030CE:  MOVF   xF5,F
030D0:  BNZ   30D8
030D2:  MOVF   xF4,W
030D4:  SUBLW  09
030D6:  BC    30FA
.................... 	{ 
.................... 		while(number >= 10) 
030D8:  MOVF   xF5,F
030DA:  BNZ   30E2
030DC:  MOVF   xF4,W
030DE:  SUBLW  09
030E0:  BC    30FA
.................... 		{ 
.................... 			(*string_out)++; 
030E2:  MOVFF  2F7,03
030E6:  MOVFF  2F6,FE9
030EA:  MOVFF  03,FEA
030EE:  INCF   FEF,F
.................... 			number = number - 10; 
030F0:  MOVLW  0A
030F2:  SUBWF  xF4,F
030F4:  MOVLW  00
030F6:  SUBWFB xF5,F
030F8:  BRA    30D8
.................... 		} 
.................... 	} 
.................... 	string_out++; 
030FA:  INCF   xF6,F
030FC:  BTFSC  FD8.2
030FE:  INCF   xF7,F
.................... 	*string_out = 48 + number; 
03100:  MOVFF  2F7,03
03104:  MOVFF  2F6,FE9
03108:  MOVFF  03,FEA
0310C:  MOVLW  30
0310E:  ADDWF  xF4,W
03110:  MOVWF  FEF
.................... 	string_out++; 
03112:  INCF   xF6,F
03114:  BTFSC  FD8.2
03116:  INCF   xF7,F
.................... 	*string_out = 0; 
03118:  MOVFF  2F7,03
0311C:  MOVFF  2F6,FE9
03120:  MOVFF  03,FEA
03124:  CLRF   FEF
03126:  MOVLB  0
03128:  RETURN 0
.................... } 
....................  
.................... void date_to_string (struct TIME *pTIME, char *string) 
.................... { 
.................... 	*string = '2';	//start off string as year (2016 to 2065)	 
*
02D24:  MOVFF  2F7,03
02D28:  MOVLB  2
02D2A:  MOVFF  2F6,FE9
02D2E:  MOVFF  03,FEA
02D32:  MOVLW  32
02D34:  MOVWF  FEF
.................... 	string++; 
02D36:  INCF   xF6,F
02D38:  BTFSC  FD8.2
02D3A:  INCF   xF7,F
.................... 	*string = '0'; 
02D3C:  MOVFF  2F7,03
02D40:  MOVFF  2F6,FE9
02D44:  MOVFF  03,FEA
02D48:  MOVLW  30
02D4A:  MOVWF  FEF
.................... 	string++; 
02D4C:  INCF   xF6,F
02D4E:  BTFSC  FD8.2
02D50:  INCF   xF7,F
.................... 	*string = (pTIME->year >> 4)+'0'; 
02D52:  MOVFF  2F7,03
02D56:  MOVLW  05
02D58:  ADDWF  xF4,W
02D5A:  MOVWF  FE9
02D5C:  MOVLW  00
02D5E:  ADDWFC xF5,W
02D60:  MOVWF  FEA
02D62:  SWAPF  FEF,W
02D64:  MOVWF  00
02D66:  MOVLW  0F
02D68:  ANDWF  00,F
02D6A:  MOVF   00,W
02D6C:  ADDLW  30
02D6E:  MOVFF  03,FEA
02D72:  MOVFF  2F6,FE9
02D76:  MOVWF  FEF
.................... 	string++; 
02D78:  INCF   xF6,F
02D7A:  BTFSC  FD8.2
02D7C:  INCF   xF7,F
.................... 	*string = (pTIME->year & 0x0F)+'0'; 
02D7E:  MOVFF  2F7,03
02D82:  MOVLW  05
02D84:  ADDWF  xF4,W
02D86:  MOVWF  FE9
02D88:  MOVLW  00
02D8A:  ADDWFC xF5,W
02D8C:  MOVWF  FEA
02D8E:  MOVF   FEF,W
02D90:  ANDLW  0F
02D92:  ADDLW  30
02D94:  MOVFF  03,FEA
02D98:  MOVFF  2F6,FE9
02D9C:  MOVWF  FEF
.................... 	string++; 
02D9E:  INCF   xF6,F
02DA0:  BTFSC  FD8.2
02DA2:  INCF   xF7,F
.................... 	*string = '-'; 
02DA4:  MOVFF  2F7,03
02DA8:  MOVFF  2F6,FE9
02DAC:  MOVFF  03,FEA
02DB0:  MOVLW  2D
02DB2:  MOVWF  FEF
.................... 	string++; 
02DB4:  INCF   xF6,F
02DB6:  BTFSC  FD8.2
02DB8:  INCF   xF7,F
.................... 	*string = (pTIME->month >> 4)+'0'; 
02DBA:  MOVFF  2F7,03
02DBE:  MOVLW  04
02DC0:  ADDWF  xF4,W
02DC2:  MOVWF  FE9
02DC4:  MOVLW  00
02DC6:  ADDWFC xF5,W
02DC8:  MOVWF  FEA
02DCA:  SWAPF  FEF,W
02DCC:  MOVWF  00
02DCE:  MOVLW  0F
02DD0:  ANDWF  00,F
02DD2:  MOVF   00,W
02DD4:  ADDLW  30
02DD6:  MOVFF  03,FEA
02DDA:  MOVFF  2F6,FE9
02DDE:  MOVWF  FEF
.................... 	string++; 
02DE0:  INCF   xF6,F
02DE2:  BTFSC  FD8.2
02DE4:  INCF   xF7,F
.................... 	*string = (pTIME->month & 0x0F)+'0'; 
02DE6:  MOVFF  2F7,03
02DEA:  MOVLW  04
02DEC:  ADDWF  xF4,W
02DEE:  MOVWF  FE9
02DF0:  MOVLW  00
02DF2:  ADDWFC xF5,W
02DF4:  MOVWF  FEA
02DF6:  MOVF   FEF,W
02DF8:  ANDLW  0F
02DFA:  ADDLW  30
02DFC:  MOVFF  03,FEA
02E00:  MOVFF  2F6,FE9
02E04:  MOVWF  FEF
.................... 	string++; 
02E06:  INCF   xF6,F
02E08:  BTFSC  FD8.2
02E0A:  INCF   xF7,F
.................... 	*string = '-'; 
02E0C:  MOVFF  2F7,03
02E10:  MOVFF  2F6,FE9
02E14:  MOVFF  03,FEA
02E18:  MOVLW  2D
02E1A:  MOVWF  FEF
.................... 	string++; 
02E1C:  INCF   xF6,F
02E1E:  BTFSC  FD8.2
02E20:  INCF   xF7,F
.................... 	*string = (pTIME->day >> 4)+'0'; 
02E22:  MOVFF  2F7,03
02E26:  MOVLW  03
02E28:  ADDWF  xF4,W
02E2A:  MOVWF  FE9
02E2C:  MOVLW  00
02E2E:  ADDWFC xF5,W
02E30:  MOVWF  FEA
02E32:  SWAPF  FEF,W
02E34:  MOVWF  00
02E36:  MOVLW  0F
02E38:  ANDWF  00,F
02E3A:  MOVF   00,W
02E3C:  ADDLW  30
02E3E:  MOVFF  03,FEA
02E42:  MOVFF  2F6,FE9
02E46:  MOVWF  FEF
.................... 	string++; 
02E48:  INCF   xF6,F
02E4A:  BTFSC  FD8.2
02E4C:  INCF   xF7,F
.................... 	*string = (pTIME->day & 0x0F)+'0'; 
02E4E:  MOVFF  2F7,03
02E52:  MOVLW  03
02E54:  ADDWF  xF4,W
02E56:  MOVWF  FE9
02E58:  MOVLW  00
02E5A:  ADDWFC xF5,W
02E5C:  MOVWF  FEA
02E5E:  MOVF   FEF,W
02E60:  ANDLW  0F
02E62:  ADDLW  30
02E64:  MOVFF  03,FEA
02E68:  MOVFF  2F6,FE9
02E6C:  MOVWF  FEF
.................... 	string++; 
02E6E:  INCF   xF6,F
02E70:  BTFSC  FD8.2
02E72:  INCF   xF7,F
.................... 	*string = 0; 
02E74:  MOVFF  2F7,03
02E78:  MOVFF  2F6,FE9
02E7C:  MOVFF  03,FEA
02E80:  CLRF   FEF
02E82:  MOVLB  0
02E84:  GOTO   3268 (RETURN)
.................... } 
....................  
.................... void time_to_string (struct TIME *pTIME, char *string) 
.................... {	//load Time header to string 
.................... 	(*string) = (pTIME->hour >> 4)+'0'; 
02E88:  MOVFF  2F7,03
02E8C:  MOVLB  2
02E8E:  MOVLW  02
02E90:  ADDWF  xF4,W
02E92:  MOVWF  FE9
02E94:  MOVLW  00
02E96:  ADDWFC xF5,W
02E98:  MOVWF  FEA
02E9A:  SWAPF  FEF,W
02E9C:  MOVWF  00
02E9E:  MOVLW  0F
02EA0:  ANDWF  00,F
02EA2:  MOVF   00,W
02EA4:  ADDLW  30
02EA6:  MOVFF  03,FEA
02EAA:  MOVFF  2F6,FE9
02EAE:  MOVWF  FEF
.................... 	string++; 
02EB0:  INCF   xF6,F
02EB2:  BTFSC  FD8.2
02EB4:  INCF   xF7,F
.................... 	(*string) = (pTIME->hour & 0x0F)+'0'; 
02EB6:  MOVFF  2F7,03
02EBA:  MOVLW  02
02EBC:  ADDWF  xF4,W
02EBE:  MOVWF  FE9
02EC0:  MOVLW  00
02EC2:  ADDWFC xF5,W
02EC4:  MOVWF  FEA
02EC6:  MOVF   FEF,W
02EC8:  ANDLW  0F
02ECA:  ADDLW  30
02ECC:  MOVFF  03,FEA
02ED0:  MOVFF  2F6,FE9
02ED4:  MOVWF  FEF
.................... 	string++; 
02ED6:  INCF   xF6,F
02ED8:  BTFSC  FD8.2
02EDA:  INCF   xF7,F
.................... 	*string = '-'; 
02EDC:  MOVFF  2F7,03
02EE0:  MOVFF  2F6,FE9
02EE4:  MOVFF  03,FEA
02EE8:  MOVLW  2D
02EEA:  MOVWF  FEF
.................... 	string++; 
02EEC:  INCF   xF6,F
02EEE:  BTFSC  FD8.2
02EF0:  INCF   xF7,F
.................... 	(*string) = (pTIME->min >> 4)+'0'; 
02EF2:  MOVFF  2F7,03
02EF6:  MOVLW  01
02EF8:  ADDWF  xF4,W
02EFA:  MOVWF  FE9
02EFC:  MOVLW  00
02EFE:  ADDWFC xF5,W
02F00:  MOVWF  FEA
02F02:  SWAPF  FEF,W
02F04:  MOVWF  00
02F06:  MOVLW  0F
02F08:  ANDWF  00,F
02F0A:  MOVF   00,W
02F0C:  ADDLW  30
02F0E:  MOVFF  03,FEA
02F12:  MOVFF  2F6,FE9
02F16:  MOVWF  FEF
.................... 	string++; 
02F18:  INCF   xF6,F
02F1A:  BTFSC  FD8.2
02F1C:  INCF   xF7,F
.................... 	(*string) = (pTIME->min & 0x0F)+'0'; 
02F1E:  MOVFF  2F7,03
02F22:  MOVLW  01
02F24:  ADDWF  xF4,W
02F26:  MOVWF  FE9
02F28:  MOVLW  00
02F2A:  ADDWFC xF5,W
02F2C:  MOVWF  FEA
02F2E:  MOVF   FEF,W
02F30:  ANDLW  0F
02F32:  ADDLW  30
02F34:  MOVFF  03,FEA
02F38:  MOVFF  2F6,FE9
02F3C:  MOVWF  FEF
.................... 	string++; 
02F3E:  INCF   xF6,F
02F40:  BTFSC  FD8.2
02F42:  INCF   xF7,F
.................... 	*string = '-'; 
02F44:  MOVFF  2F7,03
02F48:  MOVFF  2F6,FE9
02F4C:  MOVFF  03,FEA
02F50:  MOVLW  2D
02F52:  MOVWF  FEF
.................... 	string++; 
02F54:  INCF   xF6,F
02F56:  BTFSC  FD8.2
02F58:  INCF   xF7,F
.................... 	(*string) = (pTIME->sec >> 4)+'0'; 
02F5A:  MOVFF  2F7,03
02F5E:  MOVFF  2F4,FE9
02F62:  MOVFF  2F5,FEA
02F66:  SWAPF  FEF,W
02F68:  MOVWF  00
02F6A:  MOVLW  0F
02F6C:  ANDWF  00,F
02F6E:  MOVF   00,W
02F70:  ADDLW  30
02F72:  MOVFF  03,FEA
02F76:  MOVFF  2F6,FE9
02F7A:  MOVWF  FEF
.................... 	string++; 
02F7C:  INCF   xF6,F
02F7E:  BTFSC  FD8.2
02F80:  INCF   xF7,F
.................... 	(*string) = (pTIME->sec & 0x0F)+'0'; 
02F82:  MOVFF  2F7,03
02F86:  MOVFF  2F4,FE9
02F8A:  MOVFF  2F5,FEA
02F8E:  MOVF   FEF,W
02F90:  ANDLW  0F
02F92:  ADDLW  30
02F94:  MOVFF  03,FEA
02F98:  MOVFF  2F6,FE9
02F9C:  MOVWF  FEF
.................... 	string++; 
02F9E:  INCF   xF6,F
02FA0:  BTFSC  FD8.2
02FA2:  INCF   xF7,F
.................... 	(*string) = 0; 
02FA4:  MOVFF  2F7,03
02FA8:  MOVFF  2F6,FE9
02FAC:  MOVFF  03,FEA
02FB0:  CLRF   FEF
02FB2:  MOVLB  0
02FB4:  GOTO   32D0 (RETURN)
....................  
.................... } 
....................  
....................  
....................  
.................... #INCLUDE <LW_Attendant_Display.c> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Attendant_Display.C 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	Display functions 
.................... * 
.................... * History: 	28/02/16	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
.................... #INT_TIMER2  
.................... void FLASH_TIMER (void) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 scroll_offset; 
.................... 	extern char display_ram[6][21]; 
.................... 	extern int8 ALARM_FLAG; 
.................... 	extern int8 FLASH_FLAG; 
.................... 	extern int8 display_type; 
.................... 	extern int8 tick; 
.................... 	static int8 flash_timer = 0; 
.................... 	char text[21]; 
.................... 	int8 FLSH_REG1,FLSH_REG2; 
....................  
.................... 	flash_timer++; 
*
0082A:  MOVLB  1
0082C:  INCF   x55,F
.................... 	tick = 1; 
0082E:  MOVLW  01
00830:  MOVLB  0
00832:  MOVWF  xA3
.................... 	 
.................... 	//align flash registers with scrolled screen 
.................... 	FLSH_REG1  = FLASH_REG[0] >> scroll_offset; 
00834:  MOVFF  9E,3AE
00838:  MOVF   xA0,W
0083A:  MOVWF  01
0083C:  BZ    0850
0083E:  BCF    FD8.0
00840:  MOVLB  3
00842:  RRCF   xAE,F
00844:  DECFSZ 01,F
00846:  BRA    084A
00848:  BRA    084E
0084A:  MOVLB  0
0084C:  BRA    083E
0084E:  MOVLB  0
.................... 	FLSH_REG2  = FLASH_REG[1] >> scroll_offset; 
00850:  MOVFF  9F,3AF
00854:  MOVF   xA0,W
00856:  MOVWF  01
00858:  BZ    086C
0085A:  BCF    FD8.0
0085C:  MOVLB  3
0085E:  RRCF   xAF,F
00860:  DECFSZ 01,F
00862:  BRA    0866
00864:  BRA    086A
00866:  MOVLB  0
00868:  BRA    085A
0086A:  MOVLB  0
....................  
.................... 	if(flash_timer <= half_way) 
0086C:  MOVLB  1
0086E:  MOVF   x55,W
00870:  SUBLW  19
00872:  BTFSS  FD8.0
00874:  BRA    09FC
.................... 	{	//all things that flash are off 
.................... 		if(display_type == NORMAL) 
00876:  DECFSZ x54,W
00878:  BRA    0972
.................... 		{            
.................... 			text = "          "; 
0087A:  MOVLW  03
0087C:  MOVWF  FEA
0087E:  MOVLW  99
00880:  MOVWF  FE9
00882:  MOVLW  00
00884:  MOVLB  0
00886:  RCALL  025C
00888:  TBLRD*-
0088A:  TBLRD*+
0088C:  MOVF   FF5,W
0088E:  MOVWF  FEE
00890:  IORLW  00
00892:  BNZ   088A
.................... 			if(FLASH_REG[0] & BIT0) write_text_LCD (LINE_1, line1_flash_A, &text); 
00894:  BTFSS  x9E.0
00896:  BRA    08AC
00898:  MOVLB  4
0089A:  CLRF   x39
0089C:  MOVLW  0A
0089E:  MOVWF  x3A
008A0:  MOVLW  03
008A2:  MOVWF  x3C
008A4:  MOVLW  99
008A6:  MOVWF  x3B
008A8:  MOVLB  0
008AA:  RCALL  07C6
.................... 			text = "   "; 
008AC:  MOVLW  03
008AE:  MOVWF  FEA
008B0:  MOVLW  99
008B2:  MOVWF  FE9
008B4:  MOVLW  00
008B6:  RCALL  0278
008B8:  TBLRD*-
008BA:  TBLRD*+
008BC:  MOVF   FF5,W
008BE:  MOVWF  FEE
008C0:  IORLW  00
008C2:  BNZ   08BA
.................... 			if(FLSH_REG1 & BIT1) write_text_LCD (LINE_2, line_flash_A1, &text); 
008C4:  MOVLB  3
008C6:  BTFSS  xAE.1
008C8:  BRA    08E2
008CA:  MOVLW  40
008CC:  MOVLB  4
008CE:  MOVWF  x39
008D0:  MOVLW  06
008D2:  MOVWF  x3A
008D4:  MOVLW  03
008D6:  MOVWF  x3C
008D8:  MOVLW  99
008DA:  MOVWF  x3B
008DC:  MOVLB  0
008DE:  RCALL  07C6
008E0:  MOVLB  3
.................... 			if(FLSH_REG1 & BIT2) write_text_LCD (LINE_3, line_flash_A1, &text); 
008E2:  BTFSS  xAE.2
008E4:  BRA    08FE
008E6:  MOVLW  14
008E8:  MOVLB  4
008EA:  MOVWF  x39
008EC:  MOVLW  06
008EE:  MOVWF  x3A
008F0:  MOVLW  03
008F2:  MOVWF  x3C
008F4:  MOVLW  99
008F6:  MOVWF  x3B
008F8:  MOVLB  0
008FA:  RCALL  07C6
008FC:  MOVLB  3
.................... 			if(FLSH_REG1 & BIT3) write_text_LCD (LINE_4, line_flash_A1, &text); 
008FE:  BTFSS  xAE.3
00900:  BRA    091A
00902:  MOVLW  54
00904:  MOVLB  4
00906:  MOVWF  x39
00908:  MOVLW  06
0090A:  MOVWF  x3A
0090C:  MOVLW  03
0090E:  MOVWF  x3C
00910:  MOVLW  99
00912:  MOVWF  x3B
00914:  MOVLB  0
00916:  RCALL  07C6
00918:  MOVLB  3
.................... 			if(FLSH_REG2 & BIT1) write_text_LCD (LINE_2, line_flash_A2, &text); 
0091A:  BTFSS  xAF.1
0091C:  BRA    0936
0091E:  MOVLW  40
00920:  MOVLB  4
00922:  MOVWF  x39
00924:  MOVLW  10
00926:  MOVWF  x3A
00928:  MOVLW  03
0092A:  MOVWF  x3C
0092C:  MOVLW  99
0092E:  MOVWF  x3B
00930:  MOVLB  0
00932:  RCALL  07C6
00934:  MOVLB  3
.................... 			if(FLSH_REG2 & BIT2) write_text_LCD (LINE_3, line_flash_A2, &text); 
00936:  BTFSS  xAF.2
00938:  BRA    0952
0093A:  MOVLW  14
0093C:  MOVLB  4
0093E:  MOVWF  x39
00940:  MOVLW  10
00942:  MOVWF  x3A
00944:  MOVLW  03
00946:  MOVWF  x3C
00948:  MOVLW  99
0094A:  MOVWF  x3B
0094C:  MOVLB  0
0094E:  RCALL  07C6
00950:  MOVLB  3
.................... 			if(FLSH_REG2 & BIT3) write_text_LCD (LINE_4, line_flash_A2, &text); 
00952:  BTFSS  xAF.3
00954:  BRA    096E
00956:  MOVLW  54
00958:  MOVLB  4
0095A:  MOVWF  x39
0095C:  MOVLW  10
0095E:  MOVWF  x3A
00960:  MOVLW  03
00962:  MOVWF  x3C
00964:  MOVLW  99
00966:  MOVWF  x3B
00968:  MOVLB  0
0096A:  RCALL  07C6
0096C:  MOVLB  3
.................... 		} 
0096E:  BRA    09F4
00970:  MOVLB  1
.................... 		else 
.................... 		{	//display is menu, so flash entire line 
.................... 			text = "                    "; 
00972:  MOVLW  03
00974:  MOVWF  FEA
00976:  MOVLW  99
00978:  MOVWF  FE9
0097A:  MOVLW  00
0097C:  MOVLB  0
0097E:  RCALL  028C
00980:  TBLRD*-
00982:  TBLRD*+
00984:  MOVF   FF5,W
00986:  MOVWF  FEE
00988:  IORLW  00
0098A:  BNZ   0982
.................... 			if(FLSH_REG1 & BIT0) write_text_LCD (LINE_1, 0, &text); 
0098C:  MOVLB  3
0098E:  BTFSS  xAE.0
00990:  BRA    09A6
00992:  MOVLB  4
00994:  CLRF   x39
00996:  CLRF   x3A
00998:  MOVLW  03
0099A:  MOVWF  x3C
0099C:  MOVLW  99
0099E:  MOVWF  x3B
009A0:  MOVLB  0
009A2:  RCALL  07C6
009A4:  MOVLB  3
.................... 			if(FLSH_REG1 & BIT1) write_text_LCD (LINE_2, 0, &text); 
009A6:  BTFSS  xAE.1
009A8:  BRA    09C0
009AA:  MOVLW  40
009AC:  MOVLB  4
009AE:  MOVWF  x39
009B0:  CLRF   x3A
009B2:  MOVLW  03
009B4:  MOVWF  x3C
009B6:  MOVLW  99
009B8:  MOVWF  x3B
009BA:  MOVLB  0
009BC:  RCALL  07C6
009BE:  MOVLB  3
.................... 			if(FLSH_REG1 & BIT2) write_text_LCD (LINE_3, 0, &text); 
009C0:  BTFSS  xAE.2
009C2:  BRA    09DA
009C4:  MOVLW  14
009C6:  MOVLB  4
009C8:  MOVWF  x39
009CA:  CLRF   x3A
009CC:  MOVLW  03
009CE:  MOVWF  x3C
009D0:  MOVLW  99
009D2:  MOVWF  x3B
009D4:  MOVLB  0
009D6:  RCALL  07C6
009D8:  MOVLB  3
.................... 			if(FLSH_REG1 & BIT3) write_text_LCD (LINE_4, 0, &text); 
009DA:  BTFSS  xAE.3
009DC:  BRA    09F4
009DE:  MOVLW  54
009E0:  MOVLB  4
009E2:  MOVWF  x39
009E4:  CLRF   x3A
009E6:  MOVLW  03
009E8:  MOVWF  x3C
009EA:  MOVLW  99
009EC:  MOVWF  x3B
009EE:  MOVLB  0
009F0:  RCALL  07C6
009F2:  MOVLB  3
.................... 			 
.................... 		} 
.................... 		EXT_LAMP = OFF; 
009F4:  BCF    F83.7
.................... 		BUZZER_ON = OFF; 
009F6:  BCF    F86.4
.................... 		 
.................... 	} 
009F8:  BRA    0B06
009FA:  MOVLB  1
.................... 	else 
.................... 	{	//all things are on, though alarms may need to be off. 
.................... 		if(display_type == NORMAL) 
009FC:  DECFSZ x54,W
009FE:  BRA    0AB0
.................... 		{ 
.................... 			write_text_LCD (LINE_1, 0, &display_ram[0][0]); 
00A00:  MOVLB  4
00A02:  CLRF   x39
00A04:  CLRF   x3A
00A06:  CLRF   x3C
00A08:  MOVLW  D6
00A0A:  MOVWF  x3B
00A0C:  MOVLB  0
00A0E:  RCALL  07C6
.................... 			write_text_LCD (LINE_2, 0, &display_ram[1+scroll_offset][0]); 
00A10:  MOVLW  01
00A12:  ADDWF  xA0,W
00A14:  MULLW  15
00A16:  MOVF   FF3,W
00A18:  MOVLB  3
00A1A:  CLRF   xB1
00A1C:  MOVWF  xB0
00A1E:  MOVLW  D6
00A20:  ADDWF  xB0,W
00A22:  MOVWF  01
00A24:  MOVLW  00
00A26:  ADDWFC xB1,W
00A28:  MOVWF  03
00A2A:  MOVFF  01,3B2
00A2E:  MOVWF  xB3
00A30:  MOVLW  40
00A32:  MOVLB  4
00A34:  MOVWF  x39
00A36:  CLRF   x3A
00A38:  MOVFF  03,43C
00A3C:  MOVFF  01,43B
00A40:  MOVLB  0
00A42:  RCALL  07C6
.................... 			write_text_LCD (LINE_3, 0, &display_ram[2+scroll_offset][0]); 
00A44:  MOVLW  02
00A46:  ADDWF  xA0,W
00A48:  MULLW  15
00A4A:  MOVF   FF3,W
00A4C:  MOVLB  3
00A4E:  CLRF   xB1
00A50:  MOVWF  xB0
00A52:  MOVLW  D6
00A54:  ADDWF  xB0,W
00A56:  MOVWF  01
00A58:  MOVLW  00
00A5A:  ADDWFC xB1,W
00A5C:  MOVWF  03
00A5E:  MOVFF  01,3B2
00A62:  MOVWF  xB3
00A64:  MOVLW  14
00A66:  MOVLB  4
00A68:  MOVWF  x39
00A6A:  CLRF   x3A
00A6C:  MOVFF  03,43C
00A70:  MOVFF  01,43B
00A74:  MOVLB  0
00A76:  RCALL  07C6
.................... 			write_text_LCD (LINE_4, 0, &display_ram[3+scroll_offset][0]); 
00A78:  MOVLW  03
00A7A:  ADDWF  xA0,W
00A7C:  MULLW  15
00A7E:  MOVF   FF3,W
00A80:  MOVLB  3
00A82:  CLRF   xB1
00A84:  MOVWF  xB0
00A86:  MOVLW  D6
00A88:  ADDWF  xB0,W
00A8A:  MOVWF  01
00A8C:  MOVLW  00
00A8E:  ADDWFC xB1,W
00A90:  MOVWF  03
00A92:  MOVFF  01,3B2
00A96:  MOVWF  xB3
00A98:  MOVLW  54
00A9A:  MOVLB  4
00A9C:  MOVWF  x39
00A9E:  CLRF   x3A
00AA0:  MOVFF  03,43C
00AA4:  MOVFF  01,43B
00AA8:  MOVLB  0
00AAA:  RCALL  07C6
.................... 		} 
00AAC:  BRA    0AF8
00AAE:  MOVLB  1
.................... 		else 
.................... 		{ 
.................... 			write_text_LCD (LINE_1, 0, &display_ram[0][0]); 
00AB0:  MOVLB  4
00AB2:  CLRF   x39
00AB4:  CLRF   x3A
00AB6:  CLRF   x3C
00AB8:  MOVLW  D6
00ABA:  MOVWF  x3B
00ABC:  MOVLB  0
00ABE:  RCALL  07C6
.................... 			write_text_LCD (LINE_2, 0, &display_ram[1][0]); 
00AC0:  MOVLW  40
00AC2:  MOVLB  4
00AC4:  MOVWF  x39
00AC6:  CLRF   x3A
00AC8:  CLRF   x3C
00ACA:  MOVLW  EB
00ACC:  MOVWF  x3B
00ACE:  MOVLB  0
00AD0:  RCALL  07C6
.................... 			write_text_LCD (LINE_3, 0, &display_ram[2][0]); 
00AD2:  MOVLW  14
00AD4:  MOVLB  4
00AD6:  MOVWF  x39
00AD8:  CLRF   x3A
00ADA:  MOVLW  01
00ADC:  MOVWF  x3C
00ADE:  CLRF   x3B
00AE0:  MOVLB  0
00AE2:  RCALL  07C6
.................... 			write_text_LCD (LINE_4, 0, &display_ram[3][0]); 
00AE4:  MOVLW  54
00AE6:  MOVLB  4
00AE8:  MOVWF  x39
00AEA:  CLRF   x3A
00AEC:  MOVLW  01
00AEE:  MOVWF  x3C
00AF0:  MOVLW  15
00AF2:  MOVWF  x3B
00AF4:  MOVLB  0
00AF6:  RCALL  07C6
.................... 		} 
.................... 		if(ALARM_FLAG) BUZZER_ON = ON; 
00AF8:  MOVF   xA1,F
00AFA:  BZ    0AFE
00AFC:  BSF    F86.4
.................... 		if(FLASH_FLAG) EXT_LAMP = ON; 
00AFE:  MOVF   xA2,F
00B00:  BZ    0B04
00B02:  BSF    F83.7
00B04:  MOVLB  3
.................... 	} 
.................... 	if(flash_timer >= flash_rate) flash_timer = 0; 
00B06:  MOVLB  1
00B08:  MOVF   x55,W
00B0A:  SUBLW  31
00B0C:  BC    0B10
00B0E:  CLRF   x55
00B10:  BCF    F9E.1
00B12:  MOVLB  0
00B14:  GOTO   0060
.................... } 
....................  
....................  
....................  
....................  
.................... void init_display (void) 
.................... { 
.................... 	delay_ms(100); 
*
00C1C:  MOVLW  64
00C1E:  MOVLB  2
00C20:  MOVWF  xFC
00C22:  MOVLB  0
00C24:  RCALL  0BF4
.................... 	WRITE_IR 
00C26:  BCF    F86.3
00C28:  BCF    F86.0
.................... 	LCD_IO = FUNC_SET; 
00C2A:  MOVLW  3C
00C2C:  MOVWF  F84
.................... 	CYCLE_E 
00C2E:  BSF    F83.0
00C30:  NOP   
00C32:  BCF    F83.0
.................... 	delay_ms(100); 
00C34:  MOVLW  64
00C36:  MOVLB  2
00C38:  MOVWF  xFC
00C3A:  MOVLB  0
00C3C:  RCALL  0BF4
.................... 	LCD_IO = DISP_MODE;	 
00C3E:  MOVLW  0C
00C40:  MOVWF  F84
.................... 	CYCLE_E 
00C42:  BSF    F83.0
00C44:  NOP   
00C46:  BCF    F83.0
.................... 	delay_ms(100); 
00C48:  MOVLW  64
00C4A:  MOVLB  2
00C4C:  MOVWF  xFC
00C4E:  MOVLB  0
00C50:  RCALL  0BF4
.................... 	LCD_IO = CLEAR_DISP;	 
00C52:  MOVLW  01
00C54:  MOVWF  F84
.................... 	CYCLE_E 
00C56:  BSF    F83.0
00C58:  NOP   
00C5A:  BCF    F83.0
.................... 	delay_ms(5); 
00C5C:  MOVLW  05
00C5E:  MOVLB  2
00C60:  MOVWF  xFC
00C62:  MOVLB  0
00C64:  RCALL  0BF4
.................... 	LCD_IO = ENTRY_MODE;	 
00C66:  MOVLW  06
00C68:  MOVWF  F84
.................... 	CYCLE_E 
00C6A:  BSF    F83.0
00C6C:  NOP   
00C6E:  BCF    F83.0
.................... 	delay_ms(100); 
00C70:  MOVLW  64
00C72:  MOVLB  2
00C74:  MOVWF  xFC
00C76:  MOVLB  0
00C78:  RCALL  0BF4
00C7A:  GOTO   3FC8 (RETURN)
.................... } 
....................  
....................  
.................... void write_text_LCD (int8 line, int8 col, char *pLCD_TEXT) 
.................... {	//line is a defined hex number, col 0-19) 
.................... 	int8 address; 
.................... 	int1 F_OK; 
....................  
.................... 	address =  line + col; 
*
007C6:  MOVLB  4
007C8:  MOVF   x3A,W
007CA:  ADDWF  x39,W
007CC:  MOVWF  x3D
.................... 	LCD_IO_DIR_OP; 
007CE:  CLRF   F96
.................... 	WRITE_IR 
007D0:  BCF    F86.3
007D2:  BCF    F86.0
.................... 	LCD_IO = (SET_DDRAM | address); 
007D4:  MOVF   x3D,W
007D6:  IORLW  80
007D8:  MOVWF  F84
.................... 	CYCLE_E 
007DA:  BSF    F83.0
007DC:  NOP   
007DE:  BCF    F83.0
.................... 	delay_us(50); 
007E0:  MOVLW  21
007E2:  MOVWF  00
007E4:  DECFSZ 00,F
007E6:  BRA    07E4
....................  
.................... 	while(*pLCD_TEXT != 0) 
007E8:  MOVFF  43C,03
007EC:  MOVFF  43B,FE9
007F0:  MOVFF  03,FEA
007F4:  MOVF   FEF,F
007F6:  BZ    0824
.................... 	{ 
.................... 		F_OK = 0; 
007F8:  BCF    x3E.0
.................... //		LCD_IO_DIR_IP 
.................... /*		do 
.................... 		{ 
.................... 			READ_BUSY 
.................... 			LCD_E = 1; 
.................... 			DO_NOP; 
.................... 			if(LCD_BF & BIT7) F_OK = 1; 
.................... 			LCD_E = 0; 
.................... 			delay_us(10); 
.................... 		}while (F_OK == 0); 
.................... 		LCD_E = 0; 
.................... */ 
.................... //		LCD_IO_DIR_OP; 
.................... 		LCD_IO = *pLCD_TEXT; 
007FA:  MOVFF  43C,03
007FE:  MOVFF  43B,FE9
00802:  MOVFF  03,FEA
00806:  MOVFF  FEF,F84
.................... 		WRITE_DATA 
0080A:  BSF    F86.3
0080C:  BCF    F86.0
.................... 		CYCLE_E 
0080E:  BSF    F83.0
00810:  NOP   
00812:  BCF    F83.0
.................... 		pLCD_TEXT++; 
00814:  INCF   x3B,F
00816:  BTFSC  FD8.2
00818:  INCF   x3C,F
.................... 		delay_us(50); 
0081A:  MOVLW  21
0081C:  MOVWF  00
0081E:  DECFSZ 00,F
00820:  BRA    081E
00822:  BRA    07E8
.................... 	} 
.................... DO_NOP 
00824:  NOP   
00826:  MOVLB  0
00828:  RETURN 0
.................... } 
....................  
....................  
.................... void set_run_display_ram(void) 
.................... {	//were going to do this the easy, but long winded way 
....................  
.................... 	extern int8 display_type; 
.................... 	extern int8 no_of_loos; 
.................... 	extern int8 *Ploo[11]; 
.................... 	extern int8 Loo_FREG[11]; 
.................... 	extern int8 max_scroll_offset; 
.................... 	extern char display_ram[6][21]; 
.................... 	extern int8 max_scroll_offset; 
.................... 	extern int8 TRAILER_ID; 
.................... 	extern int8 Loo_FL[11]; 
.................... 	char text[21]; 
.................... 		   				  
.................... 	reset_disp_ram(); 
*
0273C:  CALL   1120
.................... 	display_type = NORMAL; 
02740:  MOVLW  01
02742:  MOVLB  1
02744:  MOVWF  x54
.................... 	text = "UNIT   :            "; 
02746:  MOVLW  02
02748:  MOVWF  FEA
0274A:  MOVLW  50
0274C:  MOVWF  FE9
0274E:  MOVLW  00
02750:  MOVLB  0
02752:  CALL   02B2
02756:  TBLRD*-
02758:  TBLRD*+
0275A:  MOVF   FF5,W
0275C:  MOVWF  FEE
0275E:  IORLW  00
02760:  BNZ   2758
.................... 	strcpy(&display_ram[0], &text); 
02762:  CLRF   FEA
02764:  MOVLW  D6
02766:  MOVWF  FE9
02768:  MOVLW  02
0276A:  MOVWF  FE2
0276C:  MOVLW  50
0276E:  MOVWF  FE1
02770:  MOVF   FE7,F
02772:  MOVFF  FE6,FEE
02776:  BNZ   2770
.................... 	display_ram[0][6] = TRAILER_ID; 
02778:  MOVFF  A6,DC
.................... 								  
.................... 	pLoo[1] = &display_ram[1][0];		//loo1 is always here. 
0277C:  CLRF   xAC
0277E:  MOVLW  EB
02780:  MOVWF  xAB
.................... 	Loo_FREG[1] = 0; 
02782:  CLRF   xC0
.................... 	Loo_FL[1] = BIT1; 
02784:  MOVLW  02
02786:  MOVWF  xCB
.................... 	if(no_of_loos <= 2) 
02788:  MOVF   xA7,W
0278A:  SUBLW  02
0278C:  BNC   27A0
.................... 	{ 
.................... 		pLoo[2] = &display_ram[1][10]; 
0278E:  CLRF   xAE
02790:  MOVLW  F5
02792:  MOVWF  xAD
.................... 		Loo_FREG[2] = 1; 
02794:  MOVLW  01
02796:  MOVWF  xC1
.................... 		Loo_FL[2] = BIT1; 
02798:  MOVLW  02
0279A:  MOVWF  xCC
.................... 		max_scroll_offset = 0; 
0279C:  CLRF   xA8
.................... 	} 
0279E:  BRA    2920
.................... 	else if (no_of_loos <= 4) 
027A0:  MOVF   xA7,W
027A2:  SUBLW  04
027A4:  BNC   27D4
.................... 	{ 
.................... 		pLoo[2] = &display_ram[2][0]; 
027A6:  MOVLW  01
027A8:  MOVWF  xAE
027AA:  CLRF   xAD
.................... 		Loo_FREG[2] = 0; 
027AC:  CLRF   xC1
.................... 		Loo_FL[2] = BIT2; 
027AE:  MOVLW  04
027B0:  MOVWF  xCC
.................... 		pLoo[3] = &display_ram[1][10]; 
027B2:  CLRF   xB0
027B4:  MOVLW  F5
027B6:  MOVWF  xAF
.................... 		Loo_FREG[3] = 1; 
027B8:  MOVLW  01
027BA:  MOVWF  xC2
.................... 		Loo_FL[3] = BIT1; 
027BC:  MOVLW  02
027BE:  MOVWF  xCD
.................... 		pLoo[4] = &display_ram[2][10];		//doesn't matter if loo4 does not exist. 
027C0:  MOVLW  01
027C2:  MOVWF  xB2
027C4:  MOVLW  0A
027C6:  MOVWF  xB1
.................... 		Loo_FREG[4] = 1; 
027C8:  MOVLW  01
027CA:  MOVWF  xC3
.................... 		Loo_FL[4] = BIT2; 
027CC:  MOVLW  04
027CE:  MOVWF  xCE
.................... 		max_scroll_offset = 0; 
027D0:  CLRF   xA8
.................... 	} 
027D2:  BRA    2920
.................... 	else if (no_of_loos <= 6) 
027D4:  MOVF   xA7,W
027D6:  SUBLW  06
027D8:  BNC   2826
.................... 	{ 
.................... 		pLoo[2] = &display_ram[2][0]; 
027DA:  MOVLW  01
027DC:  MOVWF  xAE
027DE:  CLRF   xAD
.................... 		Loo_FREG[2] = 0; 
027E0:  CLRF   xC1
.................... 		Loo_FL[2] = BIT2; 
027E2:  MOVLW  04
027E4:  MOVWF  xCC
.................... 		pLoo[3] = &display_ram[3][0]; 
027E6:  MOVLW  01
027E8:  MOVWF  xB0
027EA:  MOVLW  15
027EC:  MOVWF  xAF
.................... 		Loo_FREG[3] = 0; 
027EE:  CLRF   xC2
.................... 		Loo_FL[3] = BIT3; 
027F0:  MOVLW  08
027F2:  MOVWF  xCD
.................... 		pLoo[4] = &display_ram[1][10];		 
027F4:  CLRF   xB2
027F6:  MOVLW  F5
027F8:  MOVWF  xB1
.................... 		Loo_FREG[4] = 1; 
027FA:  MOVLW  01
027FC:  MOVWF  xC3
.................... 		Loo_FL[4] = BIT1; 
027FE:  MOVLW  02
02800:  MOVWF  xCE
.................... 		pLoo[5] = &display_ram[2][10]; 
02802:  MOVLW  01
02804:  MOVWF  xB4
02806:  MOVLW  0A
02808:  MOVWF  xB3
.................... 		Loo_FREG[5] = 1; 
0280A:  MOVLW  01
0280C:  MOVWF  xC4
.................... 		Loo_FL[5] = BIT2; 
0280E:  MOVLW  04
02810:  MOVWF  xCF
.................... 		pLoo[6] = &display_ram[3][10]; 
02812:  MOVLW  01
02814:  MOVWF  xB6
02816:  MOVLW  1F
02818:  MOVWF  xB5
.................... 		Loo_FREG[6] = 1; 
0281A:  MOVLW  01
0281C:  MOVWF  xC5
.................... 		Loo_FL[6] = BIT3; 
0281E:  MOVLW  08
02820:  MOVWF  xD0
.................... 		max_scroll_offset = 0; 
02822:  CLRF   xA8
.................... 	} 
02824:  BRA    2920
.................... 	else if (no_of_loos <= 8) 
02826:  MOVF   xA7,W
02828:  SUBLW  08
0282A:  BNC   2898
.................... 	{ 
.................... 		pLoo[2] = &display_ram[2][0]; 
0282C:  MOVLW  01
0282E:  MOVWF  xAE
02830:  CLRF   xAD
.................... 		Loo_FREG[2] = 0; 
02832:  CLRF   xC1
.................... 		Loo_FL[2] = BIT2; 
02834:  MOVLW  04
02836:  MOVWF  xCC
.................... 		pLoo[3] = &display_ram[3][0]; 
02838:  MOVLW  01
0283A:  MOVWF  xB0
0283C:  MOVLW  15
0283E:  MOVWF  xAF
.................... 		Loo_FREG[3] = 0; 
02840:  CLRF   xC2
.................... 		Loo_FL[3] = BIT3; 
02842:  MOVLW  08
02844:  MOVWF  xCD
.................... 		pLoo[4] = &display_ram[4][0];		 
02846:  MOVLW  01
02848:  MOVWF  xB2
0284A:  MOVLW  2A
0284C:  MOVWF  xB1
.................... 		Loo_FREG[4] = 0; 
0284E:  CLRF   xC3
.................... 		Loo_FL[4] = BIT4; 
02850:  MOVLW  10
02852:  MOVWF  xCE
.................... 		pLoo[5] = &display_ram[1][10]; 
02854:  CLRF   xB4
02856:  MOVLW  F5
02858:  MOVWF  xB3
.................... 		Loo_FREG[5] = 1; 
0285A:  MOVLW  01
0285C:  MOVWF  xC4
.................... 		Loo_FL[5] = BIT1; 
0285E:  MOVLW  02
02860:  MOVWF  xCF
.................... 		pLoo[6] = &display_ram[2][10]; 
02862:  MOVLW  01
02864:  MOVWF  xB6
02866:  MOVLW  0A
02868:  MOVWF  xB5
.................... 		Loo_FREG[6] = 1; 
0286A:  MOVLW  01
0286C:  MOVWF  xC5
.................... 		Loo_FL[6] = BIT2; 
0286E:  MOVLW  04
02870:  MOVWF  xD0
.................... 		pLoo[7] = &display_ram[3][10]; 
02872:  MOVLW  01
02874:  MOVWF  xB8
02876:  MOVLW  1F
02878:  MOVWF  xB7
.................... 		Loo_FREG[7] = 1; 
0287A:  MOVLW  01
0287C:  MOVWF  xC6
.................... 		Loo_FL[7] = BIT3; 
0287E:  MOVLW  08
02880:  MOVWF  xD1
.................... 		pLoo[8] = &display_ram[4][10]; 
02882:  MOVLW  01
02884:  MOVWF  xBA
02886:  MOVLW  34
02888:  MOVWF  xB9
.................... 		Loo_FREG[8] = 1; 
0288A:  MOVLW  01
0288C:  MOVWF  xC7
.................... 		Loo_FL[8] = BIT4; 
0288E:  MOVLW  10
02890:  MOVWF  xD2
.................... 		max_scroll_offset = 1; 
02892:  MOVLW  01
02894:  MOVWF  xA8
.................... 	} 
02896:  BRA    2920
.................... 	else  
.................... 	{ 
.................... 		pLoo[2] = &display_ram[2][0]; 
02898:  MOVLW  01
0289A:  MOVWF  xAE
0289C:  CLRF   xAD
.................... 		Loo_FREG[2] = 0; 
0289E:  CLRF   xC1
.................... 		Loo_FL[2] = BIT2; 
028A0:  MOVLW  04
028A2:  MOVWF  xCC
.................... 		pLoo[3] = &display_ram[3][0]; 
028A4:  MOVLW  01
028A6:  MOVWF  xB0
028A8:  MOVLW  15
028AA:  MOVWF  xAF
.................... 		Loo_FREG[3] = 0; 
028AC:  CLRF   xC2
.................... 		Loo_FL[3] = BIT3; 
028AE:  MOVLW  08
028B0:  MOVWF  xCD
.................... 		pLoo[4] = &display_ram[4][0];		 
028B2:  MOVLW  01
028B4:  MOVWF  xB2
028B6:  MOVLW  2A
028B8:  MOVWF  xB1
.................... 		Loo_FREG[4] = 0; 
028BA:  CLRF   xC3
.................... 		Loo_FL[4] = BIT4; 
028BC:  MOVLW  10
028BE:  MOVWF  xCE
.................... 		pLoo[5] = &display_ram[5][0]; 
028C0:  MOVLW  01
028C2:  MOVWF  xB4
028C4:  MOVLW  3F
028C6:  MOVWF  xB3
.................... 		Loo_FREG[5] = 0; 
028C8:  CLRF   xC4
.................... 		Loo_FL[5] = BIT5; 
028CA:  MOVLW  20
028CC:  MOVWF  xCF
.................... 		pLoo[6] = &display_ram[1][10]; 
028CE:  CLRF   xB6
028D0:  MOVLW  F5
028D2:  MOVWF  xB5
.................... 		Loo_FREG[6] = 1; 
028D4:  MOVLW  01
028D6:  MOVWF  xC5
.................... 		Loo_FL[6] = BIT1; 
028D8:  MOVLW  02
028DA:  MOVWF  xD0
.................... 		pLoo[7] = &display_ram[2][10]; 
028DC:  MOVLW  01
028DE:  MOVWF  xB8
028E0:  MOVLW  0A
028E2:  MOVWF  xB7
.................... 		Loo_FREG[7] = 1; 
028E4:  MOVLW  01
028E6:  MOVWF  xC6
.................... 		Loo_FL[7] = BIT2; 
028E8:  MOVLW  04
028EA:  MOVWF  xD1
.................... 		pLoo[8] = &display_ram[3][10]; 
028EC:  MOVLW  01
028EE:  MOVWF  xBA
028F0:  MOVLW  1F
028F2:  MOVWF  xB9
.................... 		Loo_FREG[8] = 1; 
028F4:  MOVLW  01
028F6:  MOVWF  xC7
.................... 		Loo_FL[8] = BIT3; 
028F8:  MOVLW  08
028FA:  MOVWF  xD2
.................... 		pLoo[9] = &display_ram[4][10]; 
028FC:  MOVLW  01
028FE:  MOVWF  xBC
02900:  MOVLW  34
02902:  MOVWF  xBB
.................... 		Loo_FREG[9] = 1; 
02904:  MOVLW  01
02906:  MOVWF  xC8
.................... 		Loo_FL[9] = BIT4; 
02908:  MOVLW  10
0290A:  MOVWF  xD3
.................... 		pLoo[10] = &display_ram[5][10]; 
0290C:  MOVLW  01
0290E:  MOVWF  xBE
02910:  MOVLW  49
02912:  MOVWF  xBD
.................... 		Loo_FREG[10] = 1; 
02914:  MOVLW  01
02916:  MOVWF  xC9
.................... 		Loo_FL[10] = BIT5; 
02918:  MOVLW  20
0291A:  MOVWF  xD4
.................... 		max_scroll_offset = 2; 
0291C:  MOVLW  02
0291E:  MOVWF  xA8
.................... 	} 
.................... 	(*pLoo[1]) = '1';		 
02920:  MOVFF  AB,FE9
02924:  MOVFF  AC,FEA
02928:  MOVLW  31
0292A:  MOVWF  FEF
.................... 	if(no_of_loos >= 2)(*pLoo[2]) = '2';		 
0292C:  MOVF   xA7,W
0292E:  SUBLW  01
02930:  BC    293E
02932:  MOVFF  AD,FE9
02936:  MOVFF  AE,FEA
0293A:  MOVLW  32
0293C:  MOVWF  FEF
.................... 	if(no_of_loos >= 3)(*pLoo[3]) = '3';		 
0293E:  MOVF   xA7,W
02940:  SUBLW  02
02942:  BC    2950
02944:  MOVFF  AF,FE9
02948:  MOVFF  B0,FEA
0294C:  MOVLW  33
0294E:  MOVWF  FEF
.................... 	if(no_of_loos >= 4)(*pLoo[4]) = '4';		 
02950:  MOVF   xA7,W
02952:  SUBLW  03
02954:  BC    2962
02956:  MOVFF  B1,FE9
0295A:  MOVFF  B2,FEA
0295E:  MOVLW  34
02960:  MOVWF  FEF
.................... 	if(no_of_loos >= 5)(*pLoo[5]) = '5';		 
02962:  MOVF   xA7,W
02964:  SUBLW  04
02966:  BC    2974
02968:  MOVFF  B3,FE9
0296C:  MOVFF  B4,FEA
02970:  MOVLW  35
02972:  MOVWF  FEF
.................... 	if(no_of_loos >= 6)(*pLoo[6]) = '6';		 
02974:  MOVF   xA7,W
02976:  SUBLW  05
02978:  BC    2986
0297A:  MOVFF  B5,FE9
0297E:  MOVFF  B6,FEA
02982:  MOVLW  36
02984:  MOVWF  FEF
.................... 	if(no_of_loos >= 7)(*pLoo[7]) = '7';		 
02986:  MOVF   xA7,W
02988:  SUBLW  06
0298A:  BC    2998
0298C:  MOVFF  B7,FE9
02990:  MOVFF  B8,FEA
02994:  MOVLW  37
02996:  MOVWF  FEF
.................... 	if(no_of_loos >= 8)(*pLoo[8]) = '8';		 
02998:  MOVF   xA7,W
0299A:  SUBLW  07
0299C:  BC    29AA
0299E:  MOVFF  B9,FE9
029A2:  MOVFF  BA,FEA
029A6:  MOVLW  38
029A8:  MOVWF  FEF
.................... 	if(no_of_loos >= 9)(*pLoo[9]) = '9';		 
029AA:  MOVF   xA7,W
029AC:  SUBLW  08
029AE:  BC    29BC
029B0:  MOVFF  BB,FE9
029B4:  MOVFF  BC,FEA
029B8:  MOVLW  39
029BA:  MOVWF  FEF
.................... 	if(no_of_loos == 10) (*pLoo[10]) = 'A';		 
029BC:  MOVF   xA7,W
029BE:  SUBLW  0A
029C0:  BNZ   29CE
029C2:  MOVFF  BD,FE9
029C6:  MOVFF  BE,FEA
029CA:  MOVLW  41
029CC:  MOVWF  FEF
029CE:  GOTO   4032 (RETURN)
.................... } 
....................  
.................... #INCLUDE <LW_Attendant_Func.c> 
.................... /*************************************************************************************** 
.................... * Name:   	LW_Attendant_Func.C 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:  	Phil Hockley 
.................... * 
.................... * Description: 
.................... *		 	Control PCB functions. 
.................... * 
.................... * History: 	30/03/15	Initial code started 
.................... *			 
.................... ****************************************************************************************/ 
.................... //Define use of I2C for USB interface. 
.................... #USE I2C (MASTER,SLOW,I2C2) 
*
022E8:  MOVLB  E
022EA:  BCF    xFF.7
022EC:  BCF    FA1.5
022EE:  MOVFF  2F9,F02
022F2:  MOVLW  02
022F4:  BTFSC  xFF.7
022F6:  BRA    2302
022F8:  BTFSS  FA1.5
022FA:  BRA    22F8
022FC:  MOVLW  00
022FE:  BTFSC  xFE.6
02300:  MOVLW  01
02302:  MOVWF  01
02304:  MOVLB  0
02306:  RETURN 0
*
023B0:  MOVLB  E
023B2:  BCF    xFF.6
023B4:  BSF    xFE.3
023B6:  BTFSC  xFE.3
023B8:  BRA    23B6
023BA:  BTFSC  00.0
023BC:  BCF    xFE.5
023BE:  BTFSS  00.0
023C0:  BSF    xFE.5
023C2:  BSF    xFE.4
023C4:  BTFSC  xFE.4
023C6:  BRA    23C4
023C8:  MOVFF  F02,01
023CC:  MOVLB  0
023CE:  GOTO   2468 (RETURN)
....................  
.................... void INIT_USART1 (void) 
.................... { 
.................... 	RCSTA1 = 0;		//ensure completely reset 
*
00BC8:  CLRF   FAB
.................... 	SPBRG1 = 25; 
00BCA:  MOVLW  19
00BCC:  MOVWF  FAF
.................... 	BAUD1CON = 0; 
00BCE:  CLRF   F65
.................... 	RCSTA1 = 0b10000000; 
00BD0:  MOVLW  80
00BD2:  MOVWF  FAB
.................... 	TXSTA1 = 0b00000100; 
00BD4:  MOVLW  04
00BD6:  MOVWF  FAC
00BD8:  RETURN 0
.................... } 
....................  
.................... void INIT_USART2 (void) 
.................... { 
.................... 	RCSTA2 = 0;		//ensure completely reset 
00BDA:  MOVLB  F
00BDC:  CLRF   x22
.................... 	SPBRG2 = 25;	 
00BDE:  MOVLW  19
00BE0:  MOVWF  x1E
.................... 	BAUD2CON = 0; 
00BE2:  CLRF   x20
.................... 	RCSTA2 = 0b10000000; 
00BE4:  MOVLW  80
00BE6:  MOVWF  x22
.................... 	TXSTA2 = 0b00100100; 
00BE8:  MOVLW  24
00BEA:  MOVWF  x21
.................... 	DIR2 = DIR_TX; 
00BEC:  BSF    F82.1
00BEE:  MOVLB  0
00BF0:  GOTO   3FC4 (RETURN)
.................... } 
....................  
.................... void INIT_ALL (void) 
.................... { 
.................... 	OSCCON = 0;	//external crystal... 
*
00B18:  CLRF   FD3
.................... 	PORTA = 0; 
00B1A:  CLRF   F80
.................... 	PORTB = 0; 
00B1C:  CLRF   F81
.................... 	PORTC = 0;	 
00B1E:  CLRF   F82
.................... 	PORTD = 0; 
00B20:  CLRF   F83
.................... 	PORTE = 0; 
00B22:  CLRF   F84
.................... 	PORTF = 0; 
00B24:  CLRF   F85
.................... 	PORTG = 0; 
00B26:  CLRF   F86
.................... 	TRISA = 0; 
00B28:  CLRF   F92
.................... 	TRISB = 0; 
00B2A:  CLRF   F93
.................... 	TRISC = 0b10100000; 
00B2C:  MOVLW  A0
00B2E:  MOVWF  F94
.................... 	TRISD = 0b01100000; 
00B30:  MOVLW  60
00B32:  MOVWF  F95
.................... 	TRISE = 0; 
00B34:  CLRF   F96
.................... 	TRISF = 0b00111110; 
00B36:  MOVLW  3E
00B38:  MOVWF  F97
.................... 	TRISG = 0b00100100;		//PWM output must be disabled when set up, changed later so beware!!! 
00B3A:  MOVLW  24
00B3C:  MOVWF  F98
.................... 	ADCON0 = 0b00011101; 	//using AN7 only 
00B3E:  MOVLW  1D
00B40:  MOVWF  FC2
.................... 	ADCON1 = 0b00110000;	//internal 4.096V reference 
00B42:  MOVLW  30
00B44:  MOVWF  FC1
.................... 	ADCON2 = 0b10110101;	//16TAD, and Fosc/16 
00B46:  MOVLW  B5
00B48:  MOVWF  FC0
.................... 	ANCON0 = 0b10000000;	//Using AN7 only 
00B4A:  MOVLW  80
00B4C:  MOVLB  F
00B4E:  MOVWF  x25
.................... 	ANCON2 = 0; 
00B50:  CLRF   x23
.................... 	//Timer 1 set up 
.................... 	T1CON = 0b00000110;		//overflows every 32mS or so 
00B52:  MOVLW  06
00B54:  MOVWF  FCD
.................... 	WDTCON = 0b00011000;	//under FW control, and off! 
00B56:  MOVLW  18
00B58:  MOVWF  FD1
.................... 	//set up required interrupts 
.................... 	INTCON = 0;	//Don't allow global interrupts yet 
00B5A:  CLRF   FF2
.................... 	PIE1 = 0; 
00B5C:  CLRF   F9D
.................... 	PIE2 = 0; 
00B5E:  CLRF   FA0
.................... 	PIE3 = 0; 
00B60:  CLRF   FA3
.................... 	PIE4 = 0; 
00B62:  CLRF   FB6
.................... 	//set up SPI/I2C  interfaces 
.................... //	i2c_speed (100000); 
.................... 	//i2c_init(TRUE);  
.................... 	T2CON = 0b01111111; 
00B64:  MOVLW  7F
00B66:  MOVWF  FCA
.................... 	PR2 = 159;				//20mS display update at 8MHz 
00B68:  MOVLW  9F
00B6A:  MOVWF  FCB
.................... 	TMR2 = 0; 
00B6C:  CLRF   FCC
.................... 	FLASHING_ON 
00B6E:  BCF    F9E.1
00B70:  CLRF   FCC
00B72:  BSF    F9D.1
.................... 	INT_EN 
00B74:  MOVLW  C0
00B76:  IORWF  FF2,F
.................... 	if(read_eeprom(no_of_units) > 10) write_eeprom(no_of_units,0); 
00B78:  MOVFF  FF2,250
00B7C:  BCF    FF2.7
00B7E:  CLRF   F63
00B80:  MOVLW  01
00B82:  MOVWF  F62
00B84:  BCF    F7F.6
00B86:  BCF    F7F.7
00B88:  BSF    F7F.0
00B8A:  MOVF   F61,W
00B8C:  MOVLB  2
00B8E:  BTFSC  x50.7
00B90:  BSF    FF2.7
00B92:  SUBLW  0A
00B94:  BC    0BC2
00B96:  MOVF   FF2,W
00B98:  MOVWF  00
00B9A:  BCF    FF2.7
00B9C:  CLRF   F63
00B9E:  MOVLW  01
00BA0:  MOVWF  F62
00BA2:  CLRF   F61
00BA4:  BCF    F7F.6
00BA6:  BCF    F7F.7
00BA8:  BSF    F7F.2
00BAA:  MOVLB  F
00BAC:  MOVLW  55
00BAE:  MOVWF  F7E
00BB0:  MOVLW  AA
00BB2:  MOVWF  F7E
00BB4:  BSF    F7F.1
00BB6:  BTFSC  F7F.1
00BB8:  BRA    0BB6
00BBA:  BCF    F7F.2
00BBC:  MOVF   00,W
00BBE:  IORWF  FF2,F
00BC0:  MOVLB  2
00BC2:  MOVLB  0
00BC4:  GOTO   3FBC (RETURN)
.................... } 
....................  
....................  
....................  
.................... int16 CHK_BATT (void) 
.................... {	//reads battery Voltage, and averages over 4 samples 
.................... 	//throwing out the first reading. If below setpoint  
.................... 	//stores data in EEPROM. 
....................  
.................... 	int8 i; 
.................... 	int16 result; 
....................  
.................... 	result = 0; 
.................... 	for(i=0;i<5;i++) 
.................... 	{ 
.................... 		delay_us(20);		//aq time 
.................... 		GO_DONE = 1;		//start ADC 
.................... 		while(GO_DONE); 
.................... 		if(i != 0) result += ((int16)(ADRESH*256) + (int16)(ADRESL)); 
.................... 	} 
.................... 	result = result/4; 
.................... 	return result; 
.................... } 
....................  
.................... int1 chk_up (void) 
.................... { 
.................... 	static int8 count,PB_released = 0; 
....................  
.................... 	if(PB_UP) 
*
00E5E:  BTFSS  F85.3
00E60:  BRA    0E6C
.................... 	{ 
.................... 		count = 0; 
00E62:  MOVLB  1
00E64:  CLRF   x56
.................... 		PB_released = 0; 
00E66:  CLRF   x57
.................... 	} 
00E68:  BRA    0E74
00E6A:  MOVLB  0
.................... 	else 
.................... 	{ 
.................... 		if(PB_released == 0) count++; 
00E6C:  MOVLB  1
00E6E:  MOVF   x57,F
00E70:  BNZ   0E74
00E72:  INCF   x56,F
.................... 	} 
.................... 	if(count > debounce_time) 
00E74:  MOVF   x56,W
00E76:  SUBLW  02
00E78:  BC    0E84
.................... 	{ 
.................... 		count = 0; 
00E7A:  CLRF   x56
.................... 		PB_released = 1; 
00E7C:  MOVLW  01
00E7E:  MOVWF  x57
.................... 		return 1; 
00E80:  MOVWF  01
00E82:  BRA    0E88
.................... 	} 
.................... 	return 0; 
00E84:  MOVLW  00
00E86:  MOVWF  01
00E88:  MOVLB  0
00E8A:  RETURN 0
.................... } 
....................  
.................... int1 chk_dn (void) 
.................... { 
.................... 	static int8 count,PB_released = 0; 
....................  
.................... 	if(PB_DN) 
00E8C:  BTFSS  F85.4
00E8E:  BRA    0E9A
.................... 	{ 
.................... 		count = 0; 
00E90:  MOVLB  1
00E92:  CLRF   x58
.................... 		PB_released = 0; 
00E94:  CLRF   x59
.................... 	} 
00E96:  BRA    0EA2
00E98:  MOVLB  0
.................... 	else 
.................... 	{ 
.................... 		if(PB_released == 0) count++; 
00E9A:  MOVLB  1
00E9C:  MOVF   x59,F
00E9E:  BNZ   0EA2
00EA0:  INCF   x58,F
.................... 	} 
.................... 	if(count > debounce_time) 
00EA2:  MOVF   x58,W
00EA4:  SUBLW  02
00EA6:  BC    0EB2
.................... 	{ 
.................... 		count = 0; 
00EA8:  CLRF   x58
.................... 		PB_released = 1; 
00EAA:  MOVLW  01
00EAC:  MOVWF  x59
.................... 		return 1; 
00EAE:  MOVWF  01
00EB0:  BRA    0EB6
.................... 	} 
.................... 	return 0; 
00EB2:  MOVLW  00
00EB4:  MOVWF  01
00EB6:  MOVLB  0
00EB8:  RETURN 0
.................... } 
....................  
.................... int1 chk_ent (void) 
.................... { 
.................... 	static int8 count,PB_released = 0; 
....................  
.................... 	if(PB_ENT) 
00EBA:  BTFSS  F85.5
00EBC:  BRA    0EC8
.................... 	{ 
.................... 		count = 0; 
00EBE:  MOVLB  1
00EC0:  CLRF   x5A
.................... 		PB_released = 0; 
00EC2:  CLRF   x5B
.................... 	} 
00EC4:  BRA    0ED0
00EC6:  MOVLB  0
.................... 	else 
.................... 	{ 
.................... 		if(PB_released == 0) count++; 
00EC8:  MOVLB  1
00ECA:  MOVF   x5B,F
00ECC:  BNZ   0ED0
00ECE:  INCF   x5A,F
.................... 	} 
.................... 	if(count > debounce_time) 
00ED0:  MOVF   x5A,W
00ED2:  SUBLW  02
00ED4:  BC    0EE0
.................... 	{ 
.................... 		count = 0; 
00ED6:  CLRF   x5A
.................... 		PB_released = 1; 
00ED8:  MOVLW  01
00EDA:  MOVWF  x5B
.................... 		return 1; 
00EDC:  MOVWF  01
00EDE:  BRA    0EE4
.................... 	} 
.................... 	return 0; 
00EE0:  MOVLW  00
00EE2:  MOVWF  01
00EE4:  MOVLB  0
00EE6:  RETURN 0
....................  
.................... } 
....................  
....................  
.................... void read_RTC (void) 
.................... { 
.................... 	extern TIME_STAMP; 
.................... 	extern *pTIME_STAMP; 
....................  
.................... 	pTIME_STAMP = &TIME_STAMP;	 
*
0196C:  CLRF   23
0196E:  MOVLW  1C
01970:  MOVWF  22
.................... 	RTC_EN 
01972:  BCF    F82.2
01974:  NOP   
01976:  BSF    F82.3
.................... 	SEND_SPI(read_time_date); 
01978:  MOVLW  88
0197A:  MOVLB  2
0197C:  MOVWF  xF6
0197E:  MOVLB  0
01980:  CALL   0D42
.................... 	pTIME_STAMP->sec = SEND_SPI(0); 
01984:  MOVFF  22,01
01988:  MOVFF  23,03
0198C:  MOVFF  22,2F4
01990:  MOVLB  2
01992:  MOVFF  23,2F5
01996:  CLRF   xF6
01998:  MOVLB  0
0199A:  CALL   0D42
0199E:  MOVFF  2F5,FEA
019A2:  MOVFF  2F4,FE9
019A6:  MOVFF  01,FEF
.................... 	pTIME_STAMP->min = SEND_SPI(0); 
019AA:  MOVLW  01
019AC:  ADDWF  22,W
019AE:  MOVWF  01
019B0:  MOVLW  00
019B2:  ADDWFC 23,W
019B4:  MOVWF  03
019B6:  MOVFF  01,2F4
019BA:  MOVLB  2
019BC:  MOVWF  xF5
019BE:  CLRF   xF6
019C0:  MOVLB  0
019C2:  CALL   0D42
019C6:  MOVFF  2F5,FEA
019CA:  MOVFF  2F4,FE9
019CE:  MOVFF  01,FEF
.................... 	pTIME_STAMP->hour = SEND_SPI(0); 
019D2:  MOVLW  02
019D4:  ADDWF  22,W
019D6:  MOVWF  01
019D8:  MOVLW  00
019DA:  ADDWFC 23,W
019DC:  MOVWF  03
019DE:  MOVFF  01,2F4
019E2:  MOVLB  2
019E4:  MOVWF  xF5
019E6:  CLRF   xF6
019E8:  MOVLB  0
019EA:  CALL   0D42
019EE:  MOVFF  2F5,FEA
019F2:  MOVFF  2F4,FE9
019F6:  MOVFF  01,FEF
.................... 	pTIME_STAMP->day = SEND_SPI(0); 
019FA:  MOVLW  03
019FC:  ADDWF  22,W
019FE:  MOVWF  01
01A00:  MOVLW  00
01A02:  ADDWFC 23,W
01A04:  MOVWF  03
01A06:  MOVFF  01,2F4
01A0A:  MOVLB  2
01A0C:  MOVWF  xF5
01A0E:  CLRF   xF6
01A10:  MOVLB  0
01A12:  CALL   0D42
01A16:  MOVFF  2F5,FEA
01A1A:  MOVFF  2F4,FE9
01A1E:  MOVFF  01,FEF
.................... 	SEND_SPI(0);					//ignore this it is actually weekends 
01A22:  MOVLB  2
01A24:  CLRF   xF6
01A26:  MOVLB  0
01A28:  CALL   0D42
.................... 	pTIME_STAMP->month = SEND_SPI(0);	 
01A2C:  MOVLW  04
01A2E:  ADDWF  22,W
01A30:  MOVWF  01
01A32:  MOVLW  00
01A34:  ADDWFC 23,W
01A36:  MOVWF  03
01A38:  MOVFF  01,2F4
01A3C:  MOVLB  2
01A3E:  MOVWF  xF5
01A40:  CLRF   xF6
01A42:  MOVLB  0
01A44:  CALL   0D42
01A48:  MOVFF  2F5,FEA
01A4C:  MOVFF  2F4,FE9
01A50:  MOVFF  01,FEF
.................... 	pTIME_STAMP->year = SEND_SPI(0); 
01A54:  MOVLW  05
01A56:  ADDWF  22,W
01A58:  MOVWF  01
01A5A:  MOVLW  00
01A5C:  ADDWFC 23,W
01A5E:  MOVWF  03
01A60:  MOVFF  01,2F4
01A64:  MOVLB  2
01A66:  MOVWF  xF5
01A68:  CLRF   xF6
01A6A:  MOVLB  0
01A6C:  CALL   0D42
01A70:  MOVFF  2F5,FEA
01A74:  MOVFF  2F4,FE9
01A78:  MOVFF  01,FEF
.................... 	RTC_DIS 
01A7C:  BCF    F82.3
01A7E:  BCF    F82.2
01A80:  RETURN 0
.................... } 
....................  
.................... void write_RTC (void) 
.................... { 
.................... 	extern TIME_STAMP; 
.................... 	extern *pTIME_STAMP; 
.................... 	 
.................... 	pTIME_STAMP = &TIME_STAMP;	 
*
01C7E:  CLRF   23
01C80:  MOVLW  1C
01C82:  MOVWF  22
.................... 	RTC_EN 
01C84:  BCF    F82.2
01C86:  NOP   
01C88:  BSF    F82.3
.................... 	SEND_SPI(write_time_date); 
01C8A:  MOVLW  08
01C8C:  MOVLB  2
01C8E:  MOVWF  xF6
01C90:  MOVLB  0
01C92:  CALL   0D42
.................... 	SEND_SPI(pTIME_STAMP->sec);  
01C96:  MOVFF  22,FE9
01C9A:  MOVFF  23,FEA
01C9E:  MOVFF  FEF,2F6
01CA2:  CALL   0D42
.................... 	SEND_SPI(pTIME_STAMP->min);  
01CA6:  MOVLW  01
01CA8:  ADDWF  22,W
01CAA:  MOVWF  FE9
01CAC:  MOVLW  00
01CAE:  ADDWFC 23,W
01CB0:  MOVWF  FEA
01CB2:  MOVFF  FEF,2F6
01CB6:  CALL   0D42
.................... 	SEND_SPI(pTIME_STAMP->hour);  
01CBA:  MOVLW  02
01CBC:  ADDWF  22,W
01CBE:  MOVWF  FE9
01CC0:  MOVLW  00
01CC2:  ADDWFC 23,W
01CC4:  MOVWF  FEA
01CC6:  MOVFF  FEF,2F6
01CCA:  CALL   0D42
.................... 	SEND_SPI(pTIME_STAMP->day);  
01CCE:  MOVLW  03
01CD0:  ADDWF  22,W
01CD2:  MOVWF  FE9
01CD4:  MOVLW  00
01CD6:  ADDWFC 23,W
01CD8:  MOVWF  FEA
01CDA:  MOVFF  FEF,2F6
01CDE:  CALL   0D42
.................... 	SEND_SPI(0); 					//we don't care about weekends 
01CE2:  MOVLB  2
01CE4:  CLRF   xF6
01CE6:  MOVLB  0
01CE8:  CALL   0D42
.................... 	SEND_SPI(pTIME_STAMP->month);  
01CEC:  MOVLW  04
01CEE:  ADDWF  22,W
01CF0:  MOVWF  FE9
01CF2:  MOVLW  00
01CF4:  ADDWFC 23,W
01CF6:  MOVWF  FEA
01CF8:  MOVFF  FEF,2F6
01CFC:  CALL   0D42
.................... 	SEND_SPI(pTIME_STAMP->year);  
01D00:  MOVLW  05
01D02:  ADDWF  22,W
01D04:  MOVWF  FE9
01D06:  MOVLW  00
01D08:  ADDWFC 23,W
01D0A:  MOVWF  FEA
01D0C:  MOVFF  FEF,2F6
01D10:  CALL   0D42
.................... 	RTC_DIS 
01D14:  BCF    F82.3
01D16:  BCF    F82.2
01D18:  GOTO   1FE6 (RETURN)
.................... } 
....................  
....................  
.................... int8 SEND_SPI (int8 spid_out) 
.................... { 
.................... 	int8 i,spid_in; 
....................  
.................... 	for(i=0;i<8;i++) 
*
00D42:  MOVLB  2
00D44:  CLRF   xF7
00D46:  MOVF   xF7,W
00D48:  SUBLW  07
00D4A:  BNC   0D76
.................... 	{ 
.................... 		if(spid_out & BIT7) {SPI_SDO = 1;} else {SPI_SDO = 0;} 
00D4C:  BTFSS  xF6.7
00D4E:  BRA    0D54
00D50:  BSF    F82.4
00D52:  BRA    0D56
00D54:  BCF    F82.4
.................... 		SPI_SCK = 0; 
00D56:  BCF    F82.2
.................... 		spid_out = spid_out << 1; 
00D58:  BCF    FD8.0
00D5A:  RLCF   xF6,F
.................... 		SPI_SCK = 1; 
00D5C:  BSF    F82.2
.................... 		if(SPI_SDI == 1)  
00D5E:  BTFSS  F82.5
00D60:  BRA    0D66
.................... 		{ 
.................... 			spid_in |= BIT0; 
00D62:  BSF    xF8.0
.................... 		}  
00D64:  BRA    0D68
.................... 		else  
.................... 		{ 
.................... 			spid_in &= ~BIT0; 
00D66:  BCF    xF8.0
.................... 		} 
.................... 		if(i < 7) spid_in = spid_in << 1; 
00D68:  MOVF   xF7,W
00D6A:  SUBLW  06
00D6C:  BNC   0D72
00D6E:  BCF    FD8.0
00D70:  RLCF   xF8,F
00D72:  INCF   xF7,F
00D74:  BRA    0D46
.................... 	} 
.................... 	return spid_in; 
00D76:  MOVFF  2F8,01
00D7A:  MOVLB  0
00D7C:  RETURN 0
.................... }	 
....................  
.................... int1 write_to_usb (int8 USB_CMD, char *pUSB_DATA) 
.................... { 
.................... 	int8 ACK; 
....................  
.................... 	i2c_start(); 
*
02308:  MOVLB  E
0230A:  BSF    xFE.0
0230C:  BTFSC  xFE.0
0230E:  BRA    230C
.................... 	ACK = i2c_write(USB_I2C_ADDR);     // Device address 
02310:  MOVLW  52
02312:  MOVLB  2
02314:  MOVWF  xF9
02316:  MOVLB  0
02318:  RCALL  22E8
0231A:  MOVFF  01,2F7
.................... 	if(ACK != 0) {i2c_stop(); return 0;} 
0231E:  MOVLB  2
02320:  MOVF   xF7,F
02322:  BZ    2334
02324:  MOVLB  E
02326:  BSF    xFE.2
02328:  BTFSC  xFE.2
0232A:  BRA    2328
0232C:  MOVLW  00
0232E:  MOVWF  01
02330:  BRA    23AC
02332:  MOVLB  2
.................... 	if(USB_CMD !=0xFF) ACK = i2c_write(USB_CMD); 
02334:  INCFSZ xF4,W
02336:  BRA    233A
02338:  BRA    2348
0233A:  MOVFF  2F4,2F9
0233E:  MOVLB  0
02340:  RCALL  22E8
02342:  MOVFF  01,2F7
02346:  MOVLB  2
.................... 	if(ACK != 0) {i2c_stop(); return 0;} 
02348:  MOVF   xF7,F
0234A:  BZ    235C
0234C:  MOVLB  E
0234E:  BSF    xFE.2
02350:  BTFSC  xFE.2
02352:  BRA    2350
02354:  MOVLW  00
02356:  MOVWF  01
02358:  BRA    23AC
0235A:  MOVLB  2
.................... 	do 
.................... 	{ 
.................... 		ACK = i2c_write(*pUSB_DATA); 
0235C:  MOVFF  2F6,03
02360:  MOVFF  2F5,FE9
02364:  MOVFF  03,FEA
02368:  MOVFF  FEF,2F9
0236C:  MOVLB  0
0236E:  RCALL  22E8
02370:  MOVFF  01,2F7
.................... 		if(ACK != 0) {i2c_stop(); return 0;} 
02374:  MOVLB  2
02376:  MOVF   xF7,F
02378:  BZ    238A
0237A:  MOVLB  E
0237C:  BSF    xFE.2
0237E:  BTFSC  xFE.2
02380:  BRA    237E
02382:  MOVLW  00
02384:  MOVWF  01
02386:  BRA    23AC
02388:  MOVLB  2
.................... 		pUSB_DATA++; 
0238A:  INCF   xF5,F
0238C:  BTFSC  FD8.2
0238E:  INCF   xF6,F
.................... 	}while (*pUSB_DATA != 0); 
02390:  MOVFF  2F6,03
02394:  MOVFF  2F5,FE9
02398:  MOVFF  03,FEA
0239C:  MOVF   FEF,F
0239E:  BNZ   235C
.................... 	i2c_stop(); 
023A0:  MOVLB  E
023A2:  BSF    xFE.2
023A4:  BTFSC  xFE.2
023A6:  BRA    23A4
.................... 	return 1; 
023A8:  MOVLW  01
023AA:  MOVWF  01
023AC:  MOVLB  0
023AE:  RETURN 0
.................... } 
....................  
.................... int8 USB_ready (void) 
*
023D2:  MOVLB  2
023D4:  CLRF   xF6
.................... {	//if after 1000mS it has not found the USB then it exits. 
.................... 	//looks in 20mS steps with a simple delay, so count = 50 attempts. 
.................... 	int8 i,ACK; 
.................... 	int8 ready_F = 0; 
....................  
.................... 	for(i=0;i<50;i++) 
023D6:  CLRF   xF4
023D8:  MOVF   xF4,W
023DA:  SUBLW  31
023DC:  BNC   2496
.................... 	{ 
.................... 		delay_ms(20); 
023DE:  MOVLW  14
023E0:  MOVWF  xFC
023E2:  MOVLB  0
023E4:  CALL   0BF4
.................... 		i2c_start(); 
023E8:  MOVLB  E
023EA:  BSF    xFE.0
023EC:  BTFSC  xFE.0
023EE:  BRA    23EC
.................... 		ACK = i2c_write(USB_I2C_ADDR);     // Device address 
023F0:  MOVLW  52
023F2:  MOVLB  2
023F4:  MOVWF  xF9
023F6:  MOVLB  0
023F8:  RCALL  22E8
023FA:  MOVFF  01,2F5
.................... 		if(ACK != 0) {i2c_stop(); return 0;} 
023FE:  MOVLB  2
02400:  MOVF   xF5,F
02402:  BZ    2414
02404:  MOVLB  E
02406:  BSF    xFE.2
02408:  BTFSC  xFE.2
0240A:  BRA    2408
0240C:  MOVLW  00
0240E:  MOVWF  01
02410:  BRA    249C
02412:  MOVLB  2
.................... 		ACK = i2c_write(I2C_FLASH_READY); 
02414:  MOVLW  63
02416:  MOVWF  xF9
02418:  MOVLB  0
0241A:  RCALL  22E8
0241C:  MOVFF  01,2F5
.................... 		if(ACK != 0) {i2c_stop(); return 0;} 
02420:  MOVLB  2
02422:  MOVF   xF5,F
02424:  BZ    2436
02426:  MOVLB  E
02428:  BSF    xFE.2
0242A:  BTFSC  xFE.2
0242C:  BRA    242A
0242E:  MOVLW  00
02430:  MOVWF  01
02432:  BRA    249C
02434:  MOVLB  2
.................... 		i2c_start(); 
02436:  MOVLB  E
02438:  BSF    xFE.0
0243A:  BTFSC  xFE.0
0243C:  BRA    243A
.................... 		ACK = i2c_write(USB_I2C_ADDR | BIT0);     // Device address 
0243E:  MOVLW  53
02440:  MOVLB  2
02442:  MOVWF  xF9
02444:  MOVLB  0
02446:  RCALL  22E8
02448:  MOVFF  01,2F5
.................... 		if(ACK != 0) {i2c_stop(); return 0;} 
0244C:  MOVLB  2
0244E:  MOVF   xF5,F
02450:  BZ    2462
02452:  MOVLB  E
02454:  BSF    xFE.2
02456:  BTFSC  xFE.2
02458:  BRA    2456
0245A:  MOVLW  00
0245C:  MOVWF  01
0245E:  BRA    249C
02460:  MOVLB  2
.................... 		ready_F = i2c_read(0); 
02462:  CLRF   00
02464:  MOVLB  0
02466:  BRA    23B0
02468:  MOVFF  01,2F6
.................... 		if(ACK != 0) {i2c_stop(); return 0;} 
0246C:  MOVLB  2
0246E:  MOVF   xF5,F
02470:  BZ    2482
02472:  MOVLB  E
02474:  BSF    xFE.2
02476:  BTFSC  xFE.2
02478:  BRA    2476
0247A:  MOVLW  00
0247C:  MOVWF  01
0247E:  BRA    249C
02480:  MOVLB  2
.................... 		i2c_stop(); 
02482:  MOVLB  E
02484:  BSF    xFE.2
02486:  BTFSC  xFE.2
02488:  BRA    2486
.................... 		if(ready_F == 1) break; 
0248A:  MOVLB  2
0248C:  DECFSZ xF6,W
0248E:  BRA    2492
02490:  BRA    2496
02492:  INCF   xF4,F
02494:  BRA    23D8
.................... 	} 
.................... 	return ready_F; 
02496:  MOVFF  2F6,01
0249A:  MOVLB  E
0249C:  MOVLB  0
0249E:  RETURN 0
.................... } 
....................  
.................... //converts int16 number in 0 to 999. Also removes leading zeros, 
.................... //add text "0" to the numbers. There is no NULL char at the end. 
.................... void convert_to_3digits (int16 INPUT, char *pOUTPUT) 
*
02AC4:  MOVLB  2
02AC6:  CLRF   x54
.................... { 
.................... 	int8 zero_flag = 0; 
.................... 	 
.................... 	if(INPUT > 999) INPUT = 999; 
02AC8:  MOVF   x51,W
02ACA:  SUBLW  02
02ACC:  BC    2AE0
02ACE:  XORLW  FF
02AD0:  BNZ   2AD8
02AD2:  MOVF   x50,W
02AD4:  SUBLW  E7
02AD6:  BC    2AE0
02AD8:  MOVLW  03
02ADA:  MOVWF  x51
02ADC:  MOVLW  E7
02ADE:  MOVWF  x50
.................... 	*pOUTPUT = '0'; 
02AE0:  MOVFF  253,03
02AE4:  MOVFF  252,FE9
02AE8:  MOVFF  03,FEA
02AEC:  MOVLW  30
02AEE:  MOVWF  FEF
.................... 	if(INPUT > 99) 
02AF0:  MOVF   x51,F
02AF2:  BNZ   2AFA
02AF4:  MOVF   x50,W
02AF6:  SUBLW  63
02AF8:  BC    2B22
.................... 	{ 
.................... 		zero_flag = 1;	 
02AFA:  MOVLW  01
02AFC:  MOVWF  x54
.................... 		while(INPUT >= 100) 
02AFE:  MOVF   x51,F
02B00:  BNZ   2B08
02B02:  MOVF   x50,W
02B04:  SUBLW  63
02B06:  BC    2B20
.................... 		{ 
.................... 			(*pOUTPUT)++; 
02B08:  MOVFF  253,03
02B0C:  MOVFF  252,FE9
02B10:  MOVFF  03,FEA
02B14:  INCF   FEF,F
.................... 			INPUT = INPUT - 100; 
02B16:  MOVLW  64
02B18:  SUBWF  x50,F
02B1A:  MOVLW  00
02B1C:  SUBWFB x51,F
02B1E:  BRA    2AFE
.................... 		} 
.................... 	} 
02B20:  BRA    2B32
.................... 	else 
.................... 	{ 
.................... 		*pOUTPUT = ' '; 
02B22:  MOVFF  253,03
02B26:  MOVFF  252,FE9
02B2A:  MOVFF  03,FEA
02B2E:  MOVLW  20
02B30:  MOVWF  FEF
.................... 	} 
....................  
.................... 	pOUTPUT++; 
02B32:  INCF   x52,F
02B34:  BTFSC  FD8.2
02B36:  INCF   x53,F
....................  
.................... 	*pOUTPUT = '0'; 
02B38:  MOVFF  253,03
02B3C:  MOVFF  252,FE9
02B40:  MOVFF  03,FEA
02B44:  MOVLW  30
02B46:  MOVWF  FEF
.................... 	if(INPUT > 9) 
02B48:  MOVF   x51,F
02B4A:  BNZ   2B52
02B4C:  MOVF   x50,W
02B4E:  SUBLW  09
02B50:  BC    2B78
.................... 	{ 
.................... 		zero_flag = 1;	 
02B52:  MOVLW  01
02B54:  MOVWF  x54
.................... 		while(INPUT >= 10) 
02B56:  MOVF   x51,F
02B58:  BNZ   2B60
02B5A:  MOVF   x50,W
02B5C:  SUBLW  09
02B5E:  BC    2B78
.................... 		{ 
.................... 			(*pOUTPUT)++; 
02B60:  MOVFF  253,03
02B64:  MOVFF  252,FE9
02B68:  MOVFF  03,FEA
02B6C:  INCF   FEF,F
.................... 			INPUT = INPUT - 10; 
02B6E:  MOVLW  0A
02B70:  SUBWF  x50,F
02B72:  MOVLW  00
02B74:  SUBWFB x51,F
02B76:  BRA    2B56
.................... 		} 
.................... 	} 
.................... 	if(zero_flag != 1) 
02B78:  DECFSZ x54,W
02B7A:  BRA    2B7E
02B7C:  BRA    2B8E
.................... 	{	 
.................... 		*pOUTPUT = ' '; 
02B7E:  MOVFF  253,03
02B82:  MOVFF  252,FE9
02B86:  MOVFF  03,FEA
02B8A:  MOVLW  20
02B8C:  MOVWF  FEF
.................... 	} 
....................  
.................... 	pOUTPUT++; 
02B8E:  INCF   x52,F
02B90:  BTFSC  FD8.2
02B92:  INCF   x53,F
.................... 	*pOUTPUT = INPUT + '0'; 
02B94:  MOVFF  253,03
02B98:  MOVFF  252,FE9
02B9C:  MOVFF  03,FEA
02BA0:  MOVLW  30
02BA2:  ADDWF  x50,W
02BA4:  MOVWF  FEF
02BA6:  MOVLB  0
02BA8:  GOTO   452C (RETURN)
.................... } 
....................  
.................... int1 check_USB_TO (void) 
02BAC:  MOVLB  2
02BAE:  BCF    x50.0
.................... {	//uses RTC to determine when the USB data needs to be updated 
.................... 	//This is a fixed time only adjustable in this routine. 
.................... 	//the calling function sets target to RESET_TO to reset the count 
....................  
.................... 	extern int8 target_USB; 
.................... 	static int8 seconds; 
.................... 	int1 RV = 0; 
.................... 	 
.................... 	RTC_CE = 1; 
02BB0:  BSF    F82.3
.................... 	SPI_SCK = 0; 
02BB2:  BCF    F82.2
.................... 	RTC_CE = 1; 
02BB4:  BSF    F82.3
.................... 	SEND_SPI(read_time_date); 
02BB6:  MOVLW  88
02BB8:  MOVWF  xF6
02BBA:  MOVLB  0
02BBC:  CALL   0D42
.................... 	seconds = SEND_SPI(0); 
02BC0:  MOVLB  2
02BC2:  CLRF   xF6
02BC4:  MOVLB  0
02BC6:  CALL   0D42
02BCA:  MOVFF  01,15C
.................... 	RTC_CE = 0; 
02BCE:  BCF    F82.3
.................... 	seconds = convert_BCD_to_No(seconds,7); 
02BD0:  MOVFF  15C,2F5
02BD4:  MOVLW  07
02BD6:  MOVLB  2
02BD8:  MOVWF  xF6
02BDA:  MOVLB  0
02BDC:  CALL   0D7E
02BE0:  MOVFF  01,15C
.................... 	if(target_USB  == RESET_TO) 
02BE4:  INCFSZ xA4,W
02BE6:  BRA    2C0A
.................... 	{	//first time in loop so set up Target time 
.................... 		if(seconds >= 30) {target_USB = seconds-30;} else {target_USB = seconds + 30;} 
02BE8:  MOVLB  1
02BEA:  MOVF   x5C,W
02BEC:  SUBLW  1D
02BEE:  BC    2BFC
02BF0:  MOVLW  1E
02BF2:  SUBWF  x5C,W
02BF4:  MOVLB  0
02BF6:  MOVWF  xA4
02BF8:  BRA    2C04
02BFA:  MOVLB  1
02BFC:  MOVLW  1E
02BFE:  ADDWF  x5C,W
02C00:  MOVLB  0
02C02:  MOVWF  xA4
.................... 		RV = 0;		//no update yet 
02C04:  MOVLB  2
02C06:  BCF    x50.0
02C08:  MOVLB  0
.................... 	} 
.................... 	if(seconds == target_USB) 
02C0A:  MOVF   xA4,W
02C0C:  MOVLB  1
02C0E:  SUBWF  x5C,W
02C10:  BNZ   2C32
.................... 	{	//target reached, set new target 
.................... 		if(seconds >= 30) {target_USB = seconds-30;} else {target_USB = seconds + 30;} 
02C12:  MOVF   x5C,W
02C14:  SUBLW  1D
02C16:  BC    2C24
02C18:  MOVLW  1E
02C1A:  SUBWF  x5C,W
02C1C:  MOVLB  0
02C1E:  MOVWF  xA4
02C20:  BRA    2C2C
02C22:  MOVLB  1
02C24:  MOVLW  1E
02C26:  ADDWF  x5C,W
02C28:  MOVLB  0
02C2A:  MOVWF  xA4
.................... 		RV = 1; 
02C2C:  MOVLB  2
02C2E:  BSF    x50.0
02C30:  MOVLB  1
.................... 	} 
.................... 	return RV; 
02C32:  MOVLW  00
02C34:  MOVLB  2
02C36:  BTFSC  x50.0
02C38:  MOVLW  01
02C3A:  MOVWF  01
02C3C:  MOVLB  0
02C3E:  GOTO   4C7A (RETURN)
.................... } 
....................  
.................... int1 check_menu_TO (void) 
*
00DD4:  MOVLB  2
00DD6:  BCF    x6B.0
.................... {	//uses RTC to determine when the menu has timed out to be updated 
.................... 	//This is a fixed time only adjustable in this routine. 
.................... 	//the calling function sets target to RESET_TO to reset the count 
....................  
.................... 	extern int8 target_MENU; 
.................... 	int8 seconds; 
.................... 	int1 RV = 0; 
....................  
.................... 	RTC_CE = 1; 
00DD8:  BSF    F82.3
.................... 	SPI_SCK = 0; 
00DDA:  BCF    F82.2
.................... 	RTC_CE = 1; 
00DDC:  BSF    F82.3
.................... 	SEND_SPI(read_time_date); 
00DDE:  MOVLW  88
00DE0:  MOVWF  xF6
00DE2:  MOVLB  0
00DE4:  RCALL  0D42
.................... 	seconds = SEND_SPI(0); 
00DE6:  MOVLB  2
00DE8:  CLRF   xF6
00DEA:  MOVLB  0
00DEC:  RCALL  0D42
00DEE:  MOVFF  01,26A
.................... 	RTC_CE = 0; 
00DF2:  BCF    F82.3
.................... 	seconds = convert_BCD_to_No(seconds,7); 
00DF4:  MOVFF  26A,2F5
00DF8:  MOVLW  07
00DFA:  MOVLB  2
00DFC:  MOVWF  xF6
00DFE:  MOVLB  0
00E00:  RCALL  0D7E
00E02:  MOVFF  01,26A
....................  
.................... 	if(target_MENU  == RESET_TO) 
00E06:  INCFSZ xA5,W
00E08:  BRA    0E2C
.................... 	{ 
.................... 		if(seconds >= 45) {target_MENU = seconds-45;} else {target_MENU = seconds + 15;} 
00E0A:  MOVLB  2
00E0C:  MOVF   x6A,W
00E0E:  SUBLW  2C
00E10:  BC    0E1E
00E12:  MOVLW  2D
00E14:  SUBWF  x6A,W
00E16:  MOVLB  0
00E18:  MOVWF  xA5
00E1A:  BRA    0E26
00E1C:  MOVLB  2
00E1E:  MOVLW  0F
00E20:  ADDWF  x6A,W
00E22:  MOVLB  0
00E24:  MOVWF  xA5
.................... 		RV =  0;		//no update yet 
00E26:  MOVLB  2
00E28:  BCF    x6B.0
00E2A:  MOVLB  0
.................... 	} 
.................... 	if(seconds == target_MENU) 
00E2C:  MOVF   xA5,W
00E2E:  MOVLB  2
00E30:  SUBWF  x6A,W
00E32:  BNZ   0E52
.................... 	{	//target reached, set new target 
.................... 		if(seconds >= 45) {target_MENU = seconds-45;} else {target_MENU = seconds + 15;} 
00E34:  MOVF   x6A,W
00E36:  SUBLW  2C
00E38:  BC    0E46
00E3A:  MOVLW  2D
00E3C:  SUBWF  x6A,W
00E3E:  MOVLB  0
00E40:  MOVWF  xA5
00E42:  BRA    0E4E
00E44:  MOVLB  2
00E46:  MOVLW  0F
00E48:  ADDWF  x6A,W
00E4A:  MOVLB  0
00E4C:  MOVWF  xA5
.................... 		RV = 1; 
00E4E:  MOVLB  2
00E50:  BSF    x6B.0
.................... 	} 
.................... 	return RV; 
00E52:  MOVLW  00
00E54:  BTFSC  x6B.0
00E56:  MOVLW  01
00E58:  MOVWF  01
00E5A:  MOVLB  0
00E5C:  RETURN 0
.................... } 
....................  
....................  
.................... int32 Convert_To_UNIX_TIME (void) 
.................... { 
.................... 	extern struct TIME TIME_STAMP; 
.................... 	extern struct TIME *pTIME_STAMP; 
.................... 	int32 UNIX_TIME,DELTAyears; 
.................... 	long GP_long; 
.................... 	const long TAB_days[] = {0,31,59,90,120,151,181,212,243,273,304,334}; 
....................  
....................  
.................... 	read_RTC (); 
*
0398A:  CALL   196C
.................... 	pTIME_STAMP = &TIME_STAMP; 
0398E:  CLRF   23
03990:  MOVLW  1C
03992:  MOVWF  22
.................... 	//first convert the time from BCD, and then muliply by constant 
....................  
.................... 	//seconds so far for seconds gone 
.................... 	UNIX_TIME = (int32)(pTIME_STAMP->sec & 0x0F) + (int32)(10*((pTIME_STAMP->sec >> 4) & 0x0F)); 
03994:  MOVFF  22,FE9
03998:  MOVFF  23,FEA
0399C:  MOVF   FEF,W
0399E:  ANDLW  0F
039A0:  MOVLB  2
039A2:  CLRF   xE1
039A4:  CLRF   xE0
039A6:  CLRF   xDF
039A8:  MOVWF  xDE
039AA:  MOVFF  22,FE9
039AE:  MOVFF  23,FEA
039B2:  MOVFF  FEF,2E2
039B6:  SWAPF  xE2,W
039B8:  MOVWF  00
039BA:  MOVLW  0F
039BC:  ANDWF  00,F
039BE:  MOVF   00,W
039C0:  ANDLW  0F
039C2:  MULLW  0A
039C4:  MOVFF  FF3,00
039C8:  CLRF   01
039CA:  CLRF   02
039CC:  CLRF   03
039CE:  MOVF   00,W
039D0:  ADDWF  xDE,W
039D2:  MOVWF  xD4
039D4:  MOVF   01,W
039D6:  ADDWFC xDF,W
039D8:  MOVWF  xD5
039DA:  MOVF   02,W
039DC:  ADDWFC xE0,W
039DE:  MOVWF  xD6
039E0:  MOVF   03,W
039E2:  ADDWFC xE1,W
039E4:  MOVWF  xD7
.................... 	//seconds so far for minutes gone 
.................... 	UNIX_TIME += 60*((int32)(pTIME_STAMP->min & 0x0F) + (int32)(10*((pTIME_STAMP->min >> 4) & 0x0F))); 
039E6:  MOVLW  01
039E8:  ADDWF  22,W
039EA:  MOVWF  FE9
039EC:  MOVLW  00
039EE:  ADDWFC 23,W
039F0:  MOVWF  FEA
039F2:  MOVF   FEF,W
039F4:  ANDLW  0F
039F6:  CLRF   xE1
039F8:  CLRF   xE0
039FA:  CLRF   xDF
039FC:  MOVWF  xDE
039FE:  MOVLW  01
03A00:  ADDWF  22,W
03A02:  MOVWF  FE9
03A04:  MOVLW  00
03A06:  ADDWFC 23,W
03A08:  MOVWF  FEA
03A0A:  MOVFF  FEF,2E2
03A0E:  SWAPF  xE2,W
03A10:  MOVWF  00
03A12:  MOVLW  0F
03A14:  ANDWF  00,F
03A16:  MOVF   00,W
03A18:  ANDLW  0F
03A1A:  MULLW  0A
03A1C:  MOVFF  FF3,00
03A20:  CLRF   01
03A22:  CLRF   02
03A24:  CLRF   03
03A26:  MOVF   xDE,W
03A28:  ADDWF  00,F
03A2A:  MOVF   xDF,W
03A2C:  ADDWFC 01,F
03A2E:  MOVF   xE0,W
03A30:  ADDWFC 02,F
03A32:  MOVF   xE1,W
03A34:  ADDWFC 03,F
03A36:  MOVFF  03,2E1
03A3A:  MOVFF  02,2E0
03A3E:  MOVFF  01,2DF
03A42:  MOVFF  00,2DE
03A46:  MOVFF  FEA,2E5
03A4A:  MOVFF  FE9,2E4
03A4E:  CLRF   xF1
03A50:  CLRF   xF0
03A52:  CLRF   xEF
03A54:  MOVLW  3C
03A56:  MOVWF  xEE
03A58:  MOVFF  03,2F5
03A5C:  MOVFF  02,2F4
03A60:  MOVFF  01,2F3
03A64:  MOVFF  00,2F2
03A68:  MOVLB  0
03A6A:  CALL   29D2
03A6E:  MOVFF  2E5,FEA
03A72:  MOVFF  2E4,FE9
03A76:  MOVF   00,W
03A78:  MOVLB  2
03A7A:  ADDWF  xD4,F
03A7C:  MOVF   01,W
03A7E:  ADDWFC xD5,F
03A80:  MOVF   02,W
03A82:  ADDWFC xD6,F
03A84:  MOVF   03,W
03A86:  ADDWFC xD7,F
.................... 	//seconds so far for hours gone 
.................... 	UNIX_TIME += 3600*((int32)(pTIME_STAMP->hour & 0x0F) + (int32)(10*((pTIME_STAMP->hour >> 4) & 0x0F))); 
03A88:  MOVLW  02
03A8A:  ADDWF  22,W
03A8C:  MOVWF  FE9
03A8E:  MOVLW  00
03A90:  ADDWFC 23,W
03A92:  MOVWF  FEA
03A94:  MOVF   FEF,W
03A96:  ANDLW  0F
03A98:  CLRF   xE1
03A9A:  CLRF   xE0
03A9C:  CLRF   xDF
03A9E:  MOVWF  xDE
03AA0:  MOVLW  02
03AA2:  ADDWF  22,W
03AA4:  MOVWF  FE9
03AA6:  MOVLW  00
03AA8:  ADDWFC 23,W
03AAA:  MOVWF  FEA
03AAC:  MOVFF  FEF,2E2
03AB0:  SWAPF  xE2,W
03AB2:  MOVWF  00
03AB4:  MOVLW  0F
03AB6:  ANDWF  00,F
03AB8:  MOVF   00,W
03ABA:  ANDLW  0F
03ABC:  MULLW  0A
03ABE:  MOVFF  FF3,00
03AC2:  CLRF   01
03AC4:  CLRF   02
03AC6:  CLRF   03
03AC8:  MOVF   xDE,W
03ACA:  ADDWF  00,F
03ACC:  MOVF   xDF,W
03ACE:  ADDWFC 01,F
03AD0:  MOVF   xE0,W
03AD2:  ADDWFC 02,F
03AD4:  MOVF   xE1,W
03AD6:  ADDWFC 03,F
03AD8:  MOVFF  03,2E1
03ADC:  MOVFF  02,2E0
03AE0:  MOVFF  01,2DF
03AE4:  MOVFF  00,2DE
03AE8:  MOVFF  FEA,2E5
03AEC:  MOVFF  FE9,2E4
03AF0:  CLRF   xF1
03AF2:  CLRF   xF0
03AF4:  MOVLW  0E
03AF6:  MOVWF  xEF
03AF8:  MOVLW  10
03AFA:  MOVWF  xEE
03AFC:  MOVFF  03,2F5
03B00:  MOVFF  02,2F4
03B04:  MOVFF  01,2F3
03B08:  MOVFF  00,2F2
03B0C:  MOVLB  0
03B0E:  CALL   29D2
03B12:  MOVFF  2E5,FEA
03B16:  MOVFF  2E4,FE9
03B1A:  MOVF   00,W
03B1C:  MOVLB  2
03B1E:  ADDWF  xD4,F
03B20:  MOVF   01,W
03B22:  ADDWFC xD5,F
03B24:  MOVF   02,W
03B26:  ADDWFC xD6,F
03B28:  MOVF   03,W
03B2A:  ADDWFC xD7,F
.................... 	//seconds so far for days gone (in the month) 
.................... 	UNIX_TIME += 86400*(((int32)(pTIME_STAMP->day & 0x0F) + (int32)(10*((pTIME_STAMP->day >> 4) & 0x0F))) - 1); 
03B2C:  MOVLW  03
03B2E:  ADDWF  22,W
03B30:  MOVWF  FE9
03B32:  MOVLW  00
03B34:  ADDWFC 23,W
03B36:  MOVWF  FEA
03B38:  MOVF   FEF,W
03B3A:  ANDLW  0F
03B3C:  CLRF   xE1
03B3E:  CLRF   xE0
03B40:  CLRF   xDF
03B42:  MOVWF  xDE
03B44:  MOVLW  03
03B46:  ADDWF  22,W
03B48:  MOVWF  FE9
03B4A:  MOVLW  00
03B4C:  ADDWFC 23,W
03B4E:  MOVWF  FEA
03B50:  MOVFF  FEF,2E2
03B54:  SWAPF  xE2,W
03B56:  MOVWF  00
03B58:  MOVLW  0F
03B5A:  ANDWF  00,F
03B5C:  MOVF   00,W
03B5E:  ANDLW  0F
03B60:  MULLW  0A
03B62:  MOVFF  FF3,00
03B66:  CLRF   01
03B68:  CLRF   02
03B6A:  CLRF   03
03B6C:  MOVF   00,W
03B6E:  ADDWF  xDE,F
03B70:  MOVF   01,W
03B72:  ADDWFC xDF,F
03B74:  MOVF   02,W
03B76:  ADDWFC xE0,F
03B78:  MOVF   03,W
03B7A:  ADDWFC xE1,F
03B7C:  MOVLW  01
03B7E:  SUBWF  xDE,W
03B80:  MOVWF  00
03B82:  MOVLW  00
03B84:  SUBWFB xDF,W
03B86:  MOVWF  01
03B88:  MOVLW  00
03B8A:  SUBWFB xE0,W
03B8C:  MOVWF  02
03B8E:  MOVLW  00
03B90:  SUBWFB xE1,W
03B92:  MOVWF  03
03B94:  MOVWF  xE1
03B96:  MOVFF  02,2E0
03B9A:  MOVFF  01,2DF
03B9E:  MOVFF  00,2DE
03BA2:  MOVFF  FEA,2E5
03BA6:  MOVFF  FE9,2E4
03BAA:  CLRF   xF1
03BAC:  MOVLW  01
03BAE:  MOVWF  xF0
03BB0:  MOVLW  51
03BB2:  MOVWF  xEF
03BB4:  MOVLW  80
03BB6:  MOVWF  xEE
03BB8:  MOVFF  03,2F5
03BBC:  MOVFF  02,2F4
03BC0:  MOVFF  01,2F3
03BC4:  MOVFF  00,2F2
03BC8:  MOVLB  0
03BCA:  CALL   29D2
03BCE:  MOVFF  2E5,FEA
03BD2:  MOVFF  2E4,FE9
03BD6:  MOVF   00,W
03BD8:  MOVLB  2
03BDA:  ADDWF  xD4,F
03BDC:  MOVF   01,W
03BDE:  ADDWFC xD5,F
03BE0:  MOVF   02,W
03BE2:  ADDWFC xD6,F
03BE4:  MOVF   03,W
03BE6:  ADDWFC xD7,F
.................... 	//so far OK, but now months have different number of days.. as below 
.................... 	// 31, 28*,31,30,31,30,31,31,30,31,30,31. * ignore leap years for now, we will correct this later. 
.................... 	GP_long = (pTIME_STAMP->month & 0x0F) + (10*(pTIME_STAMP->month >> 4) & 0x0F) - 1; 
03BE8:  MOVLW  04
03BEA:  ADDWF  22,W
03BEC:  MOVWF  FE9
03BEE:  MOVLW  00
03BF0:  ADDWFC 23,W
03BF2:  MOVWF  FEA
03BF4:  MOVF   FEF,W
03BF6:  ANDLW  0F
03BF8:  MOVWF  xDE
03BFA:  MOVLW  04
03BFC:  ADDWF  22,W
03BFE:  MOVWF  FE9
03C00:  MOVLW  00
03C02:  ADDWFC 23,W
03C04:  MOVWF  FEA
03C06:  SWAPF  FEF,W
03C08:  MOVWF  00
03C0A:  MOVLW  0F
03C0C:  ANDWF  00,F
03C0E:  MOVF   00,W
03C10:  MULLW  0A
03C12:  MOVF   FF3,W
03C14:  ANDLW  0F
03C16:  ADDWF  xDE,W
03C18:  ADDLW  FF
03C1A:  MOVWF  xDC
03C1C:  CLRF   xDD
.................... 	GP_long = TAB_days[GP_long]; 	 
03C1E:  BCF    FD8.0
03C20:  RLCF   xDC,W
03C22:  MOVWF  02
03C24:  RLCF   xDD,W
03C26:  MOVWF  03
03C28:  MOVF   02,W
03C2A:  MOVLB  0
03C2C:  CALL   02D8
03C30:  TBLRD*+
03C32:  MOVFF  FF5,03
03C36:  MOVLB  2
03C38:  MOVWF  xDC
03C3A:  MOVFF  03,2DD
.................... 	UNIX_TIME += 86400*(int32)GP_long; 
03C3E:  MOVFF  2DC,00
03C42:  MOVFF  2DD,01
03C46:  CLRF   02
03C48:  CLRF   03
03C4A:  MOVFF  03,2E1
03C4E:  MOVFF  02,2E0
03C52:  MOVFF  01,2DF
03C56:  MOVFF  00,2DE
03C5A:  CLRF   xF1
03C5C:  MOVLW  01
03C5E:  MOVWF  xF0
03C60:  MOVLW  51
03C62:  MOVWF  xEF
03C64:  MOVLW  80
03C66:  MOVWF  xEE
03C68:  MOVFF  03,2F5
03C6C:  MOVFF  02,2F4
03C70:  MOVFF  01,2F3
03C74:  MOVFF  00,2F2
03C78:  MOVLB  0
03C7A:  CALL   29D2
03C7E:  MOVF   00,W
03C80:  MOVLB  2
03C82:  ADDWF  xD4,F
03C84:  MOVF   01,W
03C86:  ADDWFC xD5,F
03C88:  MOVF   02,W
03C8A:  ADDWFC xD6,F
03C8C:  MOVF   03,W
03C8E:  ADDWFC xD7,F
.................... 	DELTAyears = (int32)(pTIME_STAMP->year & 0x0F) + (int32)(10*((pTIME_STAMP->year >> 4) & 0x0F)) + 30; //(+30 = 2000-1970) 
03C90:  MOVLW  05
03C92:  ADDWF  22,W
03C94:  MOVWF  FE9
03C96:  MOVLW  00
03C98:  ADDWFC 23,W
03C9A:  MOVWF  FEA
03C9C:  MOVF   FEF,W
03C9E:  ANDLW  0F
03CA0:  CLRF   xE1
03CA2:  CLRF   xE0
03CA4:  CLRF   xDF
03CA6:  MOVWF  xDE
03CA8:  MOVLW  05
03CAA:  ADDWF  22,W
03CAC:  MOVWF  FE9
03CAE:  MOVLW  00
03CB0:  ADDWFC 23,W
03CB2:  MOVWF  FEA
03CB4:  MOVFF  FEF,2E2
03CB8:  SWAPF  xE2,W
03CBA:  MOVWF  00
03CBC:  MOVLW  0F
03CBE:  ANDWF  00,F
03CC0:  MOVF   00,W
03CC2:  ANDLW  0F
03CC4:  MULLW  0A
03CC6:  MOVFF  FF3,00
03CCA:  CLRF   01
03CCC:  CLRF   02
03CCE:  CLRF   03
03CD0:  MOVF   00,W
03CD2:  ADDWF  xDE,F
03CD4:  MOVF   01,W
03CD6:  ADDWFC xDF,F
03CD8:  MOVF   02,W
03CDA:  ADDWFC xE0,F
03CDC:  MOVF   03,W
03CDE:  ADDWFC xE1,F
03CE0:  MOVLW  1E
03CE2:  ADDWF  xDE,W
03CE4:  MOVWF  xD8
03CE6:  MOVLW  00
03CE8:  ADDWFC xDF,W
03CEA:  MOVWF  xD9
03CEC:  MOVLW  00
03CEE:  ADDWFC xE0,W
03CF0:  MOVWF  xDA
03CF2:  MOVLW  00
03CF4:  ADDWFC xE1,W
03CF6:  MOVWF  xDB
.................... 	UNIX_TIME += 31536000*DELTAyears; 
03CF8:  MOVLW  01
03CFA:  MOVWF  xF1
03CFC:  MOVLW  E1
03CFE:  MOVWF  xF0
03D00:  MOVLW  33
03D02:  MOVWF  xEF
03D04:  MOVLW  80
03D06:  MOVWF  xEE
03D08:  MOVFF  2DB,2F5
03D0C:  MOVFF  2DA,2F4
03D10:  MOVFF  2D9,2F3
03D14:  MOVFF  2D8,2F2
03D18:  MOVLB  0
03D1A:  CALL   29D2
03D1E:  MOVF   00,W
03D20:  MOVLB  2
03D22:  ADDWF  xD4,F
03D24:  MOVF   01,W
03D26:  ADDWFC xD5,F
03D28:  MOVF   02,W
03D2A:  ADDWFC xD6,F
03D2C:  MOVF   03,W
03D2E:  ADDWFC xD7,F
.................... 	//now compensate for for the number of leap years since 2016, we know there has been 12 already. 
.................... 	GP_long = (pTIME_STAMP->year & 0x0F) + (10*(pTIME_STAMP->year >> 4)) - 16; 
03D30:  MOVLW  05
03D32:  ADDWF  22,W
03D34:  MOVWF  FE9
03D36:  MOVLW  00
03D38:  ADDWFC 23,W
03D3A:  MOVWF  FEA
03D3C:  MOVF   FEF,W
03D3E:  ANDLW  0F
03D40:  MOVWF  xDE
03D42:  MOVLW  05
03D44:  ADDWF  22,W
03D46:  MOVWF  FE9
03D48:  MOVLW  00
03D4A:  ADDWFC 23,W
03D4C:  MOVWF  FEA
03D4E:  SWAPF  FEF,W
03D50:  MOVWF  00
03D52:  MOVLW  0F
03D54:  ANDWF  00,F
03D56:  MOVF   00,W
03D58:  MULLW  0A
03D5A:  MOVF   FF3,W
03D5C:  ADDWF  xDE,W
03D5E:  ADDLW  F0
03D60:  MOVWF  xDC
03D62:  CLRF   xDD
.................... 	GP_long = GP_long/4; 
03D64:  RRCF   xDD,F
03D66:  RRCF   xDC,F
03D68:  RRCF   xDD,F
03D6A:  RRCF   xDC,F
03D6C:  MOVLW  3F
03D6E:  ANDWF  xDD,F
.................... 	if((pTIME_STAMP->month <= 2) &&  (gp_long != 0)) gp_long = gp_long - 1;	//Feb not happened yet...)  
03D70:  MOVLW  04
03D72:  ADDWF  22,W
03D74:  MOVWF  FE9
03D76:  MOVLW  00
03D78:  ADDWFC 23,W
03D7A:  MOVWF  FEA
03D7C:  MOVF   FEF,W
03D7E:  SUBLW  02
03D80:  BNC   3D92
03D82:  MOVF   xDC,F
03D84:  BNZ   3D8A
03D86:  MOVF   xDD,F
03D88:  BZ    3D92
03D8A:  MOVLW  01
03D8C:  SUBWF  xDC,F
03D8E:  MOVLW  00
03D90:  SUBWFB xDD,F
.................... 	GP_long += 12;	//number of leap years since 1970 and 2016 which had gone when code written) 
03D92:  MOVLW  0C
03D94:  ADDWF  xDC,F
03D96:  MOVLW  00
03D98:  ADDWFC xDD,F
.................... 	UNIX_TIME += (int32)GP_long * 86400; 
03D9A:  CLRF   xE1
03D9C:  CLRF   xE0
03D9E:  MOVFF  2DD,2DF
03DA2:  MOVFF  2DC,2DE
03DA6:  MOVFF  2E1,2F1
03DAA:  MOVFF  2E0,2F0
03DAE:  MOVFF  2DD,2EF
03DB2:  MOVFF  2DC,2EE
03DB6:  CLRF   xF5
03DB8:  MOVLW  01
03DBA:  MOVWF  xF4
03DBC:  MOVLW  51
03DBE:  MOVWF  xF3
03DC0:  MOVLW  80
03DC2:  MOVWF  xF2
03DC4:  MOVLB  0
03DC6:  CALL   29D2
03DCA:  MOVF   00,W
03DCC:  MOVLB  2
03DCE:  ADDWF  xD4,F
03DD0:  MOVF   01,W
03DD2:  ADDWFC xD5,F
03DD4:  MOVF   02,W
03DD6:  ADDWFC xD6,F
03DD8:  MOVF   03,W
03DDA:  ADDWFC xD7,F
....................  
.................... 	return UNIX_TIME; 
03DDC:  MOVFF  2D4,00
03DE0:  MOVFF  2D5,01
03DE4:  MOVFF  2D6,02
03DE8:  MOVFF  2D7,03
03DEC:  MOVLB  0
03DEE:  GOTO   3E2C (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #INCLUDE <LW_Attendant_RS485.c> 
.................... /*************************************************************************************** 
.................... * Name:      LW_Attendant_RS485.c 
.................... *  
.................... * Revision: draft 
.................... * 
.................... * Author:     Phil Hockley 
.................... * 
.................... * Description: 
.................... *          RS485 Functions/Interrupts C file. 
.................... *         Sends a command, and replies with OK=1, bad mesaage = 0; 
.................... * 
.................... *      STX,LEN,ADR,Data_n,BCC 
.................... *      STX = 0x02 
.................... *      LEN = message length of data bytes only 
.................... *      ADR = Address of unit 0-255. Note 0 = general command (i.e. Broadcast mode) 
.................... *      data_n = data bytes of length LEN 
.................... *      BCC = exc or Bit test of LEN + ADR + data 
.................... * 
.................... *      LEN here is always 1 in transmitt (the command) and variable in receive 
.................... *      ADR is 0-10, with 0 as Transmitt broadcast. Data_in does not show the BCC, but it is present 
.................... * 
.................... *      Data_out =    STX,1,ADR,0x1E -> set addr, set the UNIT_ADR as ADR only works if unit adr is 0. 
.................... *      Data_in =    STX,1, UNIT_ADR, 0x1E, BCC    
.................... * 
.................... *      Data_out =    STX,1,ADR,0x4A -> reset UNIT_ADR to 0. This has to be done if ADR is not 0, and you want to change it 
.................... *      Data_in =    STX,1, 0, 0x4A, BCC 
.................... * 
.................... *      Data_out =    0x2D ->   Send Data, send controller data over to the attendant 
.................... *      data_in =    STX,LEN,UNIT_ADR,Unit_Data,BCC. LEN = 20 at the moment. 
.................... * 
.................... * History:    14/04/15   Initial code started 
.................... *         15/03/16   New Comms function 
.................... *          
.................... ****************************************************************************************/ 
....................  
.................... int1 send_RS485 (int8 action, int8 L_ADR) 
*
011EC:  MOVLB  3
011EE:  CLRF   x1A
.................... {    
....................    extern union LOG_UNION DATA_IN[Max_no_LOOS]; 
....................    extern union LOG_UNION *pDATA_IN; 
....................    char message_in[30]; 
....................    char message_out[5]; 
....................    int8 i,BCC = 0,junk; 
....................  
....................    TX_EN = ON; 
011F0:  BSF    FAC.5
....................    DIR1 = DIR_TX; 
011F2:  BSF    F82.0
....................    wait1uS 
011F4:  NOP   
011F6:  NOP   
....................    TX_EN = ON; 
011F8:  BSF    FAC.5
....................    message_out[0] = STX; 
011FA:  MOVLW  02
011FC:  MOVWF  x14
....................    message_out[1] = 1; 
011FE:  MOVLW  01
01200:  MOVWF  x15
....................    message_out[2] = L_ADR; 
01202:  MOVFF  2F5,316
....................    message_out[3] = action; 
01206:  MOVFF  2F4,317
....................    message_out[4] = 0x01 ^ L_ADR ^ action; 
0120A:  MOVLB  2
0120C:  MOVF   xF5,W
0120E:  XORLW  01
01210:  XORWF  xF4,W
01212:  MOVLB  3
01214:  MOVWF  x18
....................    for(i=0;i<5;i++) 
01216:  CLRF   x19
01218:  MOVF   x19,W
0121A:  SUBLW  04
0121C:  BNC   124A
....................    { 
....................       COMMS_OUT = message_out[i]; 
0121E:  CLRF   03
01220:  MOVF   x19,W
01222:  ADDLW  14
01224:  MOVWF  FE9
01226:  MOVLW  03
01228:  ADDWFC 03,W
0122A:  MOVWF  FEA
0122C:  MOVFF  FEF,FAD
....................       while(!TRMT1); 
01230:  BTFSS  FAC.1
01232:  BRA    1230
....................  
....................       delay_us(500); 
01234:  MOVLW  02
01236:  MOVWF  x1C
01238:  MOVLW  F8
0123A:  MOVWF  x97
0123C:  MOVLB  0
0123E:  BRA    11C6
01240:  MOVLB  3
01242:  DECFSZ x1C,F
01244:  BRA    1238
01246:  INCF   x19,F
01248:  BRA    1218
....................    } 
....................    //last byte sent, now wait for return data. Timeout if no data after 30mS. 
....................    TX_EN = OFF; 
0124A:  BCF    FAC.5
....................    DIR1 = DIR_RX; 
0124C:  BCF    F82.0
....................    wait1uS 
0124E:  NOP   
01250:  NOP   
....................    CREN = 0; CREN = 1;   junk = COMMS_IN;junk = COMMS_IN; 
01252:  BCF    FAB.4
01254:  BSF    FAB.4
01256:  MOVFF  FAE,31B
0125A:  MOVFF  FAE,31B
....................    RX_EN = ON; 
0125E:  BSF    FAB.4
....................    RST_GET_DATA_TO 
01260:  CLRF   FCF
01262:  CLRF   FCE
01264:  BCF    F9E.0
....................    START_GET_DATA_TO 
01266:  BSF    FCD.0
....................    if(message_out[3] == SET_ADR || message_out[3] == RST_ADR) 
01268:  MOVF   x17,W
0126A:  SUBLW  1E
0126C:  BZ    1274
0126E:  MOVF   x17,W
01270:  SUBLW  4A
01272:  BNZ   12E8
....................    { 
....................       for(i=0;i<5;i++) 
01274:  CLRF   x19
01276:  MOVF   x19,W
01278:  SUBLW  04
0127A:  BNC   12C2
....................       { 
....................          while(!RC1IF) 
0127C:  BTFSC  F9E.5
0127E:  BRA    1294
....................          { 
....................             if(TMR1IF) 
01280:  BTFSS  F9E.0
01282:  BRA    1292
....................             {   //this is the only way out.... 
....................                STOP_GET_DATA_TO 
01284:  BCF    FCD.0
....................                INIT_USART1(); 
01286:  MOVLB  0
01288:  RCALL  0BC8
....................                return 0; 
0128A:  MOVLW  00
0128C:  MOVWF  01
0128E:  BRA    13E4
01290:  MOVLB  3
....................             } 
01292:  BRA    127C
....................          } 
....................          message_in[i] = COMMS_IN; 
01294:  CLRF   03
01296:  MOVF   x19,W
01298:  ADDLW  F6
0129A:  MOVWF  FE9
0129C:  MOVLW  02
0129E:  ADDWFC 03,W
012A0:  MOVWF  FEA
012A2:  MOVFF  FAE,FEF
....................          if(message_in[0] != STX)  
012A6:  MOVLB  2
012A8:  MOVF   xF6,W
012AA:  SUBLW  02
012AC:  BZ    12BC
....................          { 
....................             STOP_GET_DATA_TO  
012AE:  BCF    FCD.0
....................             INIT_USART1(); 
012B0:  MOVLB  0
012B2:  RCALL  0BC8
....................             return 0; 
012B4:  MOVLW  00
012B6:  MOVWF  01
012B8:  BRA    13E4
012BA:  MOVLB  2
....................          } 
012BC:  MOVLB  3
012BE:  INCF   x19,F
012C0:  BRA    1276
....................       } 
....................       BCC = message_in[1] ^ message_in[2] ^ message_in[3]; 
012C2:  MOVLB  2
012C4:  MOVF   xF7,W
012C6:  XORWF  xF8,W
012C8:  XORWF  xF9,W
012CA:  MOVLB  3
012CC:  MOVWF  x1A
....................       if(BCC != message_in[4]) 
012CE:  MOVLB  2
012D0:  MOVF   xFA,W
012D2:  MOVLB  3
012D4:  SUBWF  x1A,W
012D6:  BZ    12E6
....................       { 
....................          STOP_GET_DATA_TO 
012D8:  BCF    FCD.0
....................          INIT_USART1(); 
012DA:  MOVLB  0
012DC:  RCALL  0BC8
....................          return 0; 
012DE:  MOVLW  00
012E0:  MOVWF  01
012E2:  BRA    13E4
012E4:  MOVLB  3
....................       } 
....................    } 
012E6:  BRA    13DE
....................    else if(message_out[3] == SND_DATA) 
012E8:  MOVF   x17,W
012EA:  SUBLW  2D
012EC:  BTFSS  FD8.2
012EE:  BRA    13DE
....................    { 
....................       i = 0; 
012F0:  CLRF   x19
....................       do  
....................       { 
....................          while(!RC1IF) 
012F2:  BTFSC  F9E.5
012F4:  BRA    1308
....................          { 
....................             if(TMR1IF) 
012F6:  BTFSS  F9E.0
012F8:  BRA    1306
....................             {   //this is the only way out.... 
....................                STOP_GET_DATA_TO 
012FA:  BCF    FCD.0
....................                return 0; 
012FC:  MOVLW  00
012FE:  MOVWF  01
01300:  MOVLB  0
01302:  BRA    13E4
01304:  MOVLB  3
....................             } 
01306:  BRA    12F2
....................          } 
....................          message_in[i] = COMMS_IN; 
01308:  CLRF   03
0130A:  MOVF   x19,W
0130C:  ADDLW  F6
0130E:  MOVWF  FE9
01310:  MOVLW  02
01312:  ADDWFC 03,W
01314:  MOVWF  FEA
01316:  MOVFF  FAE,FEF
....................          RST_GET_DATA_TO 
0131A:  CLRF   FCF
0131C:  CLRF   FCE
0131E:  BCF    F9E.0
....................          if(message_in[0] != STX)  
01320:  MOVLB  2
01322:  MOVF   xF6,W
01324:  SUBLW  02
01326:  BZ    1334
....................          { 
....................             STOP_GET_DATA_TO return 0; 
01328:  BCF    FCD.0
0132A:  MOVLW  00
0132C:  MOVWF  01
0132E:  MOVLB  0
01330:  BRA    13E4
01332:  MOVLB  2
....................          } 
....................          if((i > 0) && (i < ((message_in[LEN_POS]+OVERHEAD)-1))) BCC = BCC ^ message_in[i]; 
01334:  MOVLB  3
01336:  MOVF   x19,F
01338:  BZ    135A
0133A:  MOVLW  04
0133C:  MOVLB  2
0133E:  ADDWF  xF7,W
01340:  ADDLW  FF
01342:  MOVLB  3
01344:  SUBWF  x19,W
01346:  BC    135A
01348:  CLRF   03
0134A:  MOVF   x19,W
0134C:  ADDLW  F6
0134E:  MOVWF  FE9
01350:  MOVLW  02
01352:  ADDWFC 03,W
01354:  MOVWF  FEA
01356:  MOVF   FEF,W
01358:  XORWF  x1A,F
....................          i++; 
0135A:  INCF   x19,F
....................       }while(i < (message_in[LEN_POS]+OVERHEAD)); 
0135C:  MOVLW  04
0135E:  MOVLB  2
01360:  ADDWF  xF7,W
01362:  MOVLB  3
01364:  SUBWF  x19,W
01366:  BNC   12F2
....................           
....................       //delay_us(1000); 
....................       i = COMMS_IN; 
01368:  MOVFF  FAE,319
....................       if(BCC != i) {STOP_GET_DATA_TO INIT_USART1();return 0;} 
0136C:  MOVF   x19,W
0136E:  SUBWF  x1A,W
01370:  BZ    1380
01372:  BCF    FCD.0
01374:  MOVLB  0
01376:  RCALL  0BC8
01378:  MOVLW  00
0137A:  MOVWF  01
0137C:  BRA    13E4
0137E:  MOVLB  3
....................       //everything OK, so load data to correct loo storage area. 
....................       pDATA_IN = &DATA_IN[L_ADR-1]; 
01380:  MOVLW  01
01382:  MOVLB  2
01384:  SUBWF  xF5,W
01386:  MULLW  14
01388:  MOVF   FF3,W
0138A:  CLRF   03
0138C:  ADDLW  24
0138E:  MOVWF  01
01390:  MOVLW  00
01392:  ADDWFC 03,F
01394:  MOVFF  01,9C
01398:  MOVLB  0
0139A:  MOVFF  03,9D
....................       for(i=0;i<UNION_LEN;i++) 
0139E:  MOVLB  3
013A0:  CLRF   x19
013A2:  MOVF   x19,W
013A4:  SUBLW  13
013A6:  BNC   13DE
....................       { 
....................          pDATA_IN->LOG_RXD[i] = message_in[i+4]; 
013A8:  MOVF   x19,W
013AA:  MOVLB  0
013AC:  ADDWF  x9C,W
013AE:  MOVWF  01
013B0:  MOVLW  00
013B2:  ADDWFC x9D,W
013B4:  MOVWF  03
013B6:  MOVLB  3
013B8:  MOVWF  x1D
013BA:  MOVLW  04
013BC:  ADDWF  x19,W
013BE:  CLRF   03
013C0:  ADDLW  F6
013C2:  MOVWF  FE9
013C4:  MOVLW  02
013C6:  ADDWFC 03,W
013C8:  MOVWF  FEA
013CA:  MOVFF  FEF,31E
013CE:  MOVFF  31D,FEA
013D2:  MOVFF  01,FE9
013D6:  MOVFF  31E,FEF
013DA:  INCF   x19,F
013DC:  BRA    13A2
....................       }    
....................    } 
....................    return 1; 
013DE:  MOVLW  01
013E0:  MOVWF  01
013E2:  MOVLB  0
013E4:  RETURN 0
.................... } 
....................  
.................... void send_data_to_WEB(int8 *pFAULTS) 
.................... { 
....................    extern union LOG_UNION DATA_IN[Max_no_LOOS]; 
....................    extern union LOG_UNION *pDATA_IN; 
....................    extern int8 no_of_loos; 
....................    extern char TRAILER_ID;  
....................    long long UNIX_TIME; 
....................    static int8 loo = 0; 
.................... //   int16 bag_len_fitted; 
....................    int8 i,x; 
....................  
....................    UNIX_TIME = Convert_To_UNIX_TIME(); 
*
03E2A:  BRA    398A
03E2C:  MOVFF  03,255
03E30:  MOVFF  02,254
03E34:  MOVFF  01,253
03E38:  MOVFF  00,252
....................  
....................    //Start the transmission 
....................    TXREG2 = STX; 
03E3C:  MOVLW  02
03E3E:  MOVLB  F
03E40:  MOVWF  x1C
....................    delay_ms(1); 
03E42:  MOVLW  01
03E44:  MOVLB  2
03E46:  MOVWF  xFC
03E48:  MOVLB  0
03E4A:  CALL   0BF4
....................    delim_send(TRAILER_ID); 
03E4E:  MOVFF  A6,2D6
03E52:  RCALL  3DF2
....................    delim_send((int8)UNIX_TIME); 
03E54:  MOVFF  252,2D6
03E58:  RCALL  3DF2
....................    delim_send((int8)(UNIX_TIME >> 8)); 
03E5A:  MOVFF  253,00
03E5E:  MOVFF  254,01
03E62:  MOVFF  255,02
03E66:  CLRF   03
03E68:  MOVFF  00,259
03E6C:  MOVFF  00,2D6
03E70:  RCALL  3DF2
....................    delim_send((int8)(UNIX_TIME >> 16)); 
03E72:  MOVFF  254,00
03E76:  MOVFF  255,01
03E7A:  CLRF   02
03E7C:  CLRF   03
03E7E:  MOVFF  00,259
03E82:  MOVFF  00,2D6
03E86:  RCALL  3DF2
....................    delim_send((int8)(UNIX_TIME >> 24)); 
03E88:  MOVFF  255,00
03E8C:  CLRF   01
03E8E:  CLRF   02
03E90:  CLRF   03
03E92:  MOVFF  00,259
03E96:  MOVFF  00,2D6
03E9A:  RCALL  3DF2
....................    delim_send(no_of_loos); 
03E9C:  MOVFF  A7,2D6
03EA0:  RCALL  3DF2
....................    //Now each controller information 
....................     
....................    for(x = 0; x < 6; x++) 
03EA2:  MOVLB  2
03EA4:  CLRF   x57
03EA6:  MOVF   x57,W
03EA8:  SUBLW  05
03EAA:  BNC   3F36
....................    { 
....................       pDATA_IN = &DATA_IN[loo]; 
03EAC:  MOVLB  1
03EAE:  MOVF   x5D,W
03EB0:  MULLW  14
03EB2:  MOVF   FF3,W
03EB4:  CLRF   03
03EB6:  ADDLW  24
03EB8:  MOVWF  01
03EBA:  MOVLW  00
03EBC:  ADDWFC 03,F
03EBE:  MOVFF  01,9C
03EC2:  MOVLB  0
03EC4:  MOVFF  03,9D
.................... //      bag_len_Fitted = pDATA_IN -> LOG_DATA[7] + pDATA_IN -> LOG_DATA[8]; 
....................       delim_send(loo+1);         //loo number being sent 1-6 
03EC8:  MOVLW  01
03ECA:  MOVLB  1
03ECC:  ADDWF  x5D,W
03ECE:  MOVLB  2
03ED0:  MOVWF  x58
03ED2:  MOVWF  xD6
03ED4:  MOVLB  0
03ED6:  RCALL  3DF2
....................       delim_send(pFAULTS[loo+1]); 
03ED8:  MOVLW  01
03EDA:  MOVLB  1
03EDC:  ADDWF  x5D,W
03EDE:  MOVLB  2
03EE0:  ADDWF  x50,W
03EE2:  MOVWF  FE9
03EE4:  MOVLW  00
03EE6:  ADDWFC x51,W
03EE8:  MOVWF  FEA
03EEA:  MOVFF  FEF,2D6
03EEE:  MOVLB  0
03EF0:  RCALL  3DF2
....................       for(i=0;i<UNION_LEN;i++) 
03EF2:  MOVLB  2
03EF4:  CLRF   x56
03EF6:  MOVF   x56,W
03EF8:  SUBLW  13
03EFA:  BNC   3F16
....................       { 
....................          delim_send(pDATA_IN->LOG_RXD[i]);       
03EFC:  MOVF   x56,W
03EFE:  MOVLB  0
03F00:  ADDWF  x9C,W
03F02:  MOVWF  FE9
03F04:  MOVLW  00
03F06:  ADDWFC x9D,W
03F08:  MOVWF  FEA
03F0A:  MOVFF  FEF,2D6
03F0E:  RCALL  3DF2
03F10:  MOVLB  2
03F12:  INCF   x56,F
03F14:  BRA    3EF6
....................       } 
.................... //      delim_send((int8)(bag_len_Fitted)); 
.................... //      delim_send((int8)(bag_len_Fitted >> 8)); 
....................       loo++; 
03F16:  MOVLB  1
03F18:  INCF   x5D,F
....................       if(loo > no_of_loos - 1) {loo = 0;break;} 
03F1A:  MOVLW  01
03F1C:  MOVLB  0
03F1E:  SUBWF  xA7,W
03F20:  MOVLB  1
03F22:  SUBWF  x5D,W
03F24:  BZ    3F30
03F26:  BNC   3F30
03F28:  CLRF   x5D
03F2A:  MOVLB  2
03F2C:  BRA    3F36
03F2E:  MOVLB  1
03F30:  MOVLB  2
03F32:  INCF   x57,F
03F34:  BRA    3EA6
....................    } 
....................    TXREG2 = ETX; 
03F36:  MOVLW  03
03F38:  MOVLB  F
03F3A:  MOVWF  x1C
03F3C:  MOVLB  0
03F3E:  RETURN 0
.................... }    
....................  
.................... void delim_send (int8 data_in) 
.................... { 
....................    if((data_in == STX) || (data_in == ETX) || (data_in == DLE))    
*
03DF2:  MOVLB  2
03DF4:  MOVF   xD6,W
03DF6:  SUBLW  02
03DF8:  BZ    3E06
03DFA:  MOVF   xD6,W
03DFC:  SUBLW  03
03DFE:  BZ    3E06
03E00:  MOVF   xD6,W
03E02:  SUBLW  10
03E04:  BNZ   3E1A
....................    { 
....................       TXREG2 = DLE; 
03E06:  MOVLW  10
03E08:  MOVLB  F
03E0A:  MOVWF  x1C
....................       delay_ms(1); 
03E0C:  MOVLW  01
03E0E:  MOVLB  2
03E10:  MOVWF  xFC
03E12:  MOVLB  0
03E14:  CALL   0BF4
03E18:  MOVLB  2
....................    } 
....................    TXREG2 = data_in; 
03E1A:  MOVFF  2D6,F1C
....................    delay_ms(1); 
03E1E:  MOVLW  01
03E20:  MOVWF  xFC
03E22:  MOVLB  0
03E24:  CALL   0BF4
03E28:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #INCLUDE <LW_Attendant_Menu.c> 
.................... /**************************************************************************** 
.................... * File Name: LooWatt Attendant_Menu 
.................... * Purpose: 
.................... *		MAIN application program.          
.................... * Parameters Passed:  
.................... * Parameters Returned:  
.................... * Globals: 
.................... * Date Started 	28/02/2016	 
.................... * Version		Not released 
.................... ****************************************************************************/   
.................... void display_USB_warning (int8 action) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern char display_ram[6][21]; 
.................... 	static int8 FLSH_STR; 
.................... 	static char disp_ram_str[11]; 
.................... 	char dtext[11]; 
.................... 	int8 i; 
....................  
.................... 	if(action == disp_warning) 
*
02C42:  MOVLB  2
02C44:  DECFSZ x50,W
02C46:  BRA    2CDE
.................... 	{	//back up existing message, and flash regs 
.................... 		FLSH_STR = FLASH_REG[0]; 
02C48:  MOVFF  9E,15E
.................... 		FLASH_REG[0] &= ~BIT0; 
02C4C:  MOVLB  0
02C4E:  BCF    x9E.0
.................... 		dtext = "USB ACTIVE"; 
02C50:  MOVLW  02
02C52:  MOVWF  FEA
02C54:  MOVLW  51
02C56:  MOVWF  FE9
02C58:  MOVLW  00
02C5A:  CALL   0300
02C5E:  TBLRD*-
02C60:  TBLRD*+
02C62:  MOVF   FF5,W
02C64:  MOVWF  FEE
02C66:  IORLW  00
02C68:  BNZ   2C60
.................... 		for(i=0;i<11;i++) 
02C6A:  MOVLB  2
02C6C:  CLRF   x5C
02C6E:  MOVF   x5C,W
02C70:  SUBLW  0A
02C72:  BNC   2CDC
.................... 		{ 
.................... 			disp_ram_str[i] = display_ram[0][(i+line1_flash_A-1)]; 
02C74:  CLRF   03
02C76:  MOVF   x5C,W
02C78:  ADDLW  5F
02C7A:  MOVWF  01
02C7C:  MOVLW  01
02C7E:  ADDWFC 03,F
02C80:  MOVFF  03,25E
02C84:  MOVLW  0A
02C86:  ADDWF  x5C,W
02C88:  ADDLW  FF
02C8A:  CLRF   03
02C8C:  ADDLW  D6
02C8E:  MOVWF  FE9
02C90:  MOVLW  00
02C92:  ADDWFC 03,W
02C94:  MOVWF  FEA
02C96:  MOVFF  FEF,25F
02C9A:  MOVFF  25E,FEA
02C9E:  MOVFF  01,FE9
02CA2:  MOVFF  25F,FEF
.................... 			display_ram[0][(i+line1_flash_A-1)] = dtext[i]; 
02CA6:  MOVLW  0A
02CA8:  ADDWF  x5C,W
02CAA:  ADDLW  FF
02CAC:  CLRF   03
02CAE:  ADDLW  D6
02CB0:  MOVWF  01
02CB2:  MOVLW  00
02CB4:  ADDWFC 03,F
02CB6:  MOVFF  03,25E
02CBA:  CLRF   03
02CBC:  MOVF   x5C,W
02CBE:  ADDLW  51
02CC0:  MOVWF  FE9
02CC2:  MOVLW  02
02CC4:  ADDWFC 03,W
02CC6:  MOVWF  FEA
02CC8:  MOVFF  FEF,25F
02CCC:  MOVFF  25E,FEA
02CD0:  MOVFF  01,FE9
02CD4:  MOVFF  25F,FEF
02CD8:  INCF   x5C,F
02CDA:  BRA    2C6E
.................... 		}	 
.................... 	} 
02CDC:  BRA    2D20
.................... 	else 
.................... 	{ 
.................... 		FLASH_REG[0] = FLSH_STR; 
02CDE:  MOVFF  15E,9E
.................... 		for(i=0;i<11;i++) 
02CE2:  CLRF   x5C
02CE4:  MOVF   x5C,W
02CE6:  SUBLW  0A
02CE8:  BNC   2D20
.................... 		{ 
.................... 			display_ram[0][i+line1_flash_A-1] = disp_ram_str[i]; 
02CEA:  MOVLW  0A
02CEC:  ADDWF  x5C,W
02CEE:  ADDLW  FF
02CF0:  CLRF   03
02CF2:  ADDLW  D6
02CF4:  MOVWF  01
02CF6:  MOVLW  00
02CF8:  ADDWFC 03,F
02CFA:  MOVFF  03,25E
02CFE:  CLRF   03
02D00:  MOVF   x5C,W
02D02:  ADDLW  5F
02D04:  MOVWF  FE9
02D06:  MOVLW  01
02D08:  ADDWFC 03,W
02D0A:  MOVWF  FEA
02D0C:  MOVFF  FEF,25F
02D10:  MOVFF  25E,FEA
02D14:  MOVFF  01,FE9
02D18:  MOVFF  25F,FEF
02D1C:  INCF   x5C,F
02D1E:  BRA    2CE4
.................... 		}	 
.................... 	} 
02D20:  MOVLB  0
02D22:  RETURN 0
.................... } 
....................  
....................  
.................... int1 set_init_mess (void) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 ALARM_FLAG; 
.................... 	extern int8 FLASH_FLAG; 
.................... 	extern int8 target_USB; 
.................... 	char text[21]; 
....................  
.................... 	FLASH_REG[0] = 0; 
*
02088:  CLRF   x9E
.................... 	FLASH_REG[1] = 0; 
0208A:  CLRF   x9F
.................... 	ALARM_FLAG = 0; 
0208C:  CLRF   xA1
.................... 	FLASH_FLAG = 0; 
0208E:  CLRF   xA2
.................... 	target_USB = 0xFF; 
02090:  SETF   xA4
....................  
.................... 	while(NO_USB) 
02092:  BTFSS  F85.1
02094:  BRA    21A4
.................... 	{ 
.................... 		text = "  USB FLASH DRIVE   "; 
02096:  MOVLW  02
02098:  MOVWF  FEA
0209A:  MOVLW  50
0209C:  MOVWF  FE9
0209E:  MOVLW  00
020A0:  CALL   031C
020A4:  TBLRD*-
020A6:  TBLRD*+
020A8:  MOVF   FF5,W
020AA:  MOVWF  FEE
020AC:  IORLW  00
020AE:  BNZ   20A6
.................... 		strcpy(&display_ram[0], &text); 
020B0:  CLRF   FEA
020B2:  MOVLW  D6
020B4:  MOVWF  FE9
020B6:  MOVLW  02
020B8:  MOVWF  FE2
020BA:  MOVLW  50
020BC:  MOVWF  FE1
020BE:  MOVF   FE7,F
020C0:  MOVFF  FE6,FEE
020C4:  BNZ   20BE
.................... 		text = "MISSING - INSERT USB"; 
020C6:  MOVLW  02
020C8:  MOVWF  FEA
020CA:  MOVLW  50
020CC:  MOVWF  FE9
020CE:  MOVLW  00
020D0:  CALL   0342
020D4:  TBLRD*-
020D6:  TBLRD*+
020D8:  MOVF   FF5,W
020DA:  MOVWF  FEE
020DC:  IORLW  00
020DE:  BNZ   20D6
.................... 		strcpy(&display_ram[1] ,&text); 
020E0:  CLRF   FEA
020E2:  MOVLW  EB
020E4:  MOVWF  FE9
020E6:  MOVLW  02
020E8:  MOVWF  FE2
020EA:  MOVLW  50
020EC:  MOVWF  FE1
020EE:  MOVF   FE7,F
020F0:  MOVFF  FE6,FEE
020F4:  BNZ   20EE
.................... 		text = "DEVICE AND PRESS ENT"; 
020F6:  MOVLW  02
020F8:  MOVWF  FEA
020FA:  MOVLW  50
020FC:  MOVWF  FE9
020FE:  MOVLW  00
02100:  CALL   0368
02104:  TBLRD*-
02106:  TBLRD*+
02108:  MOVF   FF5,W
0210A:  MOVWF  FEE
0210C:  IORLW  00
0210E:  BNZ   2106
.................... 		strcpy(&display_ram[2], &text); 
02110:  MOVLW  01
02112:  MOVWF  FEA
02114:  CLRF   FE9
02116:  MOVLW  02
02118:  MOVWF  FE2
0211A:  MOVLW  50
0211C:  MOVWF  FE1
0211E:  MOVF   FE7,F
02120:  MOVFF  FE6,FEE
02124:  BNZ   211E
.................... 		text = "PRESS UP FOR NO USB "; 
02126:  MOVLW  02
02128:  MOVWF  FEA
0212A:  MOVLW  50
0212C:  MOVWF  FE9
0212E:  MOVLW  00
02130:  CALL   038E
02134:  TBLRD*-
02136:  TBLRD*+
02138:  MOVF   FF5,W
0213A:  MOVWF  FEE
0213C:  IORLW  00
0213E:  BNZ   2136
.................... 		strcpy(&display_ram[3], &text); 
02140:  MOVLW  01
02142:  MOVWF  FEA
02144:  MOVLW  15
02146:  MOVWF  FE9
02148:  MOVLW  02
0214A:  MOVWF  FE2
0214C:  MOVLW  50
0214E:  MOVWF  FE1
02150:  MOVF   FE7,F
02152:  MOVFF  FE6,FEE
02156:  BNZ   2150
.................... 		while(!chk_ent()) 
02158:  CALL   0EBA
0215C:  MOVF   01,F
0215E:  BNZ   2184
.................... 		{ 
.................... 			while(tick == 0); 
02160:  MOVF   xA3,F
02162:  BZ    2160
.................... 			tick = 0; 
02164:  CLRF   xA3
.................... 			if(check_menu_TO()) return 0; 
02166:  CALL   0DD4
0216A:  MOVF   01,F
0216C:  BZ    2174
0216E:  MOVLW  00
02170:  MOVWF  01
02172:  BRA    2266
.................... 			if(chk_up()) return 0; 
02174:  CALL   0E5E
02178:  MOVF   01,F
0217A:  BZ    2182
0217C:  MOVLW  00
0217E:  MOVWF  01
02180:  BRA    2266
02182:  BRA    2158
.................... 		} 
.................... 		target_MENU = RESET_TO; 
02184:  SETF   xA5
.................... 		reset_disp_ram(); 
02186:  CALL   1120
.................... 		delay_ms(1000); 
0218A:  MOVLW  04
0218C:  MOVLB  2
0218E:  MOVWF  x65
02190:  MOVLW  FA
02192:  MOVWF  xFC
02194:  MOVLB  0
02196:  CALL   0BF4
0219A:  MOVLB  2
0219C:  DECFSZ x65,F
0219E:  BRA    2190
021A0:  MOVLB  0
021A2:  BRA    2092
.................... 	} 
.................... 	text = "                    "; 
021A4:  MOVLW  02
021A6:  MOVWF  FEA
021A8:  MOVLW  50
021AA:  MOVWF  FE9
021AC:  MOVLW  00
021AE:  CALL   028C
021B2:  TBLRD*-
021B4:  TBLRD*+
021B6:  MOVF   FF5,W
021B8:  MOVWF  FEE
021BA:  IORLW  00
021BC:  BNZ   21B4
.................... 	strcpy(&display_ram[0], &text); 
021BE:  CLRF   FEA
021C0:  MOVLW  D6
021C2:  MOVWF  FE9
021C4:  MOVLW  02
021C6:  MOVWF  FE2
021C8:  MOVLW  50
021CA:  MOVWF  FE1
021CC:  MOVF   FE7,F
021CE:  MOVFF  FE6,FEE
021D2:  BNZ   21CC
.................... 	text = "    INITIALISING    "; 
021D4:  MOVLW  02
021D6:  MOVWF  FEA
021D8:  MOVLW  50
021DA:  MOVWF  FE9
021DC:  MOVLW  00
021DE:  CALL   03B4
021E2:  TBLRD*-
021E4:  TBLRD*+
021E6:  MOVF   FF5,W
021E8:  MOVWF  FEE
021EA:  IORLW  00
021EC:  BNZ   21E4
.................... 	strcpy(&display_ram[1] ,&text); 
021EE:  CLRF   FEA
021F0:  MOVLW  EB
021F2:  MOVWF  FE9
021F4:  MOVLW  02
021F6:  MOVWF  FE2
021F8:  MOVLW  50
021FA:  MOVWF  FE1
021FC:  MOVF   FE7,F
021FE:  MOVFF  FE6,FEE
02202:  BNZ   21FC
.................... 	text = "     USB DEVICE     "; 
02204:  MOVLW  02
02206:  MOVWF  FEA
02208:  MOVLW  50
0220A:  MOVWF  FE9
0220C:  MOVLW  00
0220E:  CALL   03DA
02212:  TBLRD*-
02214:  TBLRD*+
02216:  MOVF   FF5,W
02218:  MOVWF  FEE
0221A:  IORLW  00
0221C:  BNZ   2214
.................... 	strcpy(&display_ram[2], &text); 
0221E:  MOVLW  01
02220:  MOVWF  FEA
02222:  CLRF   FE9
02224:  MOVLW  02
02226:  MOVWF  FE2
02228:  MOVLW  50
0222A:  MOVWF  FE1
0222C:  MOVF   FE7,F
0222E:  MOVFF  FE6,FEE
02232:  BNZ   222C
.................... 	text = "                    "; 
02234:  MOVLW  02
02236:  MOVWF  FEA
02238:  MOVLW  50
0223A:  MOVWF  FE9
0223C:  MOVLW  00
0223E:  CALL   028C
02242:  TBLRD*-
02244:  TBLRD*+
02246:  MOVF   FF5,W
02248:  MOVWF  FEE
0224A:  IORLW  00
0224C:  BNZ   2244
.................... 	strcpy(&display_ram[3], &text); 
0224E:  MOVLW  01
02250:  MOVWF  FEA
02252:  MOVLW  15
02254:  MOVWF  FE9
02256:  MOVLW  02
02258:  MOVWF  FE2
0225A:  MOVLW  50
0225C:  MOVWF  FE1
0225E:  MOVF   FE7,F
02260:  MOVFF  FE6,FEE
02264:  BNZ   225E
02266:  GOTO   4008 (RETURN)
.................... } 
....................  
....................  
.................... void set_top_menu (void) 
.................... { 
.................... 	char text[21]; 
....................  
.................... 	text = "Set Trailer ID      "; 
*
00C7E:  MOVLW  02
00C80:  MOVWF  FEA
00C82:  MOVLW  F4
00C84:  MOVWF  FE9
00C86:  MOVLW  00
00C88:  CALL   0400
00C8C:  TBLRD*-
00C8E:  TBLRD*+
00C90:  MOVF   FF5,W
00C92:  MOVWF  FEE
00C94:  IORLW  00
00C96:  BNZ   0C8E
.................... 	strcpy(&display_ram[0], &text); 
00C98:  CLRF   FEA
00C9A:  MOVLW  D6
00C9C:  MOVWF  FE9
00C9E:  MOVLW  02
00CA0:  MOVWF  FE2
00CA2:  MOVLW  F4
00CA4:  MOVWF  FE1
00CA6:  MOVF   FE7,F
00CA8:  MOVFF  FE6,FEE
00CAC:  BNZ   0CA6
.................... 	text = "S/R Unit Addresses  "; 
00CAE:  MOVLW  02
00CB0:  MOVWF  FEA
00CB2:  MOVLW  F4
00CB4:  MOVWF  FE9
00CB6:  MOVLW  00
00CB8:  CALL   0426
00CBC:  TBLRD*-
00CBE:  TBLRD*+
00CC0:  MOVF   FF5,W
00CC2:  MOVWF  FEE
00CC4:  IORLW  00
00CC6:  BNZ   0CBE
.................... 	strcpy(&display_ram[1] ,&text); 
00CC8:  CLRF   FEA
00CCA:  MOVLW  EB
00CCC:  MOVWF  FE9
00CCE:  MOVLW  02
00CD0:  MOVWF  FE2
00CD2:  MOVLW  F4
00CD4:  MOVWF  FE1
00CD6:  MOVF   FE7,F
00CD8:  MOVFF  FE6,FEE
00CDC:  BNZ   0CD6
.................... 	text = "Set Time and Date   "; 
00CDE:  MOVLW  02
00CE0:  MOVWF  FEA
00CE2:  MOVLW  F4
00CE4:  MOVWF  FE9
00CE6:  MOVLW  00
00CE8:  CALL   044C
00CEC:  TBLRD*-
00CEE:  TBLRD*+
00CF0:  MOVF   FF5,W
00CF2:  MOVWF  FEE
00CF4:  IORLW  00
00CF6:  BNZ   0CEE
.................... 	strcpy(&display_ram[2], &text); 
00CF8:  MOVLW  01
00CFA:  MOVWF  FEA
00CFC:  CLRF   FE9
00CFE:  MOVLW  02
00D00:  MOVWF  FE2
00D02:  MOVLW  F4
00D04:  MOVWF  FE1
00D06:  MOVF   FE7,F
00D08:  MOVFF  FE6,FEE
00D0C:  BNZ   0D06
.................... 	text = "Exit                "; 
00D0E:  MOVLW  02
00D10:  MOVWF  FEA
00D12:  MOVLW  F4
00D14:  MOVWF  FE9
00D16:  MOVLW  00
00D18:  CALL   0472
00D1C:  TBLRD*-
00D1E:  TBLRD*+
00D20:  MOVF   FF5,W
00D22:  MOVWF  FEE
00D24:  IORLW  00
00D26:  BNZ   0D1E
.................... 	strcpy(&display_ram[3], &text); 
00D28:  MOVLW  01
00D2A:  MOVWF  FEA
00D2C:  MOVLW  15
00D2E:  MOVWF  FE9
00D30:  MOVLW  02
00D32:  MOVWF  FE2
00D34:  MOVLW  F4
00D36:  MOVWF  FE1
00D38:  MOVF   FE7,F
00D3A:  MOVFF  FE6,FEE
00D3E:  BNZ   0D38
00D40:  RETURN 0
.................... } 
....................  
.................... void reset_disp_ram (void) 
.................... { 
.................... 	char text[21]; 
....................  
.................... 	text = "                    "; 
*
01120:  MOVLW  03
01122:  MOVWF  FEA
01124:  MOVLW  13
01126:  MOVWF  FE9
01128:  MOVLW  00
0112A:  CALL   028C
0112E:  TBLRD*-
01130:  TBLRD*+
01132:  MOVF   FF5,W
01134:  MOVWF  FEE
01136:  IORLW  00
01138:  BNZ   1130
.................... 	strcpy(&display_ram[0], &text); 
0113A:  CLRF   FEA
0113C:  MOVLW  D6
0113E:  MOVWF  FE9
01140:  MOVLW  03
01142:  MOVWF  FE2
01144:  MOVLW  13
01146:  MOVWF  FE1
01148:  MOVF   FE7,F
0114A:  MOVFF  FE6,FEE
0114E:  BNZ   1148
.................... 	strcpy(&display_ram[1], &text); 
01150:  CLRF   FEA
01152:  MOVLW  EB
01154:  MOVWF  FE9
01156:  MOVLW  03
01158:  MOVWF  FE2
0115A:  MOVLW  13
0115C:  MOVWF  FE1
0115E:  MOVF   FE7,F
01160:  MOVFF  FE6,FEE
01164:  BNZ   115E
.................... 	strcpy(&display_ram[2], &text); 
01166:  MOVLW  01
01168:  MOVWF  FEA
0116A:  CLRF   FE9
0116C:  MOVLW  03
0116E:  MOVWF  FE2
01170:  MOVLW  13
01172:  MOVWF  FE1
01174:  MOVF   FE7,F
01176:  MOVFF  FE6,FEE
0117A:  BNZ   1174
.................... 	strcpy(&display_ram[3], &text); 
0117C:  MOVLW  01
0117E:  MOVWF  FEA
01180:  MOVLW  15
01182:  MOVWF  FE9
01184:  MOVLW  03
01186:  MOVWF  FE2
01188:  MOVLW  13
0118A:  MOVWF  FE1
0118C:  MOVF   FE7,F
0118E:  MOVFF  FE6,FEE
01192:  BNZ   118C
.................... 	strcpy(&display_ram[4], &text); 
01194:  MOVLW  01
01196:  MOVWF  FEA
01198:  MOVLW  2A
0119A:  MOVWF  FE9
0119C:  MOVLW  03
0119E:  MOVWF  FE2
011A0:  MOVLW  13
011A2:  MOVWF  FE1
011A4:  MOVF   FE7,F
011A6:  MOVFF  FE6,FEE
011AA:  BNZ   11A4
.................... 	strcpy(&display_ram[5], &text); 
011AC:  MOVLW  01
011AE:  MOVWF  FEA
011B0:  MOVLW  3F
011B2:  MOVWF  FE9
011B4:  MOVLW  03
011B6:  MOVWF  FE2
011B8:  MOVLW  13
011BA:  MOVWF  FE1
011BC:  MOVF   FE7,F
011BE:  MOVFF  FE6,FEE
011C2:  BNZ   11BC
011C4:  RETURN 0
.................... } 
....................  
.................... void set_reset_addr_menu (void) 
.................... { 
.................... 	char text[21]; 
....................  
.................... 	text = "Set Unit Addresses  "; 
*
0105C:  MOVLW  02
0105E:  MOVWF  FEA
01060:  MOVLW  F0
01062:  MOVWF  FE9
01064:  MOVLW  00
01066:  CALL   0498
0106A:  TBLRD*-
0106C:  TBLRD*+
0106E:  MOVF   FF5,W
01070:  MOVWF  FEE
01072:  IORLW  00
01074:  BNZ   106C
.................... 	strcpy(&display_ram[0], &text); 
01076:  CLRF   FEA
01078:  MOVLW  D6
0107A:  MOVWF  FE9
0107C:  MOVLW  02
0107E:  MOVWF  FE2
01080:  MOVLW  F0
01082:  MOVWF  FE1
01084:  MOVF   FE7,F
01086:  MOVFF  FE6,FEE
0108A:  BNZ   1084
.................... 	text = "Reset All addresses "; 
0108C:  MOVLW  02
0108E:  MOVWF  FEA
01090:  MOVLW  F0
01092:  MOVWF  FE9
01094:  MOVLW  00
01096:  CALL   04BE
0109A:  TBLRD*-
0109C:  TBLRD*+
0109E:  MOVF   FF5,W
010A0:  MOVWF  FEE
010A2:  IORLW  00
010A4:  BNZ   109C
.................... 	strcpy(&display_ram[1], &text); 
010A6:  CLRF   FEA
010A8:  MOVLW  EB
010AA:  MOVWF  FE9
010AC:  MOVLW  02
010AE:  MOVWF  FE2
010B0:  MOVLW  F0
010B2:  MOVWF  FE1
010B4:  MOVF   FE7,F
010B6:  MOVFF  FE6,FEE
010BA:  BNZ   10B4
.................... 	text = "                    "; 
010BC:  MOVLW  02
010BE:  MOVWF  FEA
010C0:  MOVLW  F0
010C2:  MOVWF  FE9
010C4:  MOVLW  00
010C6:  CALL   028C
010CA:  TBLRD*-
010CC:  TBLRD*+
010CE:  MOVF   FF5,W
010D0:  MOVWF  FEE
010D2:  IORLW  00
010D4:  BNZ   10CC
.................... 	strcpy(&display_ram[2], &text); 
010D6:  MOVLW  01
010D8:  MOVWF  FEA
010DA:  CLRF   FE9
010DC:  MOVLW  02
010DE:  MOVWF  FE2
010E0:  MOVLW  F0
010E2:  MOVWF  FE1
010E4:  MOVF   FE7,F
010E6:  MOVFF  FE6,FEE
010EA:  BNZ   10E4
.................... 	text = "Exit                "; 
010EC:  MOVLW  02
010EE:  MOVWF  FEA
010F0:  MOVLW  F0
010F2:  MOVWF  FE9
010F4:  MOVLW  00
010F6:  CALL   0472
010FA:  TBLRD*-
010FC:  TBLRD*+
010FE:  MOVF   FF5,W
01100:  MOVWF  FEE
01102:  IORLW  00
01104:  BNZ   10FC
.................... 	strcpy(&display_ram[3], &text); 
01106:  MOVLW  01
01108:  MOVWF  FEA
0110A:  MOVLW  15
0110C:  MOVWF  FE9
0110E:  MOVLW  02
01110:  MOVWF  FE2
01112:  MOVLW  F0
01114:  MOVWF  FE1
01116:  MOVF   FE7,F
01118:  MOVFF  FE6,FEE
0111C:  BNZ   1116
0111E:  RETURN 0
.................... } 
....................  
.................... void reset_all_addr_menu (void) 
.................... { 
.................... 	char text[21]; 
....................  
.................... 	reset_disp_ram();  
*
01718:  RCALL  1120
.................... 	text = "!ABOUT TO RESET ALL!"; 
0171A:  MOVLW  02
0171C:  MOVWF  FEA
0171E:  MOVLW  F0
01720:  MOVWF  FE9
01722:  MOVLW  00
01724:  CALL   04E4
01728:  TBLRD*-
0172A:  TBLRD*+
0172C:  MOVF   FF5,W
0172E:  MOVWF  FEE
01730:  IORLW  00
01732:  BNZ   172A
.................... 	strcpy(&display_ram[0], &text); 
01734:  CLRF   FEA
01736:  MOVLW  D6
01738:  MOVWF  FE9
0173A:  MOVLW  02
0173C:  MOVWF  FE2
0173E:  MOVLW  F0
01740:  MOVWF  FE1
01742:  MOVF   FE7,F
01744:  MOVFF  FE6,FEE
01748:  BNZ   1742
.................... 	text = "   ARE YOU SURE??   "; 
0174A:  MOVLW  02
0174C:  MOVWF  FEA
0174E:  MOVLW  F0
01750:  MOVWF  FE9
01752:  MOVLW  00
01754:  CALL   050A
01758:  TBLRD*-
0175A:  TBLRD*+
0175C:  MOVF   FF5,W
0175E:  MOVWF  FEE
01760:  IORLW  00
01762:  BNZ   175A
.................... 	strcpy(&display_ram[1], &text); 
01764:  CLRF   FEA
01766:  MOVLW  EB
01768:  MOVWF  FE9
0176A:  MOVLW  02
0176C:  MOVWF  FE2
0176E:  MOVLW  F0
01770:  MOVWF  FE1
01772:  MOVF   FE7,F
01774:  MOVFF  FE6,FEE
01778:  BNZ   1772
.................... 	text = " Press ENT to abort "; 
0177A:  MOVLW  02
0177C:  MOVWF  FEA
0177E:  MOVLW  F0
01780:  MOVWF  FE9
01782:  MOVLW  00
01784:  CALL   0530
01788:  TBLRD*-
0178A:  TBLRD*+
0178C:  MOVF   FF5,W
0178E:  MOVWF  FEE
01790:  IORLW  00
01792:  BNZ   178A
.................... 	strcpy(&display_ram[2], &text); 
01794:  MOVLW  01
01796:  MOVWF  FEA
01798:  CLRF   FE9
0179A:  MOVLW  02
0179C:  MOVWF  FE2
0179E:  MOVLW  F0
017A0:  MOVWF  FE1
017A2:  MOVF   FE7,F
017A4:  MOVFF  FE6,FEE
017A8:  BNZ   17A2
.................... 	text = " Press UP reset ALL "; 
017AA:  MOVLW  02
017AC:  MOVWF  FEA
017AE:  MOVLW  F0
017B0:  MOVWF  FE9
017B2:  MOVLW  00
017B4:  CALL   0556
017B8:  TBLRD*-
017BA:  TBLRD*+
017BC:  MOVF   FF5,W
017BE:  MOVWF  FEE
017C0:  IORLW  00
017C2:  BNZ   17BA
.................... 	strcpy(&display_ram[3], &text); 
017C4:  MOVLW  01
017C6:  MOVWF  FEA
017C8:  MOVLW  15
017CA:  MOVWF  FE9
017CC:  MOVLW  02
017CE:  MOVWF  FE2
017D0:  MOVLW  F0
017D2:  MOVWF  FE1
017D4:  MOVF   FE7,F
017D6:  MOVFF  FE6,FEE
017DA:  BNZ   17D4
017DC:  GOTO   180C (RETURN)
.................... } 
....................  
.................... void menu_sys (void) 
.................... { 
.................... 	extern int8 display_type; 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 scroll_offset; 
.................... 	extern int8 tick; 
....................  
.................... 	FLASH_REG[0] = BIT0; 
*
01FF2:  MOVLW  01
01FF4:  MOVWF  x9E
....................  
.................... 	TRAILER_ID = read_eeprom(trailer_addr); 
01FF6:  MOVFF  FF2,250
01FFA:  BCF    FF2.7
01FFC:  CLRF   F63
01FFE:  CLRF   F62
02000:  BCF    F7F.6
02002:  BCF    F7F.7
02004:  BSF    F7F.0
02006:  MOVF   F61,W
02008:  MOVLB  2
0200A:  BTFSC  x50.7
0200C:  BSF    FF2.7
0200E:  MOVLB  0
02010:  MOVWF  xA6
.................... 	display_type = MENU; 
02012:  MOVLB  1
02014:  CLRF   x54
.................... 	scroll_offset = 0; 
02016:  MOVLB  0
02018:  CLRF   xA0
.................... 	set_top_menu(); 
0201A:  CALL   0C7E
.................... 	target_MENU = RESET_TO; 
0201E:  SETF   xA5
.................... 	for( ; ; ) 
.................... 	{ 
.................... 		while(tick == 0); 
02020:  MOVF   xA3,F
02022:  BZ    2020
.................... 		tick = 0; 
02024:  CLRF   xA3
.................... 		if(check_menu_TO()) break; 
02026:  CALL   0DD4
0202A:  MOVF   01,F
0202C:  BTFSS  FD8.2
0202E:  BRA    2080
.................... 		if(chk_up())  
02030:  CALL   0E5E
02034:  MOVF   01,F
02036:  BZ    2046
.................... 		{ 
.................... 			target_MENU = RESET_TO; 
02038:  SETF   xA5
.................... 			FLASH_REG[0] = FLASH_REG[0] >>1; 
0203A:  BCF    FD8.0
0203C:  RRCF   x9E,F
.................... 			if(FLASH_REG[0] == 0 ) FLASH_REG[0] = BIT3; 
0203E:  MOVF   x9E,F
02040:  BNZ   2046
02042:  MOVLW  08
02044:  MOVWF  x9E
.................... 		} 
.................... 		if(chk_dn())  
02046:  CALL   0E8C
0204A:  MOVF   01,F
0204C:  BZ    205C
.................... 		{ 
.................... 			target_MENU = RESET_TO; 
0204E:  SETF   xA5
.................... 			FLASH_REG[0] = FLASH_REG[0] << 1; 
02050:  BCF    FD8.0
02052:  RLCF   x9E,F
.................... 			if(FLASH_REG[0] & BIT4 ) FLASH_REG[0] = BIT0; 
02054:  BTFSS  x9E.4
02056:  BRA    205C
02058:  MOVLW  01
0205A:  MOVWF  x9E
.................... 		} 
.................... 		if(chk_ent()) 
0205C:  CALL   0EBA
02060:  MOVF   01,F
02062:  BZ    207E
.................... 		{	//if exit selected then done. 
.................... 			target_MENU = RESET_TO; 
02064:  SETF   xA5
.................... 			if(FLASH_REG[0] & BIT3) break; 
02066:  BTFSC  x9E.3
02068:  BRA    2080
.................... 			if(FLASH_REG[0] & BIT0) set_trailer_id(); 
0206A:  BTFSC  x9E.0
0206C:  GOTO   0EE8
.................... 			if(FLASH_REG[0] & BIT1) set_rst_units(); 
02070:  BTFSC  x9E.1
02072:  BRA    18FE
.................... 			if(FLASH_REG[0] & BIT2) set_time_date(); 
02074:  BTFSC  x9E.2
02076:  BRA    1D1C
.................... 			set_top_menu(); 
02078:  CALL   0C7E
.................... 			target_MENU = RESET_TO; 
0207C:  SETF   xA5
.................... 		} 
0207E:  BRA    2020
.................... 	} 
.................... 	reset_disp_ram(); 
02080:  CALL   1120
02084:  GOTO   3FD4 (RETURN)
.................... } 
....................  
.................... void set_trailer_id (void) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 scroll_offset; 
.................... 	extern char display_ram[6][21]; 
.................... 	extern int8 tick; 
.................... 	extern char TRAILER_ID; 
.................... 	char text[21]; 
....................  
.................... 	FLASH_REG[0] = 0; 
*
00EE8:  CLRF   x9E
.................... 	scroll_offset = 0; 
00EEA:  CLRF   xA0
....................  
.................... 	TRAILER_ID = read_eeprom(trailer_addr); 
00EEC:  MOVFF  FF2,26A
00EF0:  BCF    FF2.7
00EF2:  CLRF   F63
00EF4:  CLRF   F62
00EF6:  BCF    F7F.6
00EF8:  BCF    F7F.7
00EFA:  BSF    F7F.0
00EFC:  MOVF   F61,W
00EFE:  MOVLB  2
00F00:  BTFSC  x6A.7
00F02:  BSF    FF2.7
00F04:  MOVLB  0
00F06:  MOVWF  xA6
.................... 	display_ram[2][0] = "                   "; 
00F08:  MOVLW  20
00F0A:  MOVLB  1
00F0C:  MOVWF  x00
.................... 	if(TRAILER_ID < 'A') TRAILER_ID = 'Z'; 
00F0E:  MOVLB  0
00F10:  MOVF   xA6,W
00F12:  SUBLW  40
00F14:  BNC   0F1A
00F16:  MOVLW  5A
00F18:  MOVWF  xA6
.................... 	if(TRAILER_ID > 'Z') TRAILER_ID = 'A'; 
00F1A:  MOVF   xA6,W
00F1C:  SUBLW  5A
00F1E:  BC    0F24
00F20:  MOVLW  41
00F22:  MOVWF  xA6
.................... 	display_ram[2][ID_POS] = TRAILER_ID;        
00F24:  MOVFF  A6,109
.................... 	 
.................... 	for( ; ; ) 
.................... 	{ 
.................... 		while(tick == 0); 
00F28:  MOVF   xA3,F
00F2A:  BZ    0F28
.................... 		tick = 0; 
00F2C:  CLRF   xA3
.................... 		text = "Set Trailer ID      "; 
00F2E:  MOVLW  02
00F30:  MOVWF  FEA
00F32:  MOVLW  55
00F34:  MOVWF  FE9
00F36:  MOVLW  00
00F38:  CALL   0400
00F3C:  TBLRD*-
00F3E:  TBLRD*+
00F40:  MOVF   FF5,W
00F42:  MOVWF  FEE
00F44:  IORLW  00
00F46:  BNZ   0F3E
.................... 		strcpy(&display_ram[0], &text); 
00F48:  CLRF   FEA
00F4A:  MOVLW  D6
00F4C:  MOVWF  FE9
00F4E:  MOVLW  02
00F50:  MOVWF  FE2
00F52:  MOVLW  55
00F54:  MOVWF  FE1
00F56:  MOVF   FE7,F
00F58:  MOVFF  FE6,FEE
00F5C:  BNZ   0F56
.................... 		text = "Use Up/Down to sel  "; 
00F5E:  MOVLW  02
00F60:  MOVWF  FEA
00F62:  MOVLW  55
00F64:  MOVWF  FE9
00F66:  MOVLW  00
00F68:  CALL   05A0
00F6C:  TBLRD*-
00F6E:  TBLRD*+
00F70:  MOVF   FF5,W
00F72:  MOVWF  FEE
00F74:  IORLW  00
00F76:  BNZ   0F6E
.................... 		strcpy(&display_ram[1], &text); 
00F78:  CLRF   FEA
00F7A:  MOVLW  EB
00F7C:  MOVWF  FE9
00F7E:  MOVLW  02
00F80:  MOVWF  FE2
00F82:  MOVLW  55
00F84:  MOVWF  FE1
00F86:  MOVF   FE7,F
00F88:  MOVFF  FE6,FEE
00F8C:  BNZ   0F86
.................... 		text = "                    "; 
00F8E:  MOVLW  02
00F90:  MOVWF  FEA
00F92:  MOVLW  55
00F94:  MOVWF  FE9
00F96:  MOVLW  00
00F98:  CALL   028C
00F9C:  TBLRD*-
00F9E:  TBLRD*+
00FA0:  MOVF   FF5,W
00FA2:  MOVWF  FEE
00FA4:  IORLW  00
00FA6:  BNZ   0F9E
.................... 		strcpy(&display_ram[2], &text); 
00FA8:  MOVLW  01
00FAA:  MOVWF  FEA
00FAC:  CLRF   FE9
00FAE:  MOVLW  02
00FB0:  MOVWF  FE2
00FB2:  MOVLW  55
00FB4:  MOVWF  FE1
00FB6:  MOVF   FE7,F
00FB8:  MOVFF  FE6,FEE
00FBC:  BNZ   0FB6
.................... 		text = "Press Ent when done "; 
00FBE:  MOVLW  02
00FC0:  MOVWF  FEA
00FC2:  MOVLW  55
00FC4:  MOVWF  FE9
00FC6:  MOVLW  00
00FC8:  CALL   05C6
00FCC:  TBLRD*-
00FCE:  TBLRD*+
00FD0:  MOVF   FF5,W
00FD2:  MOVWF  FEE
00FD4:  IORLW  00
00FD6:  BNZ   0FCE
.................... 		strcpy(&display_ram[3], &text); 
00FD8:  MOVLW  01
00FDA:  MOVWF  FEA
00FDC:  MOVLW  15
00FDE:  MOVWF  FE9
00FE0:  MOVLW  02
00FE2:  MOVWF  FE2
00FE4:  MOVLW  55
00FE6:  MOVWF  FE1
00FE8:  MOVF   FE7,F
00FEA:  MOVFF  FE6,FEE
00FEE:  BNZ   0FE8
....................  
.................... 		if(chk_up())  
00FF0:  RCALL  0E5E
00FF2:  MOVF   01,F
00FF4:  BZ    1002
.................... 		{ 
.................... 			TRAILER_ID++; 
00FF6:  INCF   xA6,F
.................... 			if(TRAILER_ID > 'Z') TRAILER_ID = 'A'; 
00FF8:  MOVF   xA6,W
00FFA:  SUBLW  5A
00FFC:  BC    1002
00FFE:  MOVLW  41
01000:  MOVWF  xA6
.................... 		} 
.................... 		if(chk_dn())  
01002:  RCALL  0E8C
01004:  MOVF   01,F
01006:  BZ    1014
.................... 		{ 
.................... 			TRAILER_ID--; 
01008:  DECF   xA6,F
.................... 			if(TRAILER_ID < 'A') TRAILER_ID = 'Z'; 
0100A:  MOVF   xA6,W
0100C:  SUBLW  40
0100E:  BNC   1014
01010:  MOVLW  5A
01012:  MOVWF  xA6
.................... 		} 
.................... 		display_ram[2][ID_POS] = TRAILER_ID; 
01014:  MOVFF  A6,109
.................... 		if(chk_ent()) 
01018:  RCALL  0EBA
0101A:  MOVF   01,F
0101C:  BZ    104E
.................... 		{	//if exit selected then done. 
.................... 			 
.................... 			set_top_menu(); 
0101E:  RCALL  0C7E
.................... 			write_eeprom (trailer_addr,TRAILER_ID); 
01020:  MOVF   FF2,W
01022:  MOVWF  00
01024:  BCF    FF2.7
01026:  CLRF   F63
01028:  CLRF   F62
0102A:  MOVFF  A6,F61
0102E:  BCF    F7F.6
01030:  BCF    F7F.7
01032:  BSF    F7F.2
01034:  MOVLB  F
01036:  MOVLW  55
01038:  MOVWF  F7E
0103A:  MOVLW  AA
0103C:  MOVWF  F7E
0103E:  BSF    F7F.1
01040:  BTFSC  F7F.1
01042:  BRA    1040
01044:  BCF    F7F.2
01046:  MOVF   00,W
01048:  IORWF  FF2,F
.................... 			break; 
0104A:  BRA    1052
0104C:  MOVLB  0
.................... 		} 
0104E:  BRA    0F28
01050:  MOVLB  F
.................... 	} 
.................... 	FLASH_REG[0] = BIT0; 
01052:  MOVLW  01
01054:  MOVLB  0
01056:  MOVWF  x9E
01058:  GOTO   2070 (RETURN)
.................... } 
....................  
.................... void set_rst_units (void) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 scroll_offset; 
.................... 	extern int8 tick; 
....................  
.................... 	FLASH_REG[0] = BIT0; 
*
018FE:  MOVLW  01
01900:  MOVWF  x9E
.................... 	scroll_offset = 0; 
01902:  CLRF   xA0
....................  
.................... 	//Now we need to find out how many units have been addressed already 
.................... 	set_reset_addr_menu();	 
01904:  CALL   105C
.................... 	for( ; ; ) 
.................... 	{ 
.................... 		while(tick == 0); 
01908:  MOVF   xA3,F
0190A:  BZ    1908
.................... 		tick = 0; 
0190C:  CLRF   xA3
.................... 		if(chk_up())  
0190E:  CALL   0E5E
01912:  MOVF   01,F
01914:  BZ    192A
.................... 		{ 
.................... 			FLASH_REG[0] = FLASH_REG[0] >>1; 
01916:  BCF    FD8.0
01918:  RRCF   x9E,F
.................... 			if(FLASH_REG[0] == 0 ) FLASH_REG[0] = BIT3; 
0191A:  MOVF   x9E,F
0191C:  BNZ   1922
0191E:  MOVLW  08
01920:  MOVWF  x9E
.................... 			if(FLASH_REG[0] & BIT2) FLASH_REG[0] = BIT1; 
01922:  BTFSS  x9E.2
01924:  BRA    192A
01926:  MOVLW  02
01928:  MOVWF  x9E
.................... 		} 
.................... 		if(chk_dn())  
0192A:  CALL   0E8C
0192E:  MOVF   01,F
01930:  BZ    1946
.................... 		{ 
.................... 			FLASH_REG[0] = FLASH_REG[0] << 1; 
01932:  BCF    FD8.0
01934:  RLCF   x9E,F
.................... 			if(FLASH_REG[0] & BIT4 ) FLASH_REG[0] = BIT0; 
01936:  BTFSS  x9E.4
01938:  BRA    193E
0193A:  MOVLW  01
0193C:  MOVWF  x9E
.................... 			if(FLASH_REG[0] & BIT2) FLASH_REG[0] = BIT3; 
0193E:  BTFSS  x9E.2
01940:  BRA    1946
01942:  MOVLW  08
01944:  MOVWF  x9E
.................... 		} 
.................... 		if(chk_ent()) 
01946:  CALL   0EBA
0194A:  MOVF   01,F
0194C:  BZ    1962
.................... 		{	//if exit selected then done. 
.................... 			if(FLASH_REG[0] & BIT3) break; 
0194E:  BTFSC  x9E.3
01950:  BRA    1964
.................... 			if(FLASH_REG[0] & BIT0) set_unit_addrs(); 
01952:  BTFSC  x9E.0
01954:  BRA    13E6
.................... 			if(FLASH_REG[0] & BIT1) rst_unit_addrs(); 
01956:  BTFSC  x9E.1
01958:  BRA    17E0
.................... 			set_reset_addr_menu(); 
0195A:  CALL   105C
.................... 			FLASH_REG[0] = BIT0; 
0195E:  MOVLW  01
01960:  MOVWF  x9E
.................... 		} 
01962:  BRA    1908
.................... 	}	 
.................... 	set_top_menu(); 
01964:  CALL   0C7E
01968:  GOTO   2074 (RETURN)
.................... } 
....................  
.................... void set_unit_addrs (void) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 scroll_offset; 
.................... 	extern char display_ram[6][21]; 
.................... 	extern int8 tick; 
.................... 	int8 next_address, number1,number2; 
.................... 	char text[21]; 
.................... 	int1 OK_flag; 
....................  
.................... 	FLASH_REG[0] = 0; 
*
013E6:  CLRF   x9E
.................... 	scroll_offset = 0; 
013E8:  CLRF   xA0
.................... 	reset_disp_ram(); 
013EA:  RCALL  1120
....................  
.................... 	//Now we need to find out how many units have been addressed already 
.................... 	next_address = read_eeprom(no_of_units)+1; 
013EC:  MOVFF  FF2,272
013F0:  BCF    FF2.7
013F2:  CLRF   F63
013F4:  MOVLW  01
013F6:  MOVWF  F62
013F8:  BCF    F7F.6
013FA:  BCF    F7F.7
013FC:  BSF    F7F.0
013FE:  MOVF   F61,W
01400:  MOVLB  2
01402:  BTFSC  x72.7
01404:  BSF    FF2.7
01406:  ADDLW  01
01408:  MOVWF  x59
.................... 	if(next_address > 6 ) 
0140A:  MOVF   x59,W
0140C:  SUBLW  06
0140E:  BC    145A
.................... 	{						  
.................... 		text = "MAX ADDRESS REACHED "; 
01410:  MOVLW  02
01412:  MOVWF  FEA
01414:  MOVLW  5C
01416:  MOVWF  FE9
01418:  MOVLW  00
0141A:  MOVLB  0
0141C:  CALL   05EC
01420:  TBLRD*-
01422:  TBLRD*+
01424:  MOVF   FF5,W
01426:  MOVWF  FEE
01428:  IORLW  00
0142A:  BNZ   1422
.................... 		strcpy(&display_ram[1], &text); 
0142C:  CLRF   FEA
0142E:  MOVLW  EB
01430:  MOVWF  FE9
01432:  MOVLW  02
01434:  MOVWF  FE2
01436:  MOVLW  5C
01438:  MOVWF  FE1
0143A:  MOVF   FE7,F
0143C:  MOVFF  FE6,FEE
01440:  BNZ   143A
.................... 		delay_ms(3000); 
01442:  MOVLW  0C
01444:  MOVLB  2
01446:  MOVWF  x72
01448:  MOVLW  FA
0144A:  MOVWF  xFC
0144C:  MOVLB  0
0144E:  CALL   0BF4
01452:  MOVLB  2
01454:  DECFSZ x72,F
01456:  BRA    1448
.................... 	} 
01458:  BRA    1712
.................... 	else 
.................... 	{ 
.................... 		for( ; ; ) 
.................... 		{ 
....................  
.................... 			while(tick == 0); 
0145A:  MOVLB  0
0145C:  MOVF   xA3,F
0145E:  BZ    145C
.................... 			tick = 0; 
01460:  CLRF   xA3
.................... 			if(next_address < 10)  
01462:  MOVLB  2
01464:  MOVF   x59,W
01466:  SUBLW  09
01468:  BNC   1476
.................... 			{ 
.................... 				number2 = next_address + '0'; 
0146A:  MOVLW  30
0146C:  ADDWF  x59,W
0146E:  MOVWF  x5B
.................... 				number1 = ' '; 
01470:  MOVLW  20
01472:  MOVWF  x5A
.................... 			} 
01474:  BRA    147E
.................... 			else 
.................... 			{ 
.................... 				number1 = '1'; 
01476:  MOVLW  31
01478:  MOVWF  x5A
.................... 				number2 = '0'; 
0147A:  MOVLW  30
0147C:  MOVWF  x5B
.................... 			} 
.................... 			text = "Set Unit Address    "; 
0147E:  MOVLW  02
01480:  MOVWF  FEA
01482:  MOVLW  5C
01484:  MOVWF  FE9
01486:  MOVLW  00
01488:  MOVLB  0
0148A:  CALL   0612
0148E:  TBLRD*-
01490:  TBLRD*+
01492:  MOVF   FF5,W
01494:  MOVWF  FEE
01496:  IORLW  00
01498:  BNZ   1490
.................... 			strcpy(&display_ram[0], &text); 
0149A:  CLRF   FEA
0149C:  MOVLW  D6
0149E:  MOVWF  FE9
014A0:  MOVLW  02
014A2:  MOVWF  FE2
014A4:  MOVLW  5C
014A6:  MOVWF  FE1
014A8:  MOVF   FE7,F
014AA:  MOVFF  FE6,FEE
014AE:  BNZ   14A8
.................... 			display_ram[0][18] = number1; 
014B0:  MOVFF  25A,E8
.................... 			display_ram[0][19] = number2; 
014B4:  MOVFF  25B,E9
.................... 			text = "Press Enter to Exit "; 
014B8:  MOVLW  02
014BA:  MOVWF  FEA
014BC:  MOVLW  5C
014BE:  MOVWF  FE9
014C0:  MOVLW  00
014C2:  CALL   0638
014C6:  TBLRD*-
014C8:  TBLRD*+
014CA:  MOVF   FF5,W
014CC:  MOVWF  FEE
014CE:  IORLW  00
014D0:  BNZ   14C8
.................... 			strcpy(&display_ram[2], &text); 
014D2:  MOVLW  01
014D4:  MOVWF  FEA
014D6:  CLRF   FE9
014D8:  MOVLW  02
014DA:  MOVWF  FE2
014DC:  MOVLW  5C
014DE:  MOVWF  FE1
014E0:  MOVF   FE7,F
014E2:  MOVFF  FE6,FEE
014E6:  BNZ   14E0
.................... 			text = "Press UP to set addr"; 
014E8:  MOVLW  02
014EA:  MOVWF  FEA
014EC:  MOVLW  5C
014EE:  MOVWF  FE9
014F0:  MOVLW  00
014F2:  CALL   065E
014F6:  TBLRD*-
014F8:  TBLRD*+
014FA:  MOVF   FF5,W
014FC:  MOVWF  FEE
014FE:  IORLW  00
01500:  BNZ   14F8
.................... 			strcpy(&display_ram[3], &text); 
01502:  MOVLW  01
01504:  MOVWF  FEA
01506:  MOVLW  15
01508:  MOVWF  FE9
0150A:  MOVLW  02
0150C:  MOVWF  FE2
0150E:  MOVLW  5C
01510:  MOVWF  FE1
01512:  MOVF   FE7,F
01514:  MOVFF  FE6,FEE
01518:  BNZ   1512
.................... 			if(chk_ent()) 
0151A:  RCALL  0EBA
0151C:  MOVF   01,F
0151E:  BZ    1558
.................... 			{	//if exit selected then done. 
.................... 				write_eeprom(no_of_units,(next_address-1)); 
01520:  MOVLW  01
01522:  MOVLB  2
01524:  SUBWF  x59,W
01526:  MOVWF  x72
01528:  MOVF   FF2,W
0152A:  MOVWF  00
0152C:  BCF    FF2.7
0152E:  CLRF   F63
01530:  MOVLW  01
01532:  MOVWF  F62
01534:  MOVFF  272,F61
01538:  BCF    F7F.6
0153A:  BCF    F7F.7
0153C:  BSF    F7F.2
0153E:  MOVLB  F
01540:  MOVLW  55
01542:  MOVWF  F7E
01544:  MOVLW  AA
01546:  MOVWF  F7E
01548:  BSF    F7F.1
0154A:  BTFSC  F7F.1
0154C:  BRA    154A
0154E:  BCF    F7F.2
01550:  MOVF   00,W
01552:  IORWF  FF2,F
.................... 				break;		 
01554:  BRA    1710
01556:  MOVLB  0
.................... 			} 
.................... 			if(chk_up())  
01558:  RCALL  0E5E
0155A:  MOVF   01,F
0155C:  BTFSC  FD8.2
0155E:  BRA    170C
.................... 			{ 
.................... 				FLASHING_OFF 
01560:  BCF    F9D.1
.................... 				OK_flag = send_RS485 (SET_ADR,next_address); 
01562:  MOVLW  1E
01564:  MOVLB  2
01566:  MOVWF  xF4
01568:  MOVFF  259,2F5
0156C:  MOVLB  0
0156E:  RCALL  11EC
01570:  MOVLB  2
01572:  BCF    x71.0
01574:  BTFSC  01.0
01576:  BSF    x71.0
.................... 				if(!OK_flag) 
01578:  BTFSC  x71.0
0157A:  BRA    1638
.................... 				{      
.................... 					FLASHING_ON       
0157C:  BCF    F9E.1
0157E:  CLRF   FCC
01580:  BSF    F9D.1
.................... 					text = "                    "; 
01582:  MOVLW  02
01584:  MOVWF  FEA
01586:  MOVLW  5C
01588:  MOVWF  FE9
0158A:  MOVLW  00
0158C:  MOVLB  0
0158E:  CALL   028C
01592:  TBLRD*-
01594:  TBLRD*+
01596:  MOVF   FF5,W
01598:  MOVWF  FEE
0159A:  IORLW  00
0159C:  BNZ   1594
.................... 					strcpy(&display_ram[2], &text); 
0159E:  MOVLW  01
015A0:  MOVWF  FEA
015A2:  CLRF   FE9
015A4:  MOVLW  02
015A6:  MOVWF  FE2
015A8:  MOVLW  5C
015AA:  MOVWF  FE1
015AC:  MOVF   FE7,F
015AE:  MOVFF  FE6,FEE
015B2:  BNZ   15AC
.................... 					text = " !OPERATION FAILED! "; 
015B4:  MOVLW  02
015B6:  MOVWF  FEA
015B8:  MOVLW  5C
015BA:  MOVWF  FE9
015BC:  MOVLW  00
015BE:  CALL   0684
015C2:  TBLRD*-
015C4:  TBLRD*+
015C6:  MOVF   FF5,W
015C8:  MOVWF  FEE
015CA:  IORLW  00
015CC:  BNZ   15C4
.................... 					strcpy(&display_ram[3], &text); 
015CE:  MOVLW  01
015D0:  MOVWF  FEA
015D2:  MOVLW  15
015D4:  MOVWF  FE9
015D6:  MOVLW  02
015D8:  MOVWF  FE2
015DA:  MOVLW  5C
015DC:  MOVWF  FE1
015DE:  MOVF   FE7,F
015E0:  MOVFF  FE6,FEE
015E4:  BNZ   15DE
.................... 					write_eeprom(no_of_units,(next_address-1)); 
015E6:  MOVLW  01
015E8:  MOVLB  2
015EA:  SUBWF  x59,W
015EC:  MOVWF  x72
015EE:  MOVF   FF2,W
015F0:  MOVWF  00
015F2:  BCF    FF2.7
015F4:  CLRF   F63
015F6:  MOVLW  01
015F8:  MOVWF  F62
015FA:  MOVFF  272,F61
015FE:  BCF    F7F.6
01600:  BCF    F7F.7
01602:  BSF    F7F.2
01604:  MOVLB  F
01606:  MOVLW  55
01608:  MOVWF  F7E
0160A:  MOVLW  AA
0160C:  MOVWF  F7E
0160E:  BSF    F7F.1
01610:  BTFSC  F7F.1
01612:  BRA    1610
01614:  BCF    F7F.2
01616:  MOVF   00,W
01618:  IORWF  FF2,F
.................... 					delay_ms(3000); 
0161A:  MOVLW  0C
0161C:  MOVLB  2
0161E:  MOVWF  x72
01620:  MOVLW  FA
01622:  MOVWF  xFC
01624:  MOVLB  0
01626:  CALL   0BF4
0162A:  MOVLB  2
0162C:  DECFSZ x72,F
0162E:  BRA    1620
.................... 					break; 
01630:  MOVLB  F
01632:  BRA    1710
.................... 				} 
01634:  BRA    170A
01636:  MOVLB  2
.................... 				else 
.................... 				{	  
.................... 					FLASHING_ON        
01638:  BCF    F9E.1
0163A:  CLRF   FCC
0163C:  BSF    F9D.1
.................... 					text = "                   "; 
0163E:  MOVLW  02
01640:  MOVWF  FEA
01642:  MOVLW  5C
01644:  MOVWF  FE9
01646:  MOVLW  00
01648:  MOVLB  0
0164A:  CALL   057C
0164E:  TBLRD*-
01650:  TBLRD*+
01652:  MOVF   FF5,W
01654:  MOVWF  FEE
01656:  IORLW  00
01658:  BNZ   1650
.................... 					strcpy(&display_ram[2], &text); 
0165A:  MOVLW  01
0165C:  MOVWF  FEA
0165E:  CLRF   FE9
01660:  MOVLW  02
01662:  MOVWF  FE2
01664:  MOVLW  5C
01666:  MOVWF  FE1
01668:  MOVF   FE7,F
0166A:  MOVFF  FE6,FEE
0166E:  BNZ   1668
.................... 					text = "   ADDRESS SET OK   "; 
01670:  MOVLW  02
01672:  MOVWF  FEA
01674:  MOVLW  5C
01676:  MOVWF  FE9
01678:  MOVLW  00
0167A:  CALL   06AA
0167E:  TBLRD*-
01680:  TBLRD*+
01682:  MOVF   FF5,W
01684:  MOVWF  FEE
01686:  IORLW  00
01688:  BNZ   1680
.................... 					strcpy(&display_ram[3], &text); 
0168A:  MOVLW  01
0168C:  MOVWF  FEA
0168E:  MOVLW  15
01690:  MOVWF  FE9
01692:  MOVLW  02
01694:  MOVWF  FE2
01696:  MOVLW  5C
01698:  MOVWF  FE1
0169A:  MOVF   FE7,F
0169C:  MOVFF  FE6,FEE
016A0:  BNZ   169A
.................... 					delay_ms(3000); 
016A2:  MOVLW  0C
016A4:  MOVLB  2
016A6:  MOVWF  x72
016A8:  MOVLW  FA
016AA:  MOVWF  xFC
016AC:  MOVLB  0
016AE:  CALL   0BF4
016B2:  MOVLB  2
016B4:  DECFSZ x72,F
016B6:  BRA    16A8
.................... 					next_address++; 
016B8:  INCF   x59,F
.................... 					if(next_address >10 ) 
016BA:  MOVF   x59,W
016BC:  SUBLW  0A
016BE:  BC    1708
.................... 					{						  
.................... 						text = "MAX ADDRESS REACHED!"; 
016C0:  MOVLW  02
016C2:  MOVWF  FEA
016C4:  MOVLW  5C
016C6:  MOVWF  FE9
016C8:  MOVLW  00
016CA:  MOVLB  0
016CC:  CALL   06D0
016D0:  TBLRD*-
016D2:  TBLRD*+
016D4:  MOVF   FF5,W
016D6:  MOVWF  FEE
016D8:  IORLW  00
016DA:  BNZ   16D2
.................... 						strcpy(&display_ram[1], &text); 
016DC:  CLRF   FEA
016DE:  MOVLW  EB
016E0:  MOVWF  FE9
016E2:  MOVLW  02
016E4:  MOVWF  FE2
016E6:  MOVLW  5C
016E8:  MOVWF  FE1
016EA:  MOVF   FE7,F
016EC:  MOVFF  FE6,FEE
016F0:  BNZ   16EA
.................... 						delay_ms(3000); 
016F2:  MOVLW  0C
016F4:  MOVLB  2
016F6:  MOVWF  x72
016F8:  MOVLW  FA
016FA:  MOVWF  xFC
016FC:  MOVLB  0
016FE:  CALL   0BF4
01702:  MOVLB  2
01704:  DECFSZ x72,F
01706:  BRA    16F8
01708:  MOVLB  F
0170A:  MOVLB  0
.................... 					} 
.................... 				} 
.................... 			} 
0170C:  BRA    145C
0170E:  MOVLB  F
01710:  MOVLB  2
.................... 		} 
.................... 	} 
01712:  MOVLB  0
01714:  GOTO   1956 (RETURN)
.................... }		 
....................  
.................... int8 rst_unit_addrs (void) 
.................... { 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern int8 scroll_offset; 
.................... 	extern char display_ram[6][21]; 
.................... 	int8 number_of_set_units; 
.................... 	char text[21]; 
....................  
.................... 	FLASH_REG[0] = 0; 
*
017E0:  CLRF   x9E
.................... 	scroll_offset = 0; 
017E2:  CLRF   xA0
....................  
.................... 	//Now we need to find out how many units have been addressed already 
.................... 	number_of_set_units = read_eeprom(no_of_units); 
017E4:  MOVFF  FF2,26F
017E8:  BCF    FF2.7
017EA:  CLRF   F63
017EC:  MOVLW  01
017EE:  MOVWF  F62
017F0:  BCF    F7F.6
017F2:  BCF    F7F.7
017F4:  BSF    F7F.0
017F6:  MOVF   F61,W
017F8:  MOVLB  2
017FA:  BTFSC  x6F.7
017FC:  BSF    FF2.7
017FE:  MOVWF  x59
.................... 	if(number_of_set_units == 0) number_of_set_units = 1;	//alway assume there is one unit. 
01800:  MOVF   x59,F
01802:  BNZ   1808
01804:  MOVLW  01
01806:  MOVWF  x59
.................... 	reset_all_addr_menu(); 
01808:  MOVLB  0
0180A:  BRA    1718
....................  
.................... 	while(!chk_ent()) 
0180C:  CALL   0EBA
01810:  MOVF   01,F
01812:  BTFSS  FD8.2
01814:  BRA    18F6
.................... 	{ 
.................... 		if(chk_up())  
01816:  CALL   0E5E
0181A:  MOVF   01,F
0181C:  BZ    18F4
.................... 		{	//reset all set up unit addresses. 
.................... 			reset_disp_ram();        
0181E:  RCALL  1120
.................... 			text = "     Please Wait    "; 
01820:  MOVLW  02
01822:  MOVWF  FEA
01824:  MOVLW  5A
01826:  MOVWF  FE9
01828:  MOVLW  00
0182A:  CALL   06F6
0182E:  TBLRD*-
01830:  TBLRD*+
01832:  MOVF   FF5,W
01834:  MOVWF  FEE
01836:  IORLW  00
01838:  BNZ   1830
.................... 			strcpy(&display_ram[0], &text); 
0183A:  CLRF   FEA
0183C:  MOVLW  D6
0183E:  MOVWF  FE9
01840:  MOVLW  02
01842:  MOVWF  FE2
01844:  MOVLW  5A
01846:  MOVWF  FE1
01848:  MOVF   FE7,F
0184A:  MOVFF  FE6,FEE
0184E:  BNZ   1848
.................... 			FLASHING_OFF 
01850:  BCF    F9D.1
.................... 			send_RS485(RST_ADR,0); 
01852:  MOVLW  4A
01854:  MOVLB  2
01856:  MOVWF  xF4
01858:  CLRF   xF5
0185A:  MOVLB  0
0185C:  RCALL  11EC
.................... 			FLASHING_ON 
0185E:  BCF    F9E.1
01860:  CLRF   FCC
01862:  BSF    F9D.1
.................... 			delay_ms(3000); 
01864:  MOVLW  0C
01866:  MOVLB  2
01868:  MOVWF  x6F
0186A:  MOVLW  FA
0186C:  MOVWF  xFC
0186E:  MOVLB  0
01870:  CALL   0BF4
01874:  MOVLB  2
01876:  DECFSZ x6F,F
01878:  BRA    186A
.................... 			text = "  RESET SUCCESSFUL  "; 
0187A:  MOVLW  02
0187C:  MOVWF  FEA
0187E:  MOVLW  5A
01880:  MOVWF  FE9
01882:  MOVLW  00
01884:  MOVLB  0
01886:  CALL   071C
0188A:  TBLRD*-
0188C:  TBLRD*+
0188E:  MOVF   FF5,W
01890:  MOVWF  FEE
01892:  IORLW  00
01894:  BNZ   188C
.................... 			strcpy(&display_ram[0], &text); 
01896:  CLRF   FEA
01898:  MOVLW  D6
0189A:  MOVWF  FE9
0189C:  MOVLW  02
0189E:  MOVWF  FE2
018A0:  MOVLW  5A
018A2:  MOVWF  FE1
018A4:  MOVF   FE7,F
018A6:  MOVFF  FE6,FEE
018AA:  BNZ   18A4
.................... 			write_eeprom(no_of_units,0); 
018AC:  MOVF   FF2,W
018AE:  MOVWF  00
018B0:  BCF    FF2.7
018B2:  CLRF   F63
018B4:  MOVLW  01
018B6:  MOVWF  F62
018B8:  CLRF   F61
018BA:  BCF    F7F.6
018BC:  BCF    F7F.7
018BE:  BSF    F7F.2
018C0:  MOVLB  F
018C2:  MOVLW  55
018C4:  MOVWF  F7E
018C6:  MOVLW  AA
018C8:  MOVWF  F7E
018CA:  BSF    F7F.1
018CC:  BTFSC  F7F.1
018CE:  BRA    18CC
018D0:  BCF    F7F.2
018D2:  MOVF   00,W
018D4:  IORWF  FF2,F
.................... 			delay_ms(3000); 
018D6:  MOVLW  0C
018D8:  MOVLB  2
018DA:  MOVWF  x6F
018DC:  MOVLW  FA
018DE:  MOVWF  xFC
018E0:  MOVLB  0
018E2:  CALL   0BF4
018E6:  MOVLB  2
018E8:  DECFSZ x6F,F
018EA:  BRA    18DC
.................... 			set_reset_addr_menu(); 
018EC:  MOVLB  0
018EE:  CALL   105C
.................... 			break; 
018F2:  BRA    18F6
.................... 		} 
018F4:  BRA    180C
.................... 	} 
.................... 	return 1; 
018F6:  MOVLW  01
018F8:  MOVWF  01
018FA:  GOTO   195A (RETURN)
.................... } 
....................  
....................  
.................... void set_time_date (void) 
.................... { 
.................... 	extern struct TIME TIME_STAMP; 
....................    	extern struct TIME *pTIME_STAMP; 
.................... 	extern int8 scroll_offset; 
.................... 	extern int8 FLASH_REG[2]; 
.................... 	extern char display_ram[6][21]; 
.................... 	char text[21]; 
.................... 	int8 number; 
....................  
.................... 	pTIME_STAMP = &TIME_STAMP;	 
*
01D1C:  CLRF   23
01D1E:  MOVLW  1C
01D20:  MOVWF  22
.................... 	scroll_offset = 0; 
01D22:  CLRF   xA0
.................... 	reset_disp_ram(); 
01D24:  CALL   1120
.................... 	read_RTC(); 
01D28:  RCALL  196C
.................... 	text = "ENTER DATE  YY MM DD"; 
01D2A:  MOVLW  02
01D2C:  MOVWF  FEA
01D2E:  MOVLW  55
01D30:  MOVWF  FE9
01D32:  MOVLW  00
01D34:  CALL   0742
01D38:  TBLRD*-
01D3A:  TBLRD*+
01D3C:  MOVF   FF5,W
01D3E:  MOVWF  FEE
01D40:  IORLW  00
01D42:  BNZ   1D3A
.................... 	strcpy(&display_ram[0], &text); 
01D44:  CLRF   FEA
01D46:  MOVLW  D6
01D48:  MOVWF  FE9
01D4A:  MOVLW  02
01D4C:  MOVWF  FE2
01D4E:  MOVLW  55
01D50:  MOVWF  FE1
01D52:  MOVF   FE7,F
01D54:  MOVFF  FE6,FEE
01D58:  BNZ   1D52
.................... 	text = 	"ENTER TIME  HH MM SS"; 
01D5A:  MOVLW  02
01D5C:  MOVWF  FEA
01D5E:  MOVLW  55
01D60:  MOVWF  FE9
01D62:  MOVLW  00
01D64:  CALL   0768
01D68:  TBLRD*-
01D6A:  TBLRD*+
01D6C:  MOVF   FF5,W
01D6E:  MOVWF  FEE
01D70:  IORLW  00
01D72:  BNZ   1D6A
.................... 	strcpy(&display_ram[2], &text); 
01D74:  MOVLW  01
01D76:  MOVWF  FEA
01D78:  CLRF   FE9
01D7A:  MOVLW  02
01D7C:  MOVWF  FE2
01D7E:  MOVLW  55
01D80:  MOVWF  FE1
01D82:  MOVF   FE7,F
01D84:  MOVFF  FE6,FEE
01D88:  BNZ   1D82
.................... 	pTIME_STAMP = &TIME_STAMP; 
01D8A:  CLRF   23
01D8C:  MOVLW  1C
01D8E:  MOVWF  22
.................... 	FLASH_REG[0] = 0; 
01D90:  CLRF   x9E
.................... 	number = convert_BCD_to_No (pTIME_STAMP->year,7); 
01D92:  MOVLW  05
01D94:  ADDWF  22,W
01D96:  MOVWF  FE9
01D98:  MOVLW  00
01D9A:  ADDWFC 23,W
01D9C:  MOVWF  FEA
01D9E:  MOVFF  FEF,2F5
01DA2:  MOVLW  07
01DA4:  MOVLB  2
01DA6:  MOVWF  xF6
01DA8:  MOVLB  0
01DAA:  CALL   0D7E
01DAE:  MOVFF  01,26A
.................... 	number = enter_number (65,16,number,1,12); 
01DB2:  MOVLW  41
01DB4:  MOVLB  2
01DB6:  MOVWF  xF4
01DB8:  MOVLW  10
01DBA:  MOVWF  xF5
01DBC:  MOVFF  26A,2F6
01DC0:  MOVLW  01
01DC2:  MOVWF  xF7
01DC4:  MOVLW  0C
01DC6:  MOVWF  xF8
01DC8:  MOVLB  0
01DCA:  RCALL  1AAE
01DCC:  MOVFF  01,26A
.................... 	pTIME_STAMP->year = convert_No_to_BCD (number); 
01DD0:  MOVLW  05
01DD2:  ADDWF  22,W
01DD4:  MOVWF  01
01DD6:  MOVLW  00
01DD8:  ADDWFC 23,W
01DDA:  MOVWF  03
01DDC:  MOVFF  01,26B
01DE0:  MOVLB  2
01DE2:  MOVWF  x6C
01DE4:  MOVFF  26A,2F6
01DE8:  MOVLB  0
01DEA:  RCALL  1C4C
01DEC:  MOVFF  26C,FEA
01DF0:  MOVFF  26B,FE9
01DF4:  MOVFF  01,FEF
....................  
.................... 	number = convert_BCD_to_No (pTIME_STAMP->month,5); 
01DF8:  MOVLW  04
01DFA:  ADDWF  22,W
01DFC:  MOVWF  FE9
01DFE:  MOVLW  00
01E00:  ADDWFC 23,W
01E02:  MOVWF  FEA
01E04:  MOVFF  FEF,2F5
01E08:  MOVLW  05
01E0A:  MOVLB  2
01E0C:  MOVWF  xF6
01E0E:  MOVLB  0
01E10:  CALL   0D7E
01E14:  MOVFF  01,26A
.................... 	number = enter_number (12,1,number,1,15); 
01E18:  MOVLW  0C
01E1A:  MOVLB  2
01E1C:  MOVWF  xF4
01E1E:  MOVLW  01
01E20:  MOVWF  xF5
01E22:  MOVFF  26A,2F6
01E26:  MOVWF  xF7
01E28:  MOVLW  0F
01E2A:  MOVWF  xF8
01E2C:  MOVLB  0
01E2E:  RCALL  1AAE
01E30:  MOVFF  01,26A
.................... 	pTIME_STAMP->month = convert_No_to_BCD (number); 
01E34:  MOVLW  04
01E36:  ADDWF  22,W
01E38:  MOVWF  01
01E3A:  MOVLW  00
01E3C:  ADDWFC 23,W
01E3E:  MOVWF  03
01E40:  MOVFF  01,26B
01E44:  MOVLB  2
01E46:  MOVWF  x6C
01E48:  MOVFF  26A,2F6
01E4C:  MOVLB  0
01E4E:  RCALL  1C4C
01E50:  MOVFF  26C,FEA
01E54:  MOVFF  26B,FE9
01E58:  MOVFF  01,FEF
....................  
....................  
.................... 	number = convert_BCD_to_No (pTIME_STAMP->day,6); 
01E5C:  MOVLW  03
01E5E:  ADDWF  22,W
01E60:  MOVWF  FE9
01E62:  MOVLW  00
01E64:  ADDWFC 23,W
01E66:  MOVWF  FEA
01E68:  MOVFF  FEF,2F5
01E6C:  MOVLW  06
01E6E:  MOVLB  2
01E70:  MOVWF  xF6
01E72:  MOVLB  0
01E74:  CALL   0D7E
01E78:  MOVFF  01,26A
.................... 	number = enter_number (31,1,number,1,18); 
01E7C:  MOVLW  1F
01E7E:  MOVLB  2
01E80:  MOVWF  xF4
01E82:  MOVLW  01
01E84:  MOVWF  xF5
01E86:  MOVFF  26A,2F6
01E8A:  MOVWF  xF7
01E8C:  MOVLW  12
01E8E:  MOVWF  xF8
01E90:  MOVLB  0
01E92:  RCALL  1AAE
01E94:  MOVFF  01,26A
.................... 	pTIME_STAMP->day = convert_No_to_BCD (number); 
01E98:  MOVLW  03
01E9A:  ADDWF  22,W
01E9C:  MOVWF  01
01E9E:  MOVLW  00
01EA0:  ADDWFC 23,W
01EA2:  MOVWF  03
01EA4:  MOVFF  01,26B
01EA8:  MOVLB  2
01EAA:  MOVWF  x6C
01EAC:  MOVFF  26A,2F6
01EB0:  MOVLB  0
01EB2:  RCALL  1C4C
01EB4:  MOVFF  26C,FEA
01EB8:  MOVFF  26B,FE9
01EBC:  MOVFF  01,FEF
....................  
....................  
.................... 	number = convert_BCD_to_No (pTIME_STAMP->hour,5); 
01EC0:  MOVLW  02
01EC2:  ADDWF  22,W
01EC4:  MOVWF  FE9
01EC6:  MOVLW  00
01EC8:  ADDWFC 23,W
01ECA:  MOVWF  FEA
01ECC:  MOVFF  FEF,2F5
01ED0:  MOVLW  05
01ED2:  MOVLB  2
01ED4:  MOVWF  xF6
01ED6:  MOVLB  0
01ED8:  CALL   0D7E
01EDC:  MOVFF  01,26A
.................... 	number = enter_number (23,0,number,3,12); 
01EE0:  MOVLW  17
01EE2:  MOVLB  2
01EE4:  MOVWF  xF4
01EE6:  CLRF   xF5
01EE8:  MOVFF  26A,2F6
01EEC:  MOVLW  03
01EEE:  MOVWF  xF7
01EF0:  MOVLW  0C
01EF2:  MOVWF  xF8
01EF4:  MOVLB  0
01EF6:  RCALL  1AAE
01EF8:  MOVFF  01,26A
.................... 	pTIME_STAMP->hour = convert_No_to_BCD (number); 
01EFC:  MOVLW  02
01EFE:  ADDWF  22,W
01F00:  MOVWF  01
01F02:  MOVLW  00
01F04:  ADDWFC 23,W
01F06:  MOVWF  03
01F08:  MOVFF  01,26B
01F0C:  MOVLB  2
01F0E:  MOVWF  x6C
01F10:  MOVFF  26A,2F6
01F14:  MOVLB  0
01F16:  RCALL  1C4C
01F18:  MOVFF  26C,FEA
01F1C:  MOVFF  26B,FE9
01F20:  MOVFF  01,FEF
....................  
....................  
.................... 	number = convert_BCD_to_No (pTIME_STAMP->min,7); 
01F24:  MOVLW  01
01F26:  ADDWF  22,W
01F28:  MOVWF  FE9
01F2A:  MOVLW  00
01F2C:  ADDWFC 23,W
01F2E:  MOVWF  FEA
01F30:  MOVFF  FEF,2F5
01F34:  MOVLW  07
01F36:  MOVLB  2
01F38:  MOVWF  xF6
01F3A:  MOVLB  0
01F3C:  CALL   0D7E
01F40:  MOVFF  01,26A
.................... 	number = enter_number (59,0,number,3,15); 
01F44:  MOVLW  3B
01F46:  MOVLB  2
01F48:  MOVWF  xF4
01F4A:  CLRF   xF5
01F4C:  MOVFF  26A,2F6
01F50:  MOVLW  03
01F52:  MOVWF  xF7
01F54:  MOVLW  0F
01F56:  MOVWF  xF8
01F58:  MOVLB  0
01F5A:  RCALL  1AAE
01F5C:  MOVFF  01,26A
.................... 	pTIME_STAMP->min = convert_No_to_BCD (number); 
01F60:  MOVLW  01
01F62:  ADDWF  22,W
01F64:  MOVWF  01
01F66:  MOVLW  00
01F68:  ADDWFC 23,W
01F6A:  MOVWF  03
01F6C:  MOVFF  01,26B
01F70:  MOVLB  2
01F72:  MOVWF  x6C
01F74:  MOVFF  26A,2F6
01F78:  MOVLB  0
01F7A:  RCALL  1C4C
01F7C:  MOVFF  26C,FEA
01F80:  MOVFF  26B,FE9
01F84:  MOVFF  01,FEF
....................  
.................... 	number = convert_BCD_to_No (pTIME_STAMP->sec,7); 
01F88:  MOVFF  22,FE9
01F8C:  MOVFF  23,FEA
01F90:  MOVFF  FEF,2F5
01F94:  MOVLW  07
01F96:  MOVLB  2
01F98:  MOVWF  xF6
01F9A:  MOVLB  0
01F9C:  CALL   0D7E
01FA0:  MOVFF  01,26A
.................... 	number = enter_number (59,0,number,3,18); 
01FA4:  MOVLW  3B
01FA6:  MOVLB  2
01FA8:  MOVWF  xF4
01FAA:  CLRF   xF5
01FAC:  MOVFF  26A,2F6
01FB0:  MOVLW  03
01FB2:  MOVWF  xF7
01FB4:  MOVLW  12
01FB6:  MOVWF  xF8
01FB8:  MOVLB  0
01FBA:  RCALL  1AAE
01FBC:  MOVFF  01,26A
.................... 	pTIME_STAMP->sec = convert_No_to_BCD (number); 
01FC0:  MOVFF  22,01
01FC4:  MOVFF  23,03
01FC8:  MOVFF  22,26B
01FCC:  MOVFF  23,26C
01FD0:  MOVFF  26A,2F6
01FD4:  MOVLB  0
01FD6:  RCALL  1C4C
01FD8:  MOVFF  26C,FEA
01FDC:  MOVFF  26B,FE9
01FE0:  MOVFF  01,FEF
.................... 	write_RTC(); 
01FE4:  BRA    1C7E
.................... 	FLASH_REG[0] = BIT0; 
01FE6:  MOVLW  01
01FE8:  MOVWF  x9E
.................... 	set_top_menu(); 
01FEA:  CALL   0C7E
01FEE:  GOTO   2078 (RETURN)
.................... } 
....................  
.................... int8 convert_BCD_to_No (int8 BCDin,int8 Act_Bits) 
*
00D7E:  MOVLB  2
00D80:  CLRF   xF7
00D82:  MOVLW  01
00D84:  MOVWF  xF8
.................... { 
.................... 	int8 output = 0, BIT_MASK = 0b00000001, i; 
.................... 	int8 TAB_BDC_VAL[7] = {1,2,4,8,10,20,40}; 
00D86:  MOVWF  xFA
00D88:  MOVLW  02
00D8A:  MOVWF  xFB
00D8C:  MOVLW  04
00D8E:  MOVWF  xFC
00D90:  MOVLW  08
00D92:  MOVWF  xFD
00D94:  MOVLW  0A
00D96:  MOVWF  xFE
00D98:  MOVLW  14
00D9A:  MOVWF  xFF
00D9C:  MOVLW  28
00D9E:  MOVLB  3
00DA0:  MOVWF  x00
....................  
.................... 	for(i=0;i<Act_Bits;i++) 
00DA2:  MOVLB  2
00DA4:  CLRF   xF9
00DA6:  MOVF   xF6,W
00DA8:  SUBWF  xF9,W
00DAA:  BC    0DCC
.................... 	{ 
.................... 		if(BCDin & BIT_MASK) 
00DAC:  MOVF   xF5,W
00DAE:  ANDWF  xF8,W
00DB0:  BZ    0DC4
.................... 		{ 
.................... 			output += TAB_BDC_VAL[i]; 
00DB2:  CLRF   03
00DB4:  MOVF   xF9,W
00DB6:  ADDLW  FA
00DB8:  MOVWF  FE9
00DBA:  MOVLW  02
00DBC:  ADDWFC 03,W
00DBE:  MOVWF  FEA
00DC0:  MOVF   FEF,W
00DC2:  ADDWF  xF7,F
.................... 		} 
.................... 		BIT_MASK = BIT_MASK << 1; 
00DC4:  BCF    FD8.0
00DC6:  RLCF   xF8,F
00DC8:  INCF   xF9,F
00DCA:  BRA    0DA6
.................... 	} 
.................... 	return output; 
00DCC:  MOVFF  2F7,01
00DD0:  MOVLB  0
00DD2:  RETURN 0
.................... } 
....................  
.................... int8 convert_No_to_BCD (int8 no_in) 
.................... {	//Note the 40,20,10 columns override the 8,4,2,1 i.e. 10 = 10, not 8+2. 
.................... 	int8 BCDout; 
.................... 	int8 val; 
....................  
.................... 	val = no_in/10; 
*
01C4C:  MOVFF  2F6,2FC
01C50:  MOVLW  0A
01C52:  MOVLB  2
01C54:  MOVWF  xFD
01C56:  MOVLB  0
01C58:  RCALL  1A82
01C5A:  MOVFF  01,2F8
.................... 	BCDout = val << 4; 
01C5E:  MOVLB  2
01C60:  SWAPF  xF8,W
01C62:  MOVWF  xF7
01C64:  MOVLW  F0
01C66:  ANDWF  xF7,F
.................... 	val = no_in - (10*val); 
01C68:  MOVF   xF8,W
01C6A:  MULLW  0A
01C6C:  MOVF   FF3,W
01C6E:  SUBWF  xF6,W
01C70:  MOVWF  xF8
.................... 	BCDout |= val; 
01C72:  MOVF   xF8,W
01C74:  IORWF  xF7,F
.................... 	return BCDout; 
01C76:  MOVFF  2F7,01
01C7A:  MOVLB  0
01C7C:  RETURN 0
.................... } 
....................  
....................  
.................... int8 enter_number (int8 hi_lim, int8 lo_lim, int8 number, int8 line, int8 col) 
*
01AAE:  MOVLW  19
01AB0:  MOVLB  2
01AB2:  MOVWF  xFB
.................... { 
.................... 	int8 digit1,digit2,flash_timer = 25; 
....................  
.................... 	//first ensure numbers are in range 
.................... 	if(number > hi_lim) number = hi_lim; 
01AB4:  MOVF   xF6,W
01AB6:  SUBWF  xF4,W
01AB8:  BTFSS  FD8.0
01ABA:  MOVFF  2F4,2F6
.................... 	if(lo_lim != 0) {if(number < lo_lim) number = lo_lim;} 
01ABE:  MOVF   xF5,F
01AC0:  BTFSC  FD8.2
01AC2:  BRA    1ACE
01AC4:  MOVF   xF5,W
01AC6:  SUBWF  xF6,W
01AC8:  BTFSS  FD8.0
01ACA:  MOVFF  2F5,2F6
....................  
.................... 	for( ; ; ) 
.................... 	{ 
.................... 		if(chk_up())  
01ACE:  MOVLB  0
01AD0:  CALL   0E5E
01AD4:  MOVF   01,F
01AD6:  BZ    1AE8
.................... 		{ 
.................... 			number++; 
01AD8:  MOVLB  2
01ADA:  INCF   xF6,F
.................... 			if(number > hi_lim) number = lo_lim; 
01ADC:  MOVF   xF6,W
01ADE:  SUBWF  xF4,W
01AE0:  BTFSS  FD8.0
01AE2:  MOVFF  2F5,2F6
01AE6:  MOVLB  0
.................... 		}	 
.................... 		if(chk_dn())  
01AE8:  CALL   0E8C
01AEC:  MOVF   01,F
01AEE:  BZ    1B02
.................... 		{ 
.................... 			if(number <= lo_lim) {number = hi_lim;} else {number--;} 
01AF0:  MOVLB  2
01AF2:  MOVF   xF6,W
01AF4:  SUBWF  xF5,W
01AF6:  BNC   1AFE
01AF8:  MOVFF  2F4,2F6
01AFC:  BRA    1B00
01AFE:  DECF   xF6,F
01B00:  MOVLB  0
.................... 		} 
.................... 		if(chk_ent()) 
01B02:  CALL   0EBA
01B06:  MOVF   01,F
01B08:  BZ    1B62
.................... 		{	//done 
.................... 			display_ram[line][col] = digit1; 
01B0A:  MOVLB  2
01B0C:  MOVF   xF7,W
01B0E:  MULLW  15
01B10:  MOVF   FF3,W
01B12:  CLRF   xFD
01B14:  MOVWF  xFC
01B16:  CLRF   03
01B18:  MOVF   xF8,W
01B1A:  ADDWF  xFC,W
01B1C:  MOVWF  01
01B1E:  MOVF   xFD,W
01B20:  ADDWFC 03,F
01B22:  MOVF   01,W
01B24:  ADDLW  D6
01B26:  MOVWF  FE9
01B28:  MOVLW  00
01B2A:  ADDWFC 03,W
01B2C:  MOVWF  FEA
01B2E:  MOVFF  2F9,FEF
.................... 			display_ram[line][col+1] = digit2; 
01B32:  MOVF   xF7,W
01B34:  MULLW  15
01B36:  MOVF   FF3,W
01B38:  CLRF   xFD
01B3A:  MOVWF  xFC
01B3C:  MOVLW  01
01B3E:  ADDWF  xF8,W
01B40:  CLRF   03
01B42:  ADDWF  xFC,W
01B44:  MOVWF  01
01B46:  MOVF   xFD,W
01B48:  ADDWFC 03,F
01B4A:  MOVF   01,W
01B4C:  ADDLW  D6
01B4E:  MOVWF  FE9
01B50:  MOVLW  00
01B52:  ADDWFC 03,W
01B54:  MOVWF  FEA
01B56:  MOVFF  2FA,FEF
.................... 			return number; 
01B5A:  MOVFF  2F6,01
01B5E:  BRA    1C48
01B60:  MOVLB  0
.................... 		}	 
.................... 		flash_timer++; 
01B62:  MOVLB  2
01B64:  INCF   xFB,F
.................... 		if(flash_timer > 50) flash_timer = 0; 
01B66:  MOVF   xFB,W
01B68:  SUBLW  32
01B6A:  BC    1B6E
01B6C:  CLRF   xFB
.................... 		if(flash_timer < 25) 
01B6E:  MOVF   xFB,W
01B70:  SUBLW  18
01B72:  BNC   1BC4
.................... 		{ 
.................... 			display_ram[line][col] = ' '; 
01B74:  MOVF   xF7,W
01B76:  MULLW  15
01B78:  MOVF   FF3,W
01B7A:  CLRF   xFD
01B7C:  MOVWF  xFC
01B7E:  CLRF   03
01B80:  MOVF   xF8,W
01B82:  ADDWF  xFC,W
01B84:  MOVWF  01
01B86:  MOVF   xFD,W
01B88:  ADDWFC 03,F
01B8A:  MOVF   01,W
01B8C:  ADDLW  D6
01B8E:  MOVWF  FE9
01B90:  MOVLW  00
01B92:  ADDWFC 03,W
01B94:  MOVWF  FEA
01B96:  MOVLW  20
01B98:  MOVWF  FEF
.................... 			display_ram[line][col+1] = ' '; 
01B9A:  MOVF   xF7,W
01B9C:  MULLW  15
01B9E:  MOVF   FF3,W
01BA0:  CLRF   xFD
01BA2:  MOVWF  xFC
01BA4:  MOVLW  01
01BA6:  ADDWF  xF8,W
01BA8:  CLRF   03
01BAA:  ADDWF  xFC,W
01BAC:  MOVWF  01
01BAE:  MOVF   xFD,W
01BB0:  ADDWFC 03,F
01BB2:  MOVF   01,W
01BB4:  ADDLW  D6
01BB6:  MOVWF  FE9
01BB8:  MOVLW  00
01BBA:  ADDWFC 03,W
01BBC:  MOVWF  FEA
01BBE:  MOVLW  20
01BC0:  MOVWF  FEF
.................... 		} 
01BC2:  BRA    1C3A
.................... 		else 
.................... 		{ 
.................... 			//convert to display digits and set in display ram. 
.................... 			digit1 = (number/10) + '0'; 
01BC4:  MOVFF  2F6,2FC
01BC8:  MOVLW  0A
01BCA:  MOVWF  xFD
01BCC:  MOVLB  0
01BCE:  RCALL  1A82
01BD0:  MOVLW  30
01BD2:  ADDWF  01,W
01BD4:  MOVLB  2
01BD6:  MOVWF  xF9
.................... 			display_ram[line][col] = digit1; 
01BD8:  MOVF   xF7,W
01BDA:  MULLW  15
01BDC:  MOVF   FF3,W
01BDE:  CLRF   xFD
01BE0:  MOVWF  xFC
01BE2:  CLRF   03
01BE4:  MOVF   xF8,W
01BE6:  ADDWF  xFC,W
01BE8:  MOVWF  01
01BEA:  MOVF   xFD,W
01BEC:  ADDWFC 03,F
01BEE:  MOVF   01,W
01BF0:  ADDLW  D6
01BF2:  MOVWF  FE9
01BF4:  MOVLW  00
01BF6:  ADDWFC 03,W
01BF8:  MOVWF  FEA
01BFA:  MOVFF  2F9,FEF
.................... 			digit2 = number; 
01BFE:  MOVFF  2F6,2FA
.................... 			while (digit2 > 9) 
01C02:  MOVF   xFA,W
01C04:  SUBLW  09
01C06:  BC    1C0E
.................... 			{ 
.................... 				digit2 = digit2 -10; 
01C08:  MOVLW  0A
01C0A:  SUBWF  xFA,F
01C0C:  BRA    1C02
.................... 			} 
.................... 			digit2 = digit2 + '0'; 
01C0E:  MOVLW  30
01C10:  ADDWF  xFA,F
.................... 			display_ram[line][col+1] = digit2; 
01C12:  MOVF   xF7,W
01C14:  MULLW  15
01C16:  MOVF   FF3,W
01C18:  CLRF   xFD
01C1A:  MOVWF  xFC
01C1C:  MOVLW  01
01C1E:  ADDWF  xF8,W
01C20:  CLRF   03
01C22:  ADDWF  xFC,W
01C24:  MOVWF  01
01C26:  MOVF   xFD,W
01C28:  ADDWFC 03,F
01C2A:  MOVF   01,W
01C2C:  ADDLW  D6
01C2E:  MOVWF  FE9
01C30:  MOVLW  00
01C32:  ADDWFC 03,W
01C34:  MOVWF  FEA
01C36:  MOVFF  2FA,FEF
.................... 		}			 
.................... 		delay_ms(20); 
01C3A:  MOVLW  14
01C3C:  MOVWF  xFC
01C3E:  MOVLB  0
01C40:  CALL   0BF4
01C44:  BRA    1AD0
01C46:  MOVLB  2
.................... 	} 
01C48:  MOVLB  0
01C4A:  RETURN 0
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................   
.................... /**************************************************************************** 
.................... * File Name: LooWatt Attendant_MAIN 
.................... * Purpose: 
.................... *      MAIN application program.          
.................... * Parameters Passed:  
.................... * Parameters Returned:  
.................... * Globals: 
.................... * Date Started    10/05/2015 
.................... * Last Edit/By   28/02/2016   Code re-written by PH 
.................... * Version      Not released 
.................... ****************************************************************************/   
.................... void main (void) 
*
03F40:  CLRF   FF8
03F42:  BCF    FD0.7
03F44:  BSF    07.7
03F46:  SETF   xA4
03F48:  SETF   xA5
03F4A:  CLRF   xD5
03F4C:  MOVLB  1
03F4E:  CLRF   x55
03F50:  MOVLW  13
03F52:  MOVLB  F
03F54:  MOVWF  x01
03F56:  MOVLW  28
03F58:  MOVLB  E
03F5A:  MOVWF  xFF
03F5C:  MOVLB  F
03F5E:  BSF    x00.7
03F60:  BCF    x00.6
03F62:  MOVLB  1
03F64:  CLRF   x57
03F66:  CLRF   x59
03F68:  CLRF   x5B
03F6A:  CLRF   x5D
03F6C:  MOVLB  E
03F6E:  CLRF   xF4
03F70:  CLRF   xF5
03F72:  CLRF   xF6
03F74:  MOVLW  00
03F76:  MOVLB  F
03F78:  MOVWF  x23
03F7A:  MOVWF  x24
03F7C:  MOVWF  x25
03F7E:  BCF    FC1.3
03F80:  BCF    FC1.4
03F82:  BCF    FC1.5
03F84:  CLRF   x2E
03F86:  CLRF   x2F
03F88:  CLRF   x54
03F8A:  CLRF   1A
03F8C:  CLRF   1B
03F8E:  MOVLB  1
03F90:  CLRF   x56
03F92:  CLRF   x58
03F94:  CLRF   x5A
03F96:  CLRF   x5C
03F98:  CLRF   x5E
03F9A:  CLRF   x5F
03F9C:  CLRF   x60
03F9E:  CLRF   x61
03FA0:  CLRF   x62
03FA2:  CLRF   x63
03FA4:  CLRF   x64
03FA6:  CLRF   x65
03FA8:  CLRF   x66
03FAA:  CLRF   x67
03FAC:  CLRF   x68
03FAE:  CLRF   x69
03FB0:  CLRF   x80
03FB2:  CLRF   x81
03FB4:  CLRF   xA1
.................... { 
....................    extern union LOG_UNION DATA_IN[Max_no_LOOS]; 
....................    extern union LOG_UNION *pDATA_IN; 
....................    extern char TRAILER_ID;  
....................    extern int8 FLASH_REG[2]; 
....................    extern int8 ALARM_FLAG; 
....................    extern int8 FLASH_FLAG; 
....................    extern int8 target_USB; 
....................    extern int8 no_of_loos; 
....................    extern int8 max_scroll_offset; 
....................    extern int8 *Ploo[11]; 
....................    extern int8 Loo_FREG[11]; 
....................    int8 FLT_LOG[11],PLT_LOG[11]; 
....................    extern int8 Loo_FL[11]; 
....................    int8 MUTED_FLAG = 0; 
....................    int8 NEW_ALARM = 0; 
....................    int8 loo; 
....................    char text[20],FLSH_REM[4]; 
....................    int16 value16; 
....................    int32 value32; 
....................    int8 WEB_TO = 0; 
....................  
....................    INIT_ALL(); 
03FB6:  MOVLB  0
03FB8:  GOTO   0B18
....................    INIT_USART1(); 
03FBC:  CALL   0BC8
....................    INIT_USART2(); 
03FC0:  GOTO   0BDA
....................  
....................    init_display(); 
03FC4:  GOTO   0C1C
....................    FLASH_REG[0] = 0; 
03FC8:  CLRF   x9E
....................    FLASH_REG[1] = 0; 
03FCA:  CLRF   x9F
....................    ALARM_FLAG = 0; 
03FCC:  CLRF   xA1
....................    FLASH_FLAG = 0; 
03FCE:  CLRF   xA2
....................     
....................    menu_sys(); 
03FD0:  GOTO   1FF2
....................    TRAILER_ID = read_eeprom(trailer_addr); 
03FD4:  MOVFF  FF2,1A2
03FD8:  BCF    FF2.7
03FDA:  CLRF   F63
03FDC:  CLRF   F62
03FDE:  BCF    F7F.6
03FE0:  BCF    F7F.7
03FE2:  BSF    F7F.0
03FE4:  MOVF   F61,W
03FE6:  MOVLB  1
03FE8:  BTFSC  xA2.7
03FEA:  BSF    FF2.7
03FEC:  MOVLB  0
03FEE:  MOVWF  xA6
....................    if(TRAILER_ID < 'A') TRAILER_ID = 'Z'; 
03FF0:  MOVF   xA6,W
03FF2:  SUBLW  40
03FF4:  BNC   3FFA
03FF6:  MOVLW  5A
03FF8:  MOVWF  xA6
....................    if(TRAILER_ID > 'Z') TRAILER_ID = 'A'; 
03FFA:  MOVF   xA6,W
03FFC:  SUBLW  5A
03FFE:  BC    4004
04000:  MOVLW  41
04002:  MOVWF  xA6
....................  
....................    set_init_mess();   //also checks for the USB device. 
04004:  GOTO   2088
....................    no_of_loos = read_eeprom(no_of_units); 
04008:  MOVFF  FF2,1A2
0400C:  BCF    FF2.7
0400E:  CLRF   F63
04010:  MOVLW  01
04012:  MOVWF  F62
04014:  BCF    F7F.6
04016:  BCF    F7F.7
04018:  BSF    F7F.0
0401A:  MOVF   F61,W
0401C:  MOVLB  1
0401E:  BTFSC  xA2.7
04020:  BSF    FF2.7
04022:  MOVLB  0
04024:  MOVWF  xA7
....................    initalise_USB_files(TRAILER_ID); 
04026:  MOVFF  A6,250
0402A:  GOTO   24A0
....................    set_run_display_ram(); 
0402E:  GOTO   273C
....................    for(loo = 1;loo < 11;loo++) 
04032:  MOVLW  01
04034:  MOVLB  1
04036:  MOVWF  x82
04038:  MOVF   x82,W
0403A:  SUBLW  0A
0403C:  BNC   4052
....................    { 
....................       FLT_LOG[loo] = 0; 
0403E:  CLRF   03
04040:  MOVF   x82,W
04042:  ADDLW  6A
04044:  MOVWF  FE9
04046:  MOVLW  01
04048:  ADDWFC 03,W
0404A:  MOVWF  FEA
0404C:  CLRF   FEF
0404E:  INCF   x82,F
04050:  BRA    4038
....................    } 
....................    PLT_LOG[0] = 0xFF;      // a flag to detect first time through loop. 
04052:  SETF   x75
....................  
....................    target_USB = RESET_TO; 
04054:  MOVLB  0
04056:  SETF   xA4
....................    for( ; ; ) 
....................    { 
....................       loo = 1; 
04058:  MOVLW  01
0405A:  MOVLB  1
0405C:  MOVWF  x82
....................       //first get all the active loo's data, and set alarms as required. 
....................       do 
....................       { 
....................          pDATA_IN = &DATA_IN[loo];   //get correct loo data 
0405E:  MOVF   x82,W
04060:  MULLW  14
04062:  MOVF   FF3,W
04064:  CLRF   03
04066:  ADDLW  24
04068:  MOVWF  01
0406A:  MOVLW  00
0406C:  ADDWFC 03,F
0406E:  MOVFF  01,9C
04072:  MOVLB  0
04074:  MOVFF  03,9D
....................  
....................          //Check for key presses etc... 
....................          if(chk_ent())  
04078:  CALL   0EBA
0407C:  MOVF   01,F
0407E:  BZ    408A
....................          { 
....................             MUTED_FLAG = 1; 
04080:  MOVLW  01
04082:  MOVLB  1
04084:  MOVWF  x80
....................             NEW_ALARM = 0; 
04086:  CLRF   x81
04088:  MOVLB  0
....................          } 
....................          if(chk_up()) 
0408A:  CALL   0E5E
0408E:  MOVF   01,F
04090:  BZ    4098
....................          {   //scroll up 
....................             if(scroll_offset != 0) scroll_offset--; 
04092:  MOVF   xA0,F
04094:  BZ    4098
04096:  DECF   xA0,F
....................  
....................          } 
....................          if(chk_dn()) 
04098:  CALL   0E8C
0409C:  MOVF   01,F
0409E:  BZ    40AC
....................          {   //scroll up 
....................             scroll_offset++; 
040A0:  INCF   xA0,F
....................             if(scroll_offset > max_scroll_offset) scroll_offset = max_scroll_offset; 
040A2:  MOVF   xA0,W
040A4:  SUBWF  xA8,W
040A6:  BTFSS  FD8.0
040A8:  MOVFF  A8,A0
....................          } 
....................          delay_ms(50); 
040AC:  MOVLW  32
040AE:  MOVLB  2
040B0:  MOVWF  xFC
040B2:  MOVLB  0
040B4:  CALL   0BF4
....................          FLASHING_OFF 
040B8:  BCF    F9D.1
....................          if(!send_RS485(SND_DATA,loo)) 
040BA:  MOVLW  2D
040BC:  MOVLB  2
040BE:  MOVWF  xF4
040C0:  MOVFF  182,2F5
040C4:  MOVLB  0
040C6:  CALL   11EC
040CA:  MOVF   01,F
040CC:  BTFSS  FD8.2
040CE:  BRA    41E2
....................          {   //This loo has a comms error, ignore everything else  
....................             FLT_LOG[loo] = ERR_BIT; 
040D0:  CLRF   03
040D2:  MOVLB  1
040D4:  MOVF   x82,W
040D6:  ADDLW  6A
040D8:  MOVWF  FE9
040DA:  MOVLW  01
040DC:  ADDWFC 03,W
040DE:  MOVWF  FEA
040E0:  MOVLW  08
040E2:  MOVWF  FEF
....................             (*(pLoo[loo] + flash_col)) = 'E'; 
040E4:  CLRF   03
040E6:  MOVFF  182,02
040EA:  BCF    FD8.0
040EC:  RLCF   02,F
040EE:  RLCF   03,F
040F0:  MOVF   02,W
040F2:  ADDLW  A9
040F4:  MOVWF  FE9
040F6:  MOVLW  00
040F8:  ADDWFC 03,W
040FA:  MOVWF  FEA
040FC:  MOVFF  FEC,1A3
04100:  MOVF   FED,F
04102:  MOVFF  FEF,1A2
04106:  MOVLW  06
04108:  ADDWF  xA2,W
0410A:  MOVWF  01
0410C:  MOVLW  00
0410E:  ADDWFC xA3,W
04110:  MOVFF  01,FE9
04114:  MOVWF  FEA
04116:  MOVLW  45
04118:  MOVWF  FEF
....................             (*(pLoo[loo] + flash_col+1)) = 'R'; 
0411A:  CLRF   03
0411C:  MOVFF  182,02
04120:  BCF    FD8.0
04122:  RLCF   02,F
04124:  RLCF   03,F
04126:  MOVF   02,W
04128:  ADDLW  A9
0412A:  MOVWF  FE9
0412C:  MOVLW  00
0412E:  ADDWFC 03,W
04130:  MOVWF  FEA
04132:  MOVFF  FEC,1A3
04136:  MOVF   FED,F
04138:  MOVFF  FEF,1A2
0413C:  MOVLW  06
0413E:  ADDWF  xA2,F
04140:  MOVLW  00
04142:  ADDWFC xA3,F
04144:  MOVLW  01
04146:  ADDWF  xA2,W
04148:  MOVWF  01
0414A:  MOVLW  00
0414C:  ADDWFC xA3,W
0414E:  MOVFF  01,FE9
04152:  MOVWF  FEA
04154:  MOVLW  52
04156:  MOVWF  FEF
....................             (*(pLoo[loo] + flash_col+2)) = 'R'; 
04158:  CLRF   03
0415A:  MOVFF  182,02
0415E:  BCF    FD8.0
04160:  RLCF   02,F
04162:  RLCF   03,F
04164:  MOVF   02,W
04166:  ADDLW  A9
04168:  MOVWF  FE9
0416A:  MOVLW  00
0416C:  ADDWFC 03,W
0416E:  MOVWF  FEA
04170:  MOVFF  FEC,1A3
04174:  MOVF   FED,F
04176:  MOVFF  FEF,1A2
0417A:  MOVLW  06
0417C:  ADDWF  xA2,F
0417E:  MOVLW  00
04180:  ADDWFC xA3,F
04182:  MOVLW  02
04184:  ADDWF  xA2,W
04186:  MOVWF  01
04188:  MOVLW  00
0418A:  ADDWFC xA3,W
0418C:  MOVFF  01,FE9
04190:  MOVWF  FEA
04192:  MOVLW  52
04194:  MOVWF  FEF
....................             if(!MUTED_FLAG) FLASH_REG[Loo_FREG[loo]] = Loo_FL[loo]; 
04196:  MOVF   x80,F
04198:  BNZ   41D6
0419A:  CLRF   03
0419C:  MOVF   x82,W
0419E:  ADDLW  BF
041A0:  MOVWF  FE9
041A2:  MOVLW  00
041A4:  ADDWFC 03,W
041A6:  MOVWF  FEA
041A8:  CLRF   03
041AA:  MOVF   FEF,W
041AC:  ADDLW  9E
041AE:  MOVWF  01
041B0:  MOVLW  00
041B2:  ADDWFC 03,F
041B4:  MOVFF  03,1A3
041B8:  CLRF   03
041BA:  MOVF   x82,W
041BC:  ADDLW  CA
041BE:  MOVWF  FE9
041C0:  MOVLW  00
041C2:  ADDWFC 03,W
041C4:  MOVWF  FEA
041C6:  MOVFF  FEF,1A4
041CA:  MOVFF  1A3,FEA
041CE:  MOVFF  01,FE9
041D2:  MOVFF  1A4,FEF
....................             FLASHING_ON 
041D6:  BCF    F9E.1
041D8:  CLRF   FCC
041DA:  BSF    F9D.1
....................          } 
041DC:  GOTO   4B20
041E0:  MOVLB  0
....................          else 
....................          { 
....................             FLT_LOG[loo] &= ~ERR_BIT; 
041E2:  CLRF   03
041E4:  MOVLB  1
041E6:  MOVF   x82,W
041E8:  ADDLW  6A
041EA:  MOVWF  FE9
041EC:  MOVLW  01
041EE:  ADDWFC 03,W
041F0:  MOVWF  FEA
041F2:  MOVF   FEF,W
041F4:  ANDLW  F7
041F6:  MOVWF  FEF
....................             (*(pLoo[loo] + flash_col)) = ' '; 
041F8:  CLRF   03
041FA:  MOVFF  182,02
041FE:  BCF    FD8.0
04200:  RLCF   02,F
04202:  RLCF   03,F
04204:  MOVF   02,W
04206:  ADDLW  A9
04208:  MOVWF  FE9
0420A:  MOVLW  00
0420C:  ADDWFC 03,W
0420E:  MOVWF  FEA
04210:  MOVFF  FEC,1A3
04214:  MOVF   FED,F
04216:  MOVFF  FEF,1A2
0421A:  MOVLW  06
0421C:  ADDWF  xA2,W
0421E:  MOVWF  01
04220:  MOVLW  00
04222:  ADDWFC xA3,W
04224:  MOVFF  01,FE9
04228:  MOVWF  FEA
0422A:  MOVLW  20
0422C:  MOVWF  FEF
....................             (*(pLoo[loo] + flash_col+1)) = ' '; 
0422E:  CLRF   03
04230:  MOVFF  182,02
04234:  BCF    FD8.0
04236:  RLCF   02,F
04238:  RLCF   03,F
0423A:  MOVF   02,W
0423C:  ADDLW  A9
0423E:  MOVWF  FE9
04240:  MOVLW  00
04242:  ADDWFC 03,W
04244:  MOVWF  FEA
04246:  MOVFF  FEC,1A3
0424A:  MOVF   FED,F
0424C:  MOVFF  FEF,1A2
04250:  MOVLW  06
04252:  ADDWF  xA2,F
04254:  MOVLW  00
04256:  ADDWFC xA3,F
04258:  MOVLW  01
0425A:  ADDWF  xA2,W
0425C:  MOVWF  01
0425E:  MOVLW  00
04260:  ADDWFC xA3,W
04262:  MOVFF  01,FE9
04266:  MOVWF  FEA
04268:  MOVLW  20
0426A:  MOVWF  FEF
....................             (*(pLoo[loo] + flash_col+2)) = ' '; 
0426C:  CLRF   03
0426E:  MOVFF  182,02
04272:  BCF    FD8.0
04274:  RLCF   02,F
04276:  RLCF   03,F
04278:  MOVF   02,W
0427A:  ADDLW  A9
0427C:  MOVWF  FE9
0427E:  MOVLW  00
04280:  ADDWFC 03,W
04282:  MOVWF  FEA
04284:  MOVFF  FEC,1A3
04288:  MOVF   FED,F
0428A:  MOVFF  FEF,1A2
0428E:  MOVLW  06
04290:  ADDWF  xA2,F
04292:  MOVLW  00
04294:  ADDWFC xA3,F
04296:  MOVLW  02
04298:  ADDWF  xA2,W
0429A:  MOVWF  01
0429C:  MOVLW  00
0429E:  ADDWFC xA3,W
042A0:  MOVFF  01,FE9
042A4:  MOVWF  FEA
042A6:  MOVLW  20
042A8:  MOVWF  FEF
....................             FLASHING_ON 
042AA:  BCF    F9E.1
042AC:  CLRF   FCC
042AE:  BSF    F9D.1
....................             //calculate flushes left, and any error messages 
....................             if((pDATA_IN->LooSTATUS & OOSERVICE) == OOSERVICE) 
042B0:  MOVLB  0
042B2:  MOVFF  9C,FE9
042B6:  MOVFF  9D,FEA
042BA:  MOVFF  FEC,1A3
042BE:  MOVF   FED,F
042C0:  MOVFF  FEF,1A2
042C4:  MOVLW  04
042C6:  MOVLB  1
042C8:  ANDWF  xA2,F
042CA:  CLRF   xA3
042CC:  MOVF   xA2,W
042CE:  SUBLW  04
042D0:  BTFSS  FD8.2
042D2:  BRA    4440
042D4:  MOVF   xA3,F
042D6:  BTFSS  FD8.2
042D8:  BRA    4440
....................             { 
....................  
....................                (*(pLoo[loo] + flash_col)) = 'O'; 
042DA:  CLRF   03
042DC:  MOVFF  182,02
042E0:  BCF    FD8.0
042E2:  RLCF   02,F
042E4:  RLCF   03,F
042E6:  MOVF   02,W
042E8:  ADDLW  A9
042EA:  MOVWF  FE9
042EC:  MOVLW  00
042EE:  ADDWFC 03,W
042F0:  MOVWF  FEA
042F2:  MOVFF  FEC,1A3
042F6:  MOVF   FED,F
042F8:  MOVFF  FEF,1A2
042FC:  MOVLW  06
042FE:  ADDWF  xA2,W
04300:  MOVWF  01
04302:  MOVLW  00
04304:  ADDWFC xA3,W
04306:  MOVFF  01,FE9
0430A:  MOVWF  FEA
0430C:  MOVLW  4F
0430E:  MOVWF  FEF
....................                (*(pLoo[loo] + flash_col+1)) = 'F'; 
04310:  CLRF   03
04312:  MOVFF  182,02
04316:  BCF    FD8.0
04318:  RLCF   02,F
0431A:  RLCF   03,F
0431C:  MOVF   02,W
0431E:  ADDLW  A9
04320:  MOVWF  FE9
04322:  MOVLW  00
04324:  ADDWFC 03,W
04326:  MOVWF  FEA
04328:  MOVFF  FEC,1A3
0432C:  MOVF   FED,F
0432E:  MOVFF  FEF,1A2
04332:  MOVLW  06
04334:  ADDWF  xA2,F
04336:  MOVLW  00
04338:  ADDWFC xA3,F
0433A:  MOVLW  01
0433C:  ADDWF  xA2,W
0433E:  MOVWF  01
04340:  MOVLW  00
04342:  ADDWFC xA3,W
04344:  MOVFF  01,FE9
04348:  MOVWF  FEA
0434A:  MOVLW  46
0434C:  MOVWF  FEF
....................                (*(pLoo[loo] + flash_col+2)) = 'F'; 
0434E:  CLRF   03
04350:  MOVFF  182,02
04354:  BCF    FD8.0
04356:  RLCF   02,F
04358:  RLCF   03,F
0435A:  MOVF   02,W
0435C:  ADDLW  A9
0435E:  MOVWF  FE9
04360:  MOVLW  00
04362:  ADDWFC 03,W
04364:  MOVWF  FEA
04366:  MOVFF  FEC,1A3
0436A:  MOVF   FED,F
0436C:  MOVFF  FEF,1A2
04370:  MOVLW  06
04372:  ADDWF  xA2,F
04374:  MOVLW  00
04376:  ADDWFC xA3,F
04378:  MOVLW  02
0437A:  ADDWF  xA2,W
0437C:  MOVWF  01
0437E:  MOVLW  00
04380:  ADDWFC xA3,W
04382:  MOVFF  01,FE9
04386:  MOVWF  FEA
04388:  MOVLW  46
0438A:  MOVWF  FEF
....................                (*(PLoo[loo] + flush_rem_col)) = '-'; 
0438C:  CLRF   03
0438E:  MOVFF  182,02
04392:  BCF    FD8.0
04394:  RLCF   02,F
04396:  RLCF   03,F
04398:  MOVF   02,W
0439A:  ADDLW  A9
0439C:  MOVWF  FE9
0439E:  MOVLW  00
043A0:  ADDWFC 03,W
043A2:  MOVWF  FEA
043A4:  MOVFF  FEC,1A3
043A8:  MOVF   FED,F
043AA:  MOVFF  FEF,1A2
043AE:  MOVLW  02
043B0:  ADDWF  xA2,W
043B2:  MOVWF  01
043B4:  MOVLW  00
043B6:  ADDWFC xA3,W
043B8:  MOVFF  01,FE9
043BC:  MOVWF  FEA
043BE:  MOVLW  2D
043C0:  MOVWF  FEF
....................                (*(PLoo[loo] + flush_rem_col + 1)) = '-'; 
043C2:  CLRF   03
043C4:  MOVFF  182,02
043C8:  BCF    FD8.0
043CA:  RLCF   02,F
043CC:  RLCF   03,F
043CE:  MOVF   02,W
043D0:  ADDLW  A9
043D2:  MOVWF  FE9
043D4:  MOVLW  00
043D6:  ADDWFC 03,W
043D8:  MOVWF  FEA
043DA:  MOVFF  FEC,1A3
043DE:  MOVF   FED,F
043E0:  MOVFF  FEF,1A2
043E4:  MOVLW  02
043E6:  ADDWF  xA2,F
043E8:  MOVLW  00
043EA:  ADDWFC xA3,F
043EC:  MOVLW  01
043EE:  ADDWF  xA2,W
043F0:  MOVWF  01
043F2:  MOVLW  00
043F4:  ADDWFC xA3,W
043F6:  MOVFF  01,FE9
043FA:  MOVWF  FEA
043FC:  MOVLW  2D
043FE:  MOVWF  FEF
....................                (*(PLoo[loo] + flush_rem_col + 2 )) = '-'; 
04400:  CLRF   03
04402:  MOVFF  182,02
04406:  BCF    FD8.0
04408:  RLCF   02,F
0440A:  RLCF   03,F
0440C:  MOVF   02,W
0440E:  ADDLW  A9
04410:  MOVWF  FE9
04412:  MOVLW  00
04414:  ADDWFC 03,W
04416:  MOVWF  FEA
04418:  MOVFF  FEC,1A3
0441C:  MOVF   FED,F
0441E:  MOVFF  FEF,1A2
04422:  MOVLW  02
04424:  ADDWF  xA2,F
04426:  MOVLW  00
04428:  ADDWFC xA3,F
0442A:  MOVLW  02
0442C:  ADDWF  xA2,W
0442E:  MOVWF  01
04430:  MOVLW  00
04432:  ADDWFC xA3,W
04434:  MOVFF  01,FE9
04438:  MOVWF  FEA
0443A:  MOVLW  2D
0443C:  MOVWF  FEF
....................             } 
0443E:  BRA    4B20
....................             else 
....................             { 
....................  
....................             //   value32 = (10*((int32)pDATA_IN->BAG_LEFT))/866;      //86.6 = flush length: Changed PH 05/05/18 
.................... value32 = (10*((int32)pDATA_IN->BAG_LEFT))/670; 
04440:  MOVLW  10
04442:  MOVLB  0
04444:  ADDWF  x9C,W
04446:  MOVWF  FE9
04448:  MOVLW  00
0444A:  ADDWFC x9D,W
0444C:  MOVWF  FEA
0444E:  MOVFF  FEC,03
04452:  MOVF   FED,F
04454:  MOVFF  FEF,00
04458:  MOVFF  03,01
0445C:  CLRF   02
0445E:  CLRF   03
04460:  MOVFF  03,1A5
04464:  MOVFF  02,1A4
04468:  MOVFF  01,1A3
0446C:  MOVFF  00,1A2
04470:  MOVFF  FEA,1A7
04474:  MOVFF  FE9,1A6
04478:  MOVLB  2
0447A:  CLRF   xF1
0447C:  CLRF   xF0
0447E:  CLRF   xEF
04480:  MOVLW  0A
04482:  MOVWF  xEE
04484:  MOVFF  03,2F5
04488:  MOVFF  02,2F4
0448C:  MOVFF  01,2F3
04490:  MOVFF  00,2F2
04494:  MOVLB  0
04496:  CALL   29D2
0449A:  MOVFF  1A7,FEA
0449E:  MOVFF  1A6,FE9
044A2:  MOVFF  03,1A5
044A6:  MOVFF  02,1A4
044AA:  MOVFF  01,1A3
044AE:  MOVFF  00,1A2
044B2:  MOVFF  FEA,1A9
044B6:  MOVFF  FE9,1A8
044BA:  BCF    FD8.1
044BC:  MOVFF  03,25B
044C0:  MOVFF  02,25A
044C4:  MOVFF  01,259
044C8:  MOVFF  00,258
044CC:  MOVLB  2
044CE:  CLRF   x5F
044D0:  CLRF   x5E
044D2:  MOVLW  02
044D4:  MOVWF  x5D
044D6:  MOVLW  9E
044D8:  MOVWF  x5C
044DA:  MOVLB  0
044DC:  GOTO   2A2E
044E0:  MOVFF  1A9,FEA
044E4:  MOVFF  1A8,FE9
044E8:  MOVFF  03,1A0
044EC:  MOVFF  02,19F
044F0:  MOVFF  01,19E
044F4:  MOVFF  00,19D
....................                value16 = (int16)value32; 
044F8:  MOVFF  19E,19C
044FC:  MOVFF  19D,19B
....................  
....................                if(!(FLT_LOG[loo] & ERR_BIT))  
04500:  CLRF   03
04502:  MOVLB  1
04504:  MOVF   x82,W
04506:  ADDLW  6A
04508:  MOVWF  FE9
0450A:  MOVLW  01
0450C:  ADDWFC 03,W
0450E:  MOVWF  FEA
04510:  BTFSC  FEF.3
04512:  BRA    45E0
....................                { 
....................                   convert_to_3digits (value16,&FLSH_REM); 
04514:  MOVFF  19C,251
04518:  MOVFF  19B,250
0451C:  MOVLW  01
0451E:  MOVLB  2
04520:  MOVWF  x53
04522:  MOVLW  97
04524:  MOVWF  x52
04526:  MOVLB  0
04528:  GOTO   2AC4
....................                   (*(PLoo[loo] + flush_rem_col)) = FLSH_REM[0]; 
0452C:  CLRF   03
0452E:  MOVLB  1
04530:  MOVFF  182,02
04534:  BCF    FD8.0
04536:  RLCF   02,F
04538:  RLCF   03,F
0453A:  MOVF   02,W
0453C:  ADDLW  A9
0453E:  MOVWF  FE9
04540:  MOVLW  00
04542:  ADDWFC 03,W
04544:  MOVWF  FEA
04546:  MOVFF  FEC,1A3
0454A:  MOVF   FED,F
0454C:  MOVFF  FEF,1A2
04550:  MOVLW  02
04552:  ADDWF  xA2,W
04554:  MOVWF  01
04556:  MOVLW  00
04558:  ADDWFC xA3,W
0455A:  MOVFF  01,FE9
0455E:  MOVWF  FEA
04560:  MOVFF  197,FEF
....................                   (*(PLoo[loo] + flush_rem_col + 1)) = FLSH_REM[1]; 
04564:  CLRF   03
04566:  MOVFF  182,02
0456A:  BCF    FD8.0
0456C:  RLCF   02,F
0456E:  RLCF   03,F
04570:  MOVF   02,W
04572:  ADDLW  A9
04574:  MOVWF  FE9
04576:  MOVLW  00
04578:  ADDWFC 03,W
0457A:  MOVWF  FEA
0457C:  MOVFF  FEC,1A3
04580:  MOVF   FED,F
04582:  MOVFF  FEF,1A2
04586:  MOVLW  02
04588:  ADDWF  xA2,F
0458A:  MOVLW  00
0458C:  ADDWFC xA3,F
0458E:  MOVLW  01
04590:  ADDWF  xA2,W
04592:  MOVWF  01
04594:  MOVLW  00
04596:  ADDWFC xA3,W
04598:  MOVFF  01,FE9
0459C:  MOVWF  FEA
0459E:  MOVFF  198,FEF
....................                   (*(PLoo[loo] + flush_rem_col + 2 )) = FLSH_REM[2]; 
045A2:  CLRF   03
045A4:  MOVFF  182,02
045A8:  BCF    FD8.0
045AA:  RLCF   02,F
045AC:  RLCF   03,F
045AE:  MOVF   02,W
045B0:  ADDLW  A9
045B2:  MOVWF  FE9
045B4:  MOVLW  00
045B6:  ADDWFC 03,W
045B8:  MOVWF  FEA
045BA:  MOVFF  FEC,1A3
045BE:  MOVF   FED,F
045C0:  MOVFF  FEF,1A2
045C4:  MOVLW  02
045C6:  ADDWF  xA2,F
045C8:  MOVLW  00
045CA:  ADDWFC xA3,F
045CC:  MOVLW  02
045CE:  ADDWF  xA2,W
045D0:  MOVWF  01
045D2:  MOVLW  00
045D4:  ADDWFC xA3,W
045D6:  MOVFF  01,FE9
045DA:  MOVWF  FEA
045DC:  MOVFF  199,FEF
....................                } 
....................                if(((int8)pDATA_IN->LooSTATUS) & blockage) 
045E0:  MOVLB  0
045E2:  MOVFF  9C,FE9
045E6:  MOVFF  9D,FEA
045EA:  BTFSS  FEF.4
045EC:  BRA    4608
....................                { 
....................                   FLT_LOG[loo] |= BLK_BIT;    
045EE:  CLRF   03
045F0:  MOVLB  1
045F2:  MOVF   x82,W
045F4:  ADDLW  6A
045F6:  MOVWF  FE9
045F8:  MOVLW  01
045FA:  ADDWFC 03,W
045FC:  MOVWF  FEA
045FE:  MOVF   FEF,W
04600:  IORLW  04
04602:  MOVWF  FEF
....................                } 
04604:  BRA    461E
04606:  MOVLB  0
....................                else 
....................                { 
....................                   FLT_LOG[loo] &= ~BLK_BIT; 
04608:  CLRF   03
0460A:  MOVLB  1
0460C:  MOVF   x82,W
0460E:  ADDLW  6A
04610:  MOVWF  FE9
04612:  MOVLW  01
04614:  ADDWFC 03,W
04616:  MOVWF  FEA
04618:  MOVF   FEF,W
0461A:  ANDLW  FB
0461C:  MOVWF  FEF
....................                } 
....................                 if(((int8)pDATA_IN->LooSTATUS) & SERSTATE) 
0461E:  MOVLB  0
04620:  MOVFF  9C,FE9
04624:  MOVFF  9D,FEA
04628:  BTFSS  FEF.0
0462A:  BRA    4646
....................                { 
....................                   FLT_LOG[loo] |= SER_BIT; 
0462C:  CLRF   03
0462E:  MOVLB  1
04630:  MOVF   x82,W
04632:  ADDLW  6A
04634:  MOVWF  FE9
04636:  MOVLW  01
04638:  ADDWFC 03,W
0463A:  MOVWF  FEA
0463C:  MOVF   FEF,W
0463E:  IORLW  02
04640:  MOVWF  FEF
....................                } 
04642:  BRA    465C
04644:  MOVLB  0
....................                else 
....................                { 
....................                   FLT_LOG[loo] &= ~SER_BIT; 
04646:  CLRF   03
04648:  MOVLB  1
0464A:  MOVF   x82,W
0464C:  ADDLW  6A
0464E:  MOVWF  FE9
04650:  MOVLW  01
04652:  ADDWFC 03,W
04654:  MOVWF  FEA
04656:  MOVF   FEF,W
04658:  ANDLW  FD
0465A:  MOVWF  FEF
....................                } 
....................                if(((int8)pDATA_IN->LooSTATUS) & RUNSTATE) 
0465C:  MOVLB  0
0465E:  MOVFF  9C,FE9
04662:  MOVFF  9D,FEA
04666:  BTFSS  FEF.1
04668:  BRA    4684
....................                { 
....................                   FLT_LOG[loo] |= RUN_BIT; 
0466A:  CLRF   03
0466C:  MOVLB  1
0466E:  MOVF   x82,W
04670:  ADDLW  6A
04672:  MOVWF  FE9
04674:  MOVLW  01
04676:  ADDWFC 03,W
04678:  MOVWF  FEA
0467A:  MOVF   FEF,W
0467C:  IORLW  20
0467E:  MOVWF  FEF
....................                } 
04680:  BRA    469A
04682:  MOVLB  0
....................                else 
....................                { 
....................                   FLT_LOG[loo] &= ~RUN_BIT; 
04684:  CLRF   03
04686:  MOVLB  1
04688:  MOVF   x82,W
0468A:  ADDLW  6A
0468C:  MOVWF  FE9
0468E:  MOVLW  01
04690:  ADDWFC 03,W
04692:  MOVWF  FEA
04694:  MOVF   FEF,W
04696:  ANDLW  DF
04698:  MOVWF  FEF
....................                } 
....................                if(((int8)pDATA_IN->LooSTATUS) & LOW_FILM)   
0469A:  MOVLB  0
0469C:  MOVFF  9C,FE9
046A0:  MOVFF  9D,FEA
046A4:  BTFSS  FEF.3
046A6:  BRA    46C2
....................                { 
....................                   FLT_LOG[loo] |= LOW_BIT; 
046A8:  CLRF   03
046AA:  MOVLB  1
046AC:  MOVF   x82,W
046AE:  ADDLW  6A
046B0:  MOVWF  FE9
046B2:  MOVLW  01
046B4:  ADDWFC 03,W
046B6:  MOVWF  FEA
046B8:  MOVF   FEF,W
046BA:  IORLW  01
046BC:  MOVWF  FEF
....................                } 
046BE:  BRA    46D8
046C0:  MOVLB  0
....................                else 
....................                { 
....................                   FLT_LOG[loo] &= ~LOW_BIT; 
046C2:  CLRF   03
046C4:  MOVLB  1
046C6:  MOVF   x82,W
046C8:  ADDLW  6A
046CA:  MOVWF  FE9
046CC:  MOVLW  01
046CE:  ADDWFC 03,W
046D0:  MOVWF  FEA
046D2:  MOVF   FEF,W
046D4:  ANDLW  FE
046D6:  MOVWF  FEF
....................                } 
....................  
....................                //initialise PLT_LOG. 
....................                if(PLT_LOG[0] == 0xFF)  
046D8:  INCFSZ x75,W
046DA:  BRA    4716
....................                { 
....................                   PLT_LOG[loo] = FLT_LOG[loo]; 
046DC:  CLRF   03
046DE:  MOVF   x82,W
046E0:  ADDLW  75
046E2:  MOVWF  01
046E4:  MOVLW  01
046E6:  ADDWFC 03,F
046E8:  MOVFF  03,1A3
046EC:  CLRF   03
046EE:  MOVF   x82,W
046F0:  ADDLW  6A
046F2:  MOVWF  FE9
046F4:  MOVLW  01
046F6:  ADDWFC 03,W
046F8:  MOVWF  FEA
046FA:  MOVFF  FEF,1A4
046FE:  MOVFF  1A3,FEA
04702:  MOVFF  01,FE9
04706:  MOVFF  1A4,FEF
....................                   if(loo >= no_of_loos) PLT_LOG[0] = 0; 
0470A:  MOVLB  0
0470C:  MOVF   xA7,W
0470E:  MOVLB  1
04710:  SUBWF  x82,W
04712:  BNC   4716
04714:  CLRF   x75
....................                } 
....................                //now deal with any messages/faults, except COMMS 
....................                if(FLT_LOG[loo] & BLK_BIT) 
04716:  CLRF   03
04718:  MOVF   x82,W
0471A:  ADDLW  6A
0471C:  MOVWF  FE9
0471E:  MOVLW  01
04720:  ADDWFC 03,W
04722:  MOVWF  FEA
04724:  BTFSS  FEF.2
04726:  BRA    481C
....................                { 
....................                   (*(Ploo[loo] + flash_col)) = 'B'; 
04728:  CLRF   03
0472A:  MOVFF  182,02
0472E:  BCF    FD8.0
04730:  RLCF   02,F
04732:  RLCF   03,F
04734:  MOVF   02,W
04736:  ADDLW  A9
04738:  MOVWF  FE9
0473A:  MOVLW  00
0473C:  ADDWFC 03,W
0473E:  MOVWF  FEA
04740:  MOVFF  FEC,1A3
04744:  MOVF   FED,F
04746:  MOVFF  FEF,1A2
0474A:  MOVLW  06
0474C:  ADDWF  xA2,W
0474E:  MOVWF  01
04750:  MOVLW  00
04752:  ADDWFC xA3,W
04754:  MOVFF  01,FE9
04758:  MOVWF  FEA
0475A:  MOVLW  42
0475C:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+1)) = 'L'; 
0475E:  CLRF   03
04760:  MOVFF  182,02
04764:  BCF    FD8.0
04766:  RLCF   02,F
04768:  RLCF   03,F
0476A:  MOVF   02,W
0476C:  ADDLW  A9
0476E:  MOVWF  FE9
04770:  MOVLW  00
04772:  ADDWFC 03,W
04774:  MOVWF  FEA
04776:  MOVFF  FEC,1A3
0477A:  MOVF   FED,F
0477C:  MOVFF  FEF,1A2
04780:  MOVLW  06
04782:  ADDWF  xA2,F
04784:  MOVLW  00
04786:  ADDWFC xA3,F
04788:  MOVLW  01
0478A:  ADDWF  xA2,W
0478C:  MOVWF  01
0478E:  MOVLW  00
04790:  ADDWFC xA3,W
04792:  MOVFF  01,FE9
04796:  MOVWF  FEA
04798:  MOVLW  4C
0479A:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+2)) = 'K'; 
0479C:  CLRF   03
0479E:  MOVFF  182,02
047A2:  BCF    FD8.0
047A4:  RLCF   02,F
047A6:  RLCF   03,F
047A8:  MOVF   02,W
047AA:  ADDLW  A9
047AC:  MOVWF  FE9
047AE:  MOVLW  00
047B0:  ADDWFC 03,W
047B2:  MOVWF  FEA
047B4:  MOVFF  FEC,1A3
047B8:  MOVF   FED,F
047BA:  MOVFF  FEF,1A2
047BE:  MOVLW  06
047C0:  ADDWF  xA2,F
047C2:  MOVLW  00
047C4:  ADDWFC xA3,F
047C6:  MOVLW  02
047C8:  ADDWF  xA2,W
047CA:  MOVWF  01
047CC:  MOVLW  00
047CE:  ADDWFC xA3,W
047D0:  MOVFF  01,FE9
047D4:  MOVWF  FEA
047D6:  MOVLW  4B
047D8:  MOVWF  FEF
....................                   if(!MUTED_FLAG) FLASH_REG[Loo_FREG[loo]] = Loo_FL[loo]; 
047DA:  MOVF   x80,F
047DC:  BNZ   481A
047DE:  CLRF   03
047E0:  MOVF   x82,W
047E2:  ADDLW  BF
047E4:  MOVWF  FE9
047E6:  MOVLW  00
047E8:  ADDWFC 03,W
047EA:  MOVWF  FEA
047EC:  CLRF   03
047EE:  MOVF   FEF,W
047F0:  ADDLW  9E
047F2:  MOVWF  01
047F4:  MOVLW  00
047F6:  ADDWFC 03,F
047F8:  MOVFF  03,1A3
047FC:  CLRF   03
047FE:  MOVF   x82,W
04800:  ADDLW  CA
04802:  MOVWF  FE9
04804:  MOVLW  00
04806:  ADDWFC 03,W
04808:  MOVWF  FEA
0480A:  MOVFF  FEF,1A4
0480E:  MOVFF  1A3,FEA
04812:  MOVFF  01,FE9
04816:  MOVFF  1A4,FEF
....................                } 
0481A:  BRA    4B20
....................                else if(FLT_LOG[loo] & RUN_BIT) 
0481C:  CLRF   03
0481E:  MOVF   x82,W
04820:  ADDLW  6A
04822:  MOVWF  FE9
04824:  MOVLW  01
04826:  ADDWFC 03,W
04828:  MOVWF  FEA
0482A:  BTFSS  FEF.5
0482C:  BRA    48E2
....................                { 
....................                   (*(Ploo[loo] + flash_col)) = 'R'; 
0482E:  CLRF   03
04830:  MOVFF  182,02
04834:  BCF    FD8.0
04836:  RLCF   02,F
04838:  RLCF   03,F
0483A:  MOVF   02,W
0483C:  ADDLW  A9
0483E:  MOVWF  FE9
04840:  MOVLW  00
04842:  ADDWFC 03,W
04844:  MOVWF  FEA
04846:  MOVFF  FEC,1A3
0484A:  MOVF   FED,F
0484C:  MOVFF  FEF,1A2
04850:  MOVLW  06
04852:  ADDWF  xA2,W
04854:  MOVWF  01
04856:  MOVLW  00
04858:  ADDWFC xA3,W
0485A:  MOVFF  01,FE9
0485E:  MOVWF  FEA
04860:  MOVLW  52
04862:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+1)) = 'U'; 
04864:  CLRF   03
04866:  MOVFF  182,02
0486A:  BCF    FD8.0
0486C:  RLCF   02,F
0486E:  RLCF   03,F
04870:  MOVF   02,W
04872:  ADDLW  A9
04874:  MOVWF  FE9
04876:  MOVLW  00
04878:  ADDWFC 03,W
0487A:  MOVWF  FEA
0487C:  MOVFF  FEC,1A3
04880:  MOVF   FED,F
04882:  MOVFF  FEF,1A2
04886:  MOVLW  06
04888:  ADDWF  xA2,F
0488A:  MOVLW  00
0488C:  ADDWFC xA3,F
0488E:  MOVLW  01
04890:  ADDWF  xA2,W
04892:  MOVWF  01
04894:  MOVLW  00
04896:  ADDWFC xA3,W
04898:  MOVFF  01,FE9
0489C:  MOVWF  FEA
0489E:  MOVLW  55
048A0:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+2)) = 'N'; 
048A2:  CLRF   03
048A4:  MOVFF  182,02
048A8:  BCF    FD8.0
048AA:  RLCF   02,F
048AC:  RLCF   03,F
048AE:  MOVF   02,W
048B0:  ADDLW  A9
048B2:  MOVWF  FE9
048B4:  MOVLW  00
048B6:  ADDWFC 03,W
048B8:  MOVWF  FEA
048BA:  MOVFF  FEC,1A3
048BE:  MOVF   FED,F
048C0:  MOVFF  FEF,1A2
048C4:  MOVLW  06
048C6:  ADDWF  xA2,F
048C8:  MOVLW  00
048CA:  ADDWFC xA3,F
048CC:  MOVLW  02
048CE:  ADDWF  xA2,W
048D0:  MOVWF  01
048D2:  MOVLW  00
048D4:  ADDWFC xA3,W
048D6:  MOVFF  01,FE9
048DA:  MOVWF  FEA
048DC:  MOVLW  4E
048DE:  MOVWF  FEF
....................                } 
048E0:  BRA    4B20
....................                else if(FLT_LOG[loo] & SER_BIT) 
048E2:  CLRF   03
048E4:  MOVF   x82,W
048E6:  ADDLW  6A
048E8:  MOVWF  FE9
048EA:  MOVLW  01
048EC:  ADDWFC 03,W
048EE:  MOVWF  FEA
048F0:  BTFSS  FEF.1
048F2:  BRA    49A8
....................                { 
....................                   (*(Ploo[loo] + flash_col)) = 'S'; 
048F4:  CLRF   03
048F6:  MOVFF  182,02
048FA:  BCF    FD8.0
048FC:  RLCF   02,F
048FE:  RLCF   03,F
04900:  MOVF   02,W
04902:  ADDLW  A9
04904:  MOVWF  FE9
04906:  MOVLW  00
04908:  ADDWFC 03,W
0490A:  MOVWF  FEA
0490C:  MOVFF  FEC,1A3
04910:  MOVF   FED,F
04912:  MOVFF  FEF,1A2
04916:  MOVLW  06
04918:  ADDWF  xA2,W
0491A:  MOVWF  01
0491C:  MOVLW  00
0491E:  ADDWFC xA3,W
04920:  MOVFF  01,FE9
04924:  MOVWF  FEA
04926:  MOVLW  53
04928:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+1)) = 'R'; 
0492A:  CLRF   03
0492C:  MOVFF  182,02
04930:  BCF    FD8.0
04932:  RLCF   02,F
04934:  RLCF   03,F
04936:  MOVF   02,W
04938:  ADDLW  A9
0493A:  MOVWF  FE9
0493C:  MOVLW  00
0493E:  ADDWFC 03,W
04940:  MOVWF  FEA
04942:  MOVFF  FEC,1A3
04946:  MOVF   FED,F
04948:  MOVFF  FEF,1A2
0494C:  MOVLW  06
0494E:  ADDWF  xA2,F
04950:  MOVLW  00
04952:  ADDWFC xA3,F
04954:  MOVLW  01
04956:  ADDWF  xA2,W
04958:  MOVWF  01
0495A:  MOVLW  00
0495C:  ADDWFC xA3,W
0495E:  MOVFF  01,FE9
04962:  MOVWF  FEA
04964:  MOVLW  52
04966:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+2)) = 'V'; 
04968:  CLRF   03
0496A:  MOVFF  182,02
0496E:  BCF    FD8.0
04970:  RLCF   02,F
04972:  RLCF   03,F
04974:  MOVF   02,W
04976:  ADDLW  A9
04978:  MOVWF  FE9
0497A:  MOVLW  00
0497C:  ADDWFC 03,W
0497E:  MOVWF  FEA
04980:  MOVFF  FEC,1A3
04984:  MOVF   FED,F
04986:  MOVFF  FEF,1A2
0498A:  MOVLW  06
0498C:  ADDWF  xA2,F
0498E:  MOVLW  00
04990:  ADDWFC xA3,F
04992:  MOVLW  02
04994:  ADDWF  xA2,W
04996:  MOVWF  01
04998:  MOVLW  00
0499A:  ADDWFC xA3,W
0499C:  MOVFF  01,FE9
049A0:  MOVWF  FEA
049A2:  MOVLW  56
049A4:  MOVWF  FEF
....................                } 
049A6:  BRA    4B20
....................                else if(FLT_LOG[loo] & LOW_BIT) 
049A8:  CLRF   03
049AA:  MOVF   x82,W
049AC:  ADDLW  6A
049AE:  MOVWF  FE9
049B0:  MOVLW  01
049B2:  ADDWFC 03,W
049B4:  MOVWF  FEA
049B6:  BTFSS  FEF.0
049B8:  BRA    4A6E
....................                { 
....................                   (*(Ploo[loo] + flash_col)) = 'L'; 
049BA:  CLRF   03
049BC:  MOVFF  182,02
049C0:  BCF    FD8.0
049C2:  RLCF   02,F
049C4:  RLCF   03,F
049C6:  MOVF   02,W
049C8:  ADDLW  A9
049CA:  MOVWF  FE9
049CC:  MOVLW  00
049CE:  ADDWFC 03,W
049D0:  MOVWF  FEA
049D2:  MOVFF  FEC,1A3
049D6:  MOVF   FED,F
049D8:  MOVFF  FEF,1A2
049DC:  MOVLW  06
049DE:  ADDWF  xA2,W
049E0:  MOVWF  01
049E2:  MOVLW  00
049E4:  ADDWFC xA3,W
049E6:  MOVFF  01,FE9
049EA:  MOVWF  FEA
049EC:  MOVLW  4C
049EE:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+1)) = 'O'; 
049F0:  CLRF   03
049F2:  MOVFF  182,02
049F6:  BCF    FD8.0
049F8:  RLCF   02,F
049FA:  RLCF   03,F
049FC:  MOVF   02,W
049FE:  ADDLW  A9
04A00:  MOVWF  FE9
04A02:  MOVLW  00
04A04:  ADDWFC 03,W
04A06:  MOVWF  FEA
04A08:  MOVFF  FEC,1A3
04A0C:  MOVF   FED,F
04A0E:  MOVFF  FEF,1A2
04A12:  MOVLW  06
04A14:  ADDWF  xA2,F
04A16:  MOVLW  00
04A18:  ADDWFC xA3,F
04A1A:  MOVLW  01
04A1C:  ADDWF  xA2,W
04A1E:  MOVWF  01
04A20:  MOVLW  00
04A22:  ADDWFC xA3,W
04A24:  MOVFF  01,FE9
04A28:  MOVWF  FEA
04A2A:  MOVLW  4F
04A2C:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+2)) = 'W'; 
04A2E:  CLRF   03
04A30:  MOVFF  182,02
04A34:  BCF    FD8.0
04A36:  RLCF   02,F
04A38:  RLCF   03,F
04A3A:  MOVF   02,W
04A3C:  ADDLW  A9
04A3E:  MOVWF  FE9
04A40:  MOVLW  00
04A42:  ADDWFC 03,W
04A44:  MOVWF  FEA
04A46:  MOVFF  FEC,1A3
04A4A:  MOVF   FED,F
04A4C:  MOVFF  FEF,1A2
04A50:  MOVLW  06
04A52:  ADDWF  xA2,F
04A54:  MOVLW  00
04A56:  ADDWFC xA3,F
04A58:  MOVLW  02
04A5A:  ADDWF  xA2,W
04A5C:  MOVWF  01
04A5E:  MOVLW  00
04A60:  ADDWFC xA3,W
04A62:  MOVFF  01,FE9
04A66:  MOVWF  FEA
04A68:  MOVLW  57
04A6A:  MOVWF  FEF
....................                } 
04A6C:  BRA    4B20
....................                else 
....................                { 
....................                   (*(Ploo[loo] + flash_col)) = ' '; 
04A6E:  CLRF   03
04A70:  MOVFF  182,02
04A74:  BCF    FD8.0
04A76:  RLCF   02,F
04A78:  RLCF   03,F
04A7A:  MOVF   02,W
04A7C:  ADDLW  A9
04A7E:  MOVWF  FE9
04A80:  MOVLW  00
04A82:  ADDWFC 03,W
04A84:  MOVWF  FEA
04A86:  MOVFF  FEC,1A3
04A8A:  MOVF   FED,F
04A8C:  MOVFF  FEF,1A2
04A90:  MOVLW  06
04A92:  ADDWF  xA2,W
04A94:  MOVWF  01
04A96:  MOVLW  00
04A98:  ADDWFC xA3,W
04A9A:  MOVFF  01,FE9
04A9E:  MOVWF  FEA
04AA0:  MOVLW  20
04AA2:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+1)) = ' '; 
04AA4:  CLRF   03
04AA6:  MOVFF  182,02
04AAA:  BCF    FD8.0
04AAC:  RLCF   02,F
04AAE:  RLCF   03,F
04AB0:  MOVF   02,W
04AB2:  ADDLW  A9
04AB4:  MOVWF  FE9
04AB6:  MOVLW  00
04AB8:  ADDWFC 03,W
04ABA:  MOVWF  FEA
04ABC:  MOVFF  FEC,1A3
04AC0:  MOVF   FED,F
04AC2:  MOVFF  FEF,1A2
04AC6:  MOVLW  06
04AC8:  ADDWF  xA2,F
04ACA:  MOVLW  00
04ACC:  ADDWFC xA3,F
04ACE:  MOVLW  01
04AD0:  ADDWF  xA2,W
04AD2:  MOVWF  01
04AD4:  MOVLW  00
04AD6:  ADDWFC xA3,W
04AD8:  MOVFF  01,FE9
04ADC:  MOVWF  FEA
04ADE:  MOVLW  20
04AE0:  MOVWF  FEF
....................                   (*(Ploo[loo] + flash_col+2)) = ' '; 
04AE2:  CLRF   03
04AE4:  MOVFF  182,02
04AE8:  BCF    FD8.0
04AEA:  RLCF   02,F
04AEC:  RLCF   03,F
04AEE:  MOVF   02,W
04AF0:  ADDLW  A9
04AF2:  MOVWF  FE9
04AF4:  MOVLW  00
04AF6:  ADDWFC 03,W
04AF8:  MOVWF  FEA
04AFA:  MOVFF  FEC,1A3
04AFE:  MOVF   FED,F
04B00:  MOVFF  FEF,1A2
04B04:  MOVLW  06
04B06:  ADDWF  xA2,F
04B08:  MOVLW  00
04B0A:  ADDWFC xA3,F
04B0C:  MOVLW  02
04B0E:  ADDWF  xA2,W
04B10:  MOVWF  01
04B12:  MOVLW  00
04B14:  ADDWFC xA3,W
04B16:  MOVFF  01,FE9
04B1A:  MOVWF  FEA
04B1C:  MOVLW  20
04B1E:  MOVWF  FEF
....................                } 
....................             } 
....................          } 
....................          loo++; 
04B20:  INCF   x82,F
....................       }while(loo < no_of_loos+1); 
04B22:  MOVLW  01
04B24:  MOVLB  0
04B26:  ADDWF  xA7,W
04B28:  MOVLB  1
04B2A:  SUBWF  x82,W
04B2C:  BTFSS  FD8.0
04B2E:  GOTO   405E
....................  
....................       //check to see if we need to stop flashing 
....................       if(MUTED_FLAG) 
04B32:  MOVF   x80,F
04B34:  BZ    4B72
....................       {   //Stop all flashing and beeps etc..... 
....................          FLASH_REG[0] = 0; 
04B36:  MOVLB  0
04B38:  CLRF   x9E
....................          FLASH_REG[1] = 0; 
04B3A:  CLRF   x9F
....................          ALARM_FLAG = 0; 
04B3C:  CLRF   xA1
....................          FLASH_FLAG = 0; 
04B3E:  CLRF   xA2
....................          text = "          "; 
04B40:  MOVLW  01
04B42:  MOVWF  FEA
04B44:  MOVLW  83
04B46:  MOVWF  FE9
04B48:  MOVLW  00
04B4A:  CALL   025C
04B4E:  TBLRD*-
04B50:  TBLRD*+
04B52:  MOVF   FF5,W
04B54:  MOVWF  FEE
04B56:  IORLW  00
04B58:  BNZ   4B50
....................          strcpy(&display_ram[0][line1_flash_A], &text); 
04B5A:  CLRF   FEA
04B5C:  MOVLW  E0
04B5E:  MOVWF  FE9
04B60:  MOVLW  01
04B62:  MOVWF  FE2
04B64:  MOVLW  83
04B66:  MOVWF  FE1
04B68:  MOVF   FE7,F
04B6A:  MOVFF  FE6,FEE
04B6E:  BNZ   4B68
04B70:  MOVLB  1
....................       } 
....................       //check to see if there is a new fault. 
....................       for(loo=1;loo<no_of_loos+1;loo++) 
04B72:  MOVLW  01
04B74:  MOVWF  x82
04B76:  MOVLW  01
04B78:  MOVLB  0
04B7A:  ADDWF  xA7,W
04B7C:  MOVLB  1
04B7E:  SUBWF  x82,W
04B80:  BC    4C4C
....................       { 
....................          if(FLT_LOG[loo] != PLT_LOG[loo]) 
04B82:  CLRF   03
04B84:  MOVF   x82,W
04B86:  ADDLW  6A
04B88:  MOVWF  FE9
04B8A:  MOVLW  01
04B8C:  ADDWFC 03,W
04B8E:  MOVWF  FEA
04B90:  MOVFF  FEF,1A2
04B94:  CLRF   03
04B96:  MOVF   x82,W
04B98:  ADDLW  75
04B9A:  MOVWF  FE9
04B9C:  MOVLW  01
04B9E:  ADDWFC 03,W
04BA0:  MOVWF  FEA
04BA2:  MOVF   FEF,W
04BA4:  SUBWF  xA2,W
04BA6:  BZ    4C1A
....................          { 
....................             SEND_FLT_FLAG = 1;      //when any new fault occurs send all info to webserver. 
04BA8:  MOVLW  01
04BAA:  MOVLB  0
04BAC:  MOVWF  xD5
....................             if(FLT_LOG[loo] & ERR_BIT) 
04BAE:  CLRF   03
04BB0:  MOVLB  1
04BB2:  MOVF   x82,W
04BB4:  ADDLW  6A
04BB6:  MOVWF  FE9
04BB8:  MOVLW  01
04BBA:  ADDWFC 03,W
04BBC:  MOVWF  FEA
04BBE:  BTFSS  FEF.3
04BC0:  BRA    4BE6
....................             { 
....................                text = "COMMS FAIL"; 
04BC2:  MOVLW  01
04BC4:  MOVWF  FEA
04BC6:  MOVLW  83
04BC8:  MOVWF  FE9
04BCA:  MOVLW  00
04BCC:  MOVLB  0
04BCE:  CALL   078E
04BD2:  TBLRD*-
04BD4:  TBLRD*+
04BD6:  MOVF   FF5,W
04BD8:  MOVWF  FEE
04BDA:  IORLW  00
04BDC:  BNZ   4BD4
....................                NEW_ALARM = 1; 
04BDE:  MOVLW  01
04BE0:  MOVLB  1
04BE2:  MOVWF  x81
....................             } 
04BE4:  BRA    4C1A
....................             else if (FLT_LOG[loo] & BLK_BIT) 
04BE6:  CLRF   03
04BE8:  MOVF   x82,W
04BEA:  ADDLW  6A
04BEC:  MOVWF  FE9
04BEE:  MOVLW  01
04BF0:  ADDWFC 03,W
04BF2:  MOVWF  FEA
04BF4:  BTFSS  FEF.2
04BF6:  BRA    4C1A
....................             { 
....................                text = "BLOCKAGE  "; 
04BF8:  MOVLW  01
04BFA:  MOVWF  FEA
04BFC:  MOVLW  83
04BFE:  MOVWF  FE9
04C00:  MOVLW  00
04C02:  MOVLB  0
04C04:  CALL   07AA
04C08:  TBLRD*-
04C0A:  TBLRD*+
04C0C:  MOVF   FF5,W
04C0E:  MOVWF  FEE
04C10:  IORLW  00
04C12:  BNZ   4C0A
....................                NEW_ALARM = 1; 
04C14:  MOVLW  01
04C16:  MOVLB  1
04C18:  MOVWF  x81
....................             } 
....................          } 
....................          PLT_LOG[loo] = FLT_LOG[loo];          
04C1A:  CLRF   03
04C1C:  MOVF   x82,W
04C1E:  ADDLW  75
04C20:  MOVWF  01
04C22:  MOVLW  01
04C24:  ADDWFC 03,F
04C26:  MOVFF  03,1A3
04C2A:  CLRF   03
04C2C:  MOVF   x82,W
04C2E:  ADDLW  6A
04C30:  MOVWF  FE9
04C32:  MOVLW  01
04C34:  ADDWFC 03,W
04C36:  MOVWF  FEA
04C38:  MOVFF  FEF,1A4
04C3C:  MOVFF  1A3,FEA
04C40:  MOVFF  01,FE9
04C44:  MOVFF  1A4,FEF
04C48:  INCF   x82,F
04C4A:  BRA    4B76
....................       } 
....................       if(NEW_ALARM) 
04C4C:  MOVF   x81,F
04C4E:  BZ    4C74
....................       {   //start flashing and beeps. 
....................          strcpy(&display_ram[0][line1_flash_A], &text); 
04C50:  CLRF   FEA
04C52:  MOVLW  E0
04C54:  MOVWF  FE9
04C56:  MOVLW  01
04C58:  MOVWF  FE2
04C5A:  MOVLW  83
04C5C:  MOVWF  FE1
04C5E:  MOVF   FE7,F
04C60:  MOVFF  FE6,FEE
04C64:  BNZ   4C5E
....................          MUTED_FLAG = 0; 
04C66:  CLRF   x80
....................          ALARM_FLAG = 1; 
04C68:  MOVLW  01
04C6A:  MOVLB  0
04C6C:  MOVWF  xA1
....................          FLASH_FLAG = 1; 
04C6E:  MOVWF  xA2
....................          FLASH_REG[0] |= BIT0; 
04C70:  BSF    x9E.0
04C72:  MOVLB  1
....................       } 
....................       if(check_USB_TO()) 
04C74:  MOVLB  0
04C76:  GOTO   2BAC
04C7A:  MOVF   01,F
04C7C:  BZ    4CE2
....................       { 
....................          if(!NO_USB) 
04C7E:  BTFSC  F85.1
04C80:  BRA    4C9C
....................          { 
....................             display_USB_warning(disp_warning); 
04C82:  MOVLW  01
04C84:  MOVLB  2
04C86:  MOVWF  x50
04C88:  MOVLB  0
04C8A:  CALL   2C42
....................             send_log_data_to_USB(); 
04C8E:  GOTO   312A
....................             display_USB_warning(rst_warning); 
04C92:  MOVLB  2
04C94:  CLRF   x50
04C96:  MOVLB  0
04C98:  CALL   2C42
....................          } 
....................          //WEB_TO++; 
....................          //if((WEB_TO >= W_HOUR) || (SEND_FLT_FLAG == 1)) 
....................          //{ 
....................             WEB_TO = 0; 
04C9C:  MOVLB  1
04C9E:  CLRF   xA1
....................             SEND_FLT_FLAG = 0; 
04CA0:  MOVLB  0
04CA2:  CLRF   xD5
....................             send_data_to_WEB(&FLT_LOG[0]); 
04CA4:  MOVLW  01
04CA6:  MOVLB  2
04CA8:  MOVWF  x51
04CAA:  MOVLW  6A
04CAC:  MOVWF  x50
04CAE:  MOVLB  0
04CB0:  CALL   3E2A
....................             if(no_of_loos >= 6) 
04CB4:  MOVF   xA7,W
04CB6:  SUBLW  05
04CB8:  BC    4CE2
....................             {   //wait 6 seconds and send the next block of three, if any. 
....................                delay_ms(6000); 
04CBA:  MOVLW  18
04CBC:  MOVLB  1
04CBE:  MOVWF  xA2
04CC0:  MOVLW  FA
04CC2:  MOVLB  2
04CC4:  MOVWF  xFC
04CC6:  MOVLB  0
04CC8:  CALL   0BF4
04CCC:  MOVLB  1
04CCE:  DECFSZ xA2,F
04CD0:  BRA    4CC0
....................                send_data_to_WEB(&FLT_LOG[3]); 
04CD2:  MOVLW  01
04CD4:  MOVLB  2
04CD6:  MOVWF  x51
04CD8:  MOVLW  6D
04CDA:  MOVWF  x50
04CDC:  MOVLB  0
04CDE:  CALL   3E2A
....................             } 
....................          //} 
....................       } 
04CE2:  GOTO   4058
....................    } 
.................... } 
*
04CE6:  SLEEP 

Configuration Fuses:
   Word  1: C215   VREGSLEEP INTRC_HP SOSC_DIG NOXINST HSH NOPLLEN FCMEN IESO
   Word  2: 7C7F   NOPUT BROWNOUT BORV18 ZPBORM NOWDT WDT1048576
   Word  3: 8901   RTCOSC_T1 CCP2C1 MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
